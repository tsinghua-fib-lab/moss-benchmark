diff --git a/.clangd b/.clangd
new file mode 100644
index 0000000..a6c41cc
--- /dev/null
+++ b/.clangd
@@ -0,0 +1,17 @@
+CompileFlags:
+  Add:
+    - -std=c++11
+    - -I/usr/include/c++/11
+    - -I/usr/include/x86_64-linux-gnu/c++/11
+    - -L/usr/lib/gcc/x86_64-linux-gnu/11
+    - -I./src
+    - -I./extern/pybind11/include
+    - -I./extern/rapidjson/include
+    - -I./extern/milo
+    - -I/usr/lib/gcc/x86_64-linux-gnu/12/include
+  Remove:
+    - -ccbin*
+    - -rdc*
+    - --options-file*
+    - --generate-code*
+    - -f*
diff --git a/.gitignore b/.gitignore
index 5a168aa..498de68 100644
--- a/.gitignore
+++ b/.gitignore
@@ -9,5 +9,7 @@ local/
 __pycache__
 CMakeSettings.json
 cmake-build-*
-
-frontend/replay/*
\ No newline at end of file
+extern/
+frontend/replay/*
+*.egg-info
+.cache/
\ No newline at end of file
diff --git a/CMakeLists.txt b/CMakeLists.txt
index 943923e..8445725 100644
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -1,6 +1,7 @@
 cmake_minimum_required(VERSION 3.0)
 project(cityflow)
 
+set(CMAKE_EXPORT_COMPILE_COMMANDS ON)
 set(CMAKE_CXX_STANDARD "11" CACHE STRING "")
 set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -Wall -DRAPIDJSON_HAS_STDSTRING=1")
 set(CMAKE_CXX_FLAGS_RELEASE "-O2")
@@ -8,7 +9,7 @@ set(CMAKE_CXX_FLAGS_DEBUG "-g")
 set(CMAKE_POSITION_INDEPENDENT_CODE ON)
 
 if(POLICY CMP0063)
-  cmake_policy(SET CMP0063 NEW)
+    cmake_policy(SET CMP0063 NEW)
 endif()
 
 if(NOT CMAKE_BUILD_TYPE)
@@ -24,17 +25,20 @@ set(REQUIRED_SUBMODULES
 
 foreach(REQUIRED_SUBMODULE ${REQUIRED_SUBMODULES})
     if(NOT EXISTS "${PROJECT_SOURCE_DIR}/${REQUIRED_SUBMODULE}")
-        # update submodule 
+        # update submodule
         # https://cliutils.gitlab.io/modern-cmake/chapters/projects/submodule.html
         find_package(Git QUIET)
+
         if(GIT_FOUND AND EXISTS "${PROJECT_SOURCE_DIR}/.git")
-        # Update submodules as needed
+            # Update submodules as needed
             option(GIT_SUBMODULE "Check submodules during build" ON)
+
             if(GIT_SUBMODULE)
                 message(STATUS "Submodule update, this may take some time...")
                 execute_process(COMMAND ${GIT_EXECUTABLE} submodule update --init --recursive
-                                WORKING_DIRECTORY ${CMAKE_CURRENT_SOURCE_DIR}
-                                RESULT_VARIABLE GIT_SUBMOD_RESULT)
+                    WORKING_DIRECTORY ${CMAKE_CURRENT_SOURCE_DIR}
+                    RESULT_VARIABLE GIT_SUBMOD_RESULT)
+
                 if(NOT GIT_SUBMOD_RESULT EQUAL "0")
                     message(FATAL_ERROR "git submodule update --init failed with ${GIT_SUBMOD_RESULT}, please checkout submodules")
                 endif()
@@ -59,18 +63,19 @@ add_subdirectory(src)
 
 # Tests
 find_package(GTest)
+
 if(GTEST_FOUND)
     enable_testing()
     add_subdirectory(tests)
 endif()
 
-if (${CMAKE_BUILD_TYPE} STREQUAL Debug)
+if(${CMAKE_BUILD_TYPE} STREQUAL Debug)
     add_subdirectory(tools/debug)
 endif()
 
 pybind11_add_module(${PROJECT_NAME} MODULE src/cityflow.cpp)
 target_link_libraries(${PROJECT_NAME} PRIVATE ${PROJECT_LIB_NAME})
+
 if(VERSION)
     target_compile_definitions(${PROJECT_NAME} PRIVATE -DVERSION=${VERSION})
 endif()
-
diff --git a/extern/pybind11 b/extern/pybind11
deleted file mode 160000
index a8ee79d..0000000
--- a/extern/pybind11
+++ /dev/null
@@ -1 +0,0 @@
-Subproject commit a8ee79d08e9705e2903d5c20327d343ad1b70870
diff --git a/extern/rapidjson b/extern/rapidjson
deleted file mode 160000
index 7b3d971..0000000
--- a/extern/rapidjson
+++ /dev/null
@@ -1 +0,0 @@
-Subproject commit 7b3d971b261ab624f745e9450b1620157e39cce5
diff --git a/src/cityflow.cpp b/src/cityflow.cpp
index 2cb43be..0472588 100644
--- a/src/cityflow.cpp
+++ b/src/cityflow.cpp
@@ -1,5 +1,5 @@
-#include "engine/engine.h"
 #include "engine/archive.h"
+#include "engine/engine.h"
 
 #include "pybind11/pybind11.h"
 #include "pybind11/stl.h"
@@ -8,41 +8,81 @@ namespace py = pybind11;
 using namespace py::literals;
 
 PYBIND11_MODULE(cityflow, m) {
-    py::class_<CityFlow::Engine>(m, "Engine")
-        .def(py::init<const std::string&, int>(),
-            "config_file"_a,
-            "thread_num"_a=1
-        )
-        .def("next_step", &CityFlow::Engine::nextStep)
-        .def("get_vehicle_count", &CityFlow::Engine::getVehicleCount)
-        .def("get_vehicles", &CityFlow::Engine::getVehicles, "include_waiting"_a=false)
-        .def("get_lane_vehicle_count", &CityFlow::Engine::getLaneVehicleCount)
-        .def("get_lane_waiting_vehicle_count", &CityFlow::Engine::getLaneWaitingVehicleCount)
-        .def("get_lane_vehicles", &CityFlow::Engine::getLaneVehicles)
-        .def("get_vehicle_speed", &CityFlow::Engine::getVehicleSpeed)
-        .def("get_vehicle_info", &CityFlow::Engine::getVehicleInfo, "vehicle_id"_a)
-        .def("get_vehicle_distance", &CityFlow::Engine::getVehicleDistance)
-        .def("get_leader", &CityFlow::Engine::getLeader, "vehicle_id"_a)
-        .def("get_current_time", &CityFlow::Engine::getCurrentTime)
-        .def("get_average_travel_time", &CityFlow::Engine::getAverageTravelTime)
-        .def("set_tl_phase", &CityFlow::Engine::setTrafficLightPhase, "intersection_id"_a, "phase_id"_a)
-        .def("set_vehicle_speed", &CityFlow::Engine::setVehicleSpeed, "vehicle_id"_a, "speed"_a)
-        .def("set_replay_file", &CityFlow::Engine::setReplayLogFile, "replay_file"_a)
-        .def("set_random_seed", &CityFlow::Engine::setRandomSeed, "seed"_a)
-        .def("set_save_replay", &CityFlow::Engine::setSaveReplay, "open"_a)
-        .def("push_vehicle", (void (CityFlow::Engine::*)(const std::map<std::string, double>&, const std::vector<std::string>&)) &CityFlow::Engine::pushVehicle)
-        .def("reset", &CityFlow::Engine::reset, "seed"_a=false)
-        .def("load", &CityFlow::Engine::load, "archive"_a)
-        .def("snapshot", &CityFlow::Engine::snapshot)
-        .def("load_from_file", &CityFlow::Engine::loadFromFile, "path"_a)
-        .def("set_vehicle_route", &CityFlow::Engine::setRoute, "vehicle_id"_a, "route"_a);
+  py::class_<CityFlow::Engine>(m, "Engine")
+      .def(py::init<const std::string &, int>(), "config_file"_a,
+           "thread_num"_a = 1)
+      .def("_get_junction_count", &CityFlow::Engine::get_junction_count)
+      .def("_get_junction_phase_counts",
+           &CityFlow::Engine::get_junction_phase_counts)
+      .def("_get_running_vehicle_count",
+           &CityFlow::Engine::get_running_vehicle_count)
+      .def("_get_finished_vehicle_count",
+           &CityFlow::Engine::get_finished_vehicle_count)
+      .def("_get_departed_vehicle_average_traveling_time",
+           &CityFlow::Engine::get_departed_vehicle_average_traveling_time)
+      .def("_get_finished_vehicle_average_traveling_time",
+           &CityFlow::Engine::get_finished_vehicle_average_traveling_time)
+      .def("_get_lane_lengths", &CityFlow::Engine::get_lane_lengths)
+      .def("_get_lane_vehicle_counts",
+           &CityFlow::Engine::get_lane_vehicle_counts)
+      .def("_get_lane_waiting_vehicle_counts",
+           &CityFlow::Engine::get_lane_waiting_vehicle_counts,
+           "speed_threshold"_a = 0.1)
+      .def("_get_lane_waiting_at_end_vehicle_counts",
+           &CityFlow::Engine::get_lane_waiting_at_end_vehicle_counts,
+           "speed_threshold"_a = 0.1, "distance_to_end"_a = 100)
+      .def("_get_vehicle_road_speed", &CityFlow::Engine::get_vehicle_road_speed)
+      .def("_get_vehicle_road_speed_id",
+           &CityFlow::Engine::get_vehicle_road_speed_id)
+      .def("_get_junction_inout_lanes",
+           &CityFlow::Engine::get_junction_inout_lanes)
+      .def("_get_junction_phase_lanes",
+           &CityFlow::Engine::get_junction_phase_lanes)
+      .def("_set_tl_phase", &CityFlow::Engine::set_tl_phase, "junction_id"_a,
+           "phase_id"_a)
+      .def("_set_tl_phase_batch", &CityFlow::Engine::set_tl_phase_batch,
+           "junction_ids"_a, "phase_ids"_a)
+      .def("_next_step", &CityFlow::Engine::next_step, "n"_a)
+      .def("next_step", &CityFlow::Engine::nextStep)
+      .def("get_vehicle_count", &CityFlow::Engine::getVehicleCount)
+      .def("get_vehicles", &CityFlow::Engine::getVehicles,
+           "include_waiting"_a = false)
+      .def("get_lane_vehicle_count", &CityFlow::Engine::getLaneVehicleCount)
+      .def("get_lane_waiting_vehicle_count",
+           &CityFlow::Engine::getLaneWaitingVehicleCount)
+      .def("get_lane_vehicles", &CityFlow::Engine::getLaneVehicles)
+      .def("get_vehicle_speed", &CityFlow::Engine::getVehicleSpeed)
+      .def("get_vehicle_info", &CityFlow::Engine::getVehicleInfo,
+           "vehicle_id"_a)
+      .def("get_vehicle_distance", &CityFlow::Engine::getVehicleDistance)
+      .def("get_leader", &CityFlow::Engine::getLeader, "vehicle_id"_a)
+      .def("get_current_time", &CityFlow::Engine::getCurrentTime)
+      .def("get_average_travel_time", &CityFlow::Engine::getAverageTravelTime)
+      .def("set_tl_phase", &CityFlow::Engine::setTrafficLightPhase,
+           "intersection_id"_a, "phase_id"_a)
+      .def("set_vehicle_speed", &CityFlow::Engine::setVehicleSpeed,
+           "vehicle_id"_a, "speed"_a)
+      .def("set_replay_file", &CityFlow::Engine::setReplayLogFile,
+           "replay_file"_a)
+      .def("set_random_seed", &CityFlow::Engine::setRandomSeed, "seed"_a)
+      .def("set_save_replay", &CityFlow::Engine::setSaveReplay, "open"_a)
+      .def("push_vehicle",
+           (void(CityFlow::Engine::*)(const std::map<std::string, double> &,
+                                      const std::vector<std::string> &)) &
+               CityFlow::Engine::pushVehicle)
+      .def("reset", &CityFlow::Engine::reset, "seed"_a = false)
+      .def("load", &CityFlow::Engine::load, "archive"_a)
+      .def("snapshot", &CityFlow::Engine::snapshot)
+      .def("load_from_file", &CityFlow::Engine::loadFromFile, "path"_a)
+      .def("set_vehicle_route", &CityFlow::Engine::setRoute, "vehicle_id"_a,
+           "route"_a);
 
-    py::class_<CityFlow::Archive>(m, "Archive")
-        .def(py::init<const CityFlow::Engine&>())
-        .def("dump", &CityFlow::Archive::dump, "path"_a);
+  py::class_<CityFlow::Archive>(m, "Archive")
+      .def(py::init<const CityFlow::Engine &>())
+      .def("dump", &CityFlow::Archive::dump, "path"_a);
 #ifdef VERSION
-    m.attr("__version__") = VERSION;
+  m.attr("__version__") = VERSION;
 #else
-    m.attr("__version__") = "dev";
+  m.attr("__version__") = "dev";
 #endif
 }
\ No newline at end of file
diff --git a/src/engine/archive.cpp b/src/engine/archive.cpp
index 15570c6..f289d50 100644
--- a/src/engine/archive.cpp
+++ b/src/engine/archive.cpp
@@ -6,548 +6,616 @@
 
 namespace CityFlow {
 
-    Archive::Archive(const Engine &engine)
-    : step(engine.step), activeVehicleCount(engine.activeVehicleCount), rnd(engine.rnd),
-      finishedVehicleCnt(engine.finishedVehicleCnt), cumulativeTravelTime(engine.cumulativeTravelTime) {
-        // copy the vehicle Pool
-        vehiclePool = copyVehiclePool(engine.vehiclePool);
-
-        // record the information of each drivable object
-        for (const auto &drivable : engine.roadnet.getDrivables()) {
-            auto result = drivablesArchive.emplace(drivable, DrivableArchive());
-            assert(result.second);
-            archiveDrivable(drivable, result.first->second);
-        }
-
-        // record the information of each flow
-        for (const auto &flow : engine.flows) {
-            auto result = flowsArchive.emplace(&flow, FlowArchive());
-            assert(result.second);
-            archiveFlow(&flow, result.first->second);
-        }
-
-        //record the information of each traffic light
-        for (const auto &intersection : engine.roadnet.getIntersections()) {
-            const auto &light = &intersection.getTrafficLight();
-            auto result = trafficLightsArchive.emplace(&intersection, TrafficLightArchive());
-            assert(result.second);
-            archiveTrafficLight(light, result.first->second);
-        }
-
+Archive::Archive(const Engine &engine)
+    : step(engine.step), activeVehicleCount(engine.activeVehicleCount),
+      rnd(engine.rnd), finishedVehicleCnt(engine.finishedVehicleCnt),
+      cumulativeTravelTime(engine.cumulativeTravelTime) {
+  // copy the vehicle Pool
+  vehiclePool = copyVehiclePool(engine.vehiclePool);
+
+  // record the information of each drivable object
+  for (const auto &drivable : engine.roadnet.getDrivables()) {
+    auto result = drivablesArchive.emplace(drivable, DrivableArchive());
+    assert(result.second);
+    archiveDrivable(drivable, result.first->second);
+  }
+
+  // record the information of each flow
+  for (const auto &flow : engine.flows) {
+    auto result = flowsArchive.emplace(&flow, FlowArchive());
+    assert(result.second);
+    archiveFlow(&flow, result.first->second);
+  }
+
+  // record the information of each traffic light
+  for (const auto &intersection : engine.roadnet.getIntersections()) {
+    const auto &light = &intersection.getTrafficLight();
+    auto result =
+        trafficLightsArchive.emplace(&intersection, TrafficLightArchive());
+    assert(result.second);
+    archiveTrafficLight(light, result.first->second);
+  }
+}
+
+Vehicle *Archive::getNewPointer(const VehiclePool &vehiclePool,
+                                const Vehicle *old) {
+  if (!old)
+    return nullptr;
+  int priority = old->getPriority();
+  auto result = vehiclePool.find(priority);
+  assert(result != vehiclePool.end());
+  return result->second.first;
+}
+
+void Archive::archiveDrivable(const Drivable *drivable,
+                              Archive::DrivableArchive &drivableArchive) {
+  for (const auto &vehicle : drivable->getVehicles())
+    drivableArchive.vehicles.emplace_back(getNewPointer(vehiclePool, vehicle));
+  if (drivable->isLane()) {
+    const Lane *lane = static_cast<const Lane *>(drivable);
+    for (const auto &vehicle : lane->getWaitingBuffer()) {
+      drivableArchive.waitingBuffer.emplace_back(
+          getNewPointer(vehiclePool, vehicle));
+    }
+    drivableArchive.history = lane->history;
+    drivableArchive.historyVehicleNum = lane->historyVehicleNum;
+    drivableArchive.historyAverageSpeed = lane->historyAverageSpeed;
+  }
+}
+
+void Archive::archiveFlow(const Flow *flow, Archive::FlowArchive &flowArchive) {
+  flowArchive.currentTime = flow->currentTime;
+  flowArchive.nowTime = flow->nowTime;
+  flowArchive.cnt = flow->cnt;
+}
+
+void Archive::archiveTrafficLight(
+    const TrafficLight *light,
+    Archive::TrafficLightArchive &trafficLightArchive) {
+  trafficLightArchive.curPhaseIndex = light->curPhaseIndex;
+  trafficLightArchive.remainDuration = light->remainDuration;
+}
+
+void Archive::resume(Engine &engine) const {
+  engine.step = step;
+  engine.activeVehicleCount = activeVehicleCount;
+  for (auto &veh : engine.vehiclePool) {
+    auto vehicle = veh.second.first;
+    delete vehicle;
+  }
+  engine.vehiclePool = copyVehiclePool(vehiclePool);
+  engine.vehicleMap.clear();
+  for (const auto &iter : engine.vehiclePool) {
+    Vehicle *vehicle = iter.second.first;
+    engine.vehicleMap.emplace(vehicle->getId(), vehicle);
+  }
+  engine.rnd = rnd;
+  for (auto &threadVeh : engine.threadVehiclePool)
+    threadVeh.clear();
+  for (const auto &pair : engine.vehiclePool) {
+    const auto &vehicle = pair.second.first;
+    size_t threadIndex = pair.second.second;
+    engine.threadVehiclePool[threadIndex].emplace(vehicle);
+  }
+  for (auto &drivable : engine.roadnet.getDrivables()) {
+    const auto &archive = drivablesArchive.find(drivable)->second;
+    drivable->vehicles.clear();
+    for (const auto &vehicle : archive.vehicles) {
+      drivable->vehicles.emplace_back(
+          getNewPointer(engine.vehiclePool, vehicle));
     }
 
-    Vehicle *Archive::getNewPointer(const VehiclePool &vehiclePool, const Vehicle *old) {
-        if (!old) return nullptr;
-        int priority = old->getPriority();
-        auto result = vehiclePool.find(priority);
-        assert(result != vehiclePool.end());
-        return result->second.first;
+    if (drivable->isLane()) {
+      Lane *lane = static_cast<Lane *>(drivable);
+      lane->waitingBuffer.clear();
+      for (const auto &vehicle : archive.waitingBuffer) {
+        lane->waitingBuffer.emplace_back(
+            getNewPointer(engine.vehiclePool, vehicle));
+      }
+      lane->history = archive.history;
+      lane->historyVehicleNum = archive.historyVehicleNum;
+      lane->historyAverageSpeed = archive.historyAverageSpeed;
+    }
+  }
+  for (auto &flow : engine.flows) {
+    const auto &archive = flowsArchive.find(&flow)->second;
+    flow.currentTime = archive.currentTime;
+    flow.nowTime = archive.nowTime;
+    flow.cnt = archive.cnt;
+  }
+  for (auto &intersection : engine.roadnet.getIntersections()) {
+    auto &light = intersection.getTrafficLight();
+    const auto &archive = trafficLightsArchive.find(&intersection)->second;
+    light.remainDuration = archive.remainDuration;
+    light.curPhaseIndex = archive.curPhaseIndex;
+  }
+  engine.finishedVehicleCnt = this->finishedVehicleCnt;
+  engine.cumulativeTravelTime = this->cumulativeTravelTime;
+}
+
+Archive::VehiclePool Archive::copyVehiclePool(const VehiclePool &src) {
+  VehiclePool newPool;
+  for (const auto &veh : src) {
+    const Vehicle *oldVehicle = veh.second.first;
+    Vehicle *newVehicle = new Vehicle(*oldVehicle);
+    newPool.emplace(oldVehicle->getPriority(),
+                    std::make_pair(newVehicle, veh.second.second));
+  }
+
+  // update the vehicle pointers
+  for (const auto &veh : newPool) {
+    Vehicle *vehicle = veh.second.first;
+    vehicle->laneChangeInfo.partner =
+        getNewPointer(newPool, vehicle->laneChangeInfo.partner);
+    vehicle->controllerInfo.leader =
+        getNewPointer(newPool, vehicle->controllerInfo.leader);
+    vehicle->controllerInfo.blocker =
+        getNewPointer(newPool, vehicle->controllerInfo.blocker);
+
+    std::shared_ptr<LaneChange> laneChange = vehicle->laneChange;
+    laneChange->targetLeader = getNewPointer(newPool, laneChange->targetLeader);
+    laneChange->targetFollower =
+        getNewPointer(newPool, laneChange->targetFollower);
+    if (laneChange->signalRecv) {
+      laneChange->signalRecv =
+          getNewPointer(newPool, laneChange->signalRecv->source)
+              ->laneChange->signalSend;
     }
+  }
+  return newPool;
+}
+
+void Archive::dump(const std::string &fileName) const {
+  rapidjson::Document jsonRoot;
+  jsonRoot.SetObject();
+  auto &allocator = jsonRoot.GetAllocator();
+
+  jsonRoot.AddMember("step", static_cast<unsigned>(this->step), allocator);
+  jsonRoot.AddMember("activeVehicleCount",
+                     static_cast<unsigned>(this->activeVehicleCount),
+                     allocator);
+
+  std::stringstream rndStringStream;
+  rndStringStream << this->rnd;
+  rapidjson::Value rndValue;
+  rndValue.SetString(rndStringStream.str().c_str(), jsonRoot.GetAllocator());
+  jsonRoot.AddMember("rnd", rndValue, allocator);
+  // Serialize the mt19937 object
+
+  dumpVehicles(jsonRoot);
+  dumpDrivables(jsonRoot);
+  dumpFlows(jsonRoot);
+  dumpTrafficLights(jsonRoot);
+
+  jsonRoot.AddMember("finishedVehicleCnt", finishedVehicleCnt, allocator);
+  jsonRoot.AddMember("cumulativeTravelTime", cumulativeTravelTime, allocator);
+
+  writeJsonToFile(fileName, jsonRoot);
+}
+
+rapidjson::Value Archive::dumpVehicle(const Vehicle &vehicle,
+                                      rapidjson::Document &jsonRoot) const {
+  rapidjson::Value vehicleValue(rapidjson::kObjectType);
+  auto &allocator = jsonRoot.GetAllocator();
+
+  vehicleValue.AddMember("priority", vehicle.priority, allocator);
+  vehicleValue.AddMember(
+      "id", rapidjson::Value(vehicle.getId(), allocator).Move(), allocator);
+  vehicleValue.AddMember("enterTime", vehicle.enterTime, allocator);
+
+  // save vehicleInfo
+  vehicleValue.AddMember("speed", vehicle.vehicleInfo.speed, allocator);
+  vehicleValue.AddMember("len", vehicle.vehicleInfo.len, allocator);
+  vehicleValue.AddMember("width", vehicle.vehicleInfo.width, allocator);
+  vehicleValue.AddMember("maxPosAcc", vehicle.vehicleInfo.maxPosAcc, allocator);
+  vehicleValue.AddMember("maxNegAcc", vehicle.vehicleInfo.maxNegAcc, allocator);
+  vehicleValue.AddMember("usualPosAcc", vehicle.vehicleInfo.usualPosAcc,
+                         allocator);
+  vehicleValue.AddMember("usualNegAcc", vehicle.vehicleInfo.usualNegAcc,
+                         allocator);
+  vehicleValue.AddMember("minGap", vehicle.vehicleInfo.minGap, allocator);
+  vehicleValue.AddMember("maxSpeed", vehicle.vehicleInfo.maxSpeed, allocator);
+  vehicleValue.AddMember("headwayTime", vehicle.vehicleInfo.headwayTime,
+                         allocator);
+  vehicleValue.AddMember("yieldDistance", vehicle.vehicleInfo.yieldDistance,
+                         allocator);
+  vehicleValue.AddMember("turnSpeed", vehicle.vehicleInfo.turnSpeed, allocator);
+
+  // save route
+  rapidjson::Value routeValue(rapidjson::kArrayType);
+  for (const auto &road : vehicle.controllerInfo.router.route) {
+    pushBackObjectAsMember(routeValue, road, allocator);
+  }
+  vehicleValue.AddMember("route", routeValue, allocator);
+
+  // save controllerInfo
+  vehicleValue.AddMember("dis", vehicle.controllerInfo.dis, allocator);
+  addObjectAsMember(vehicleValue, "drivable", vehicle.controllerInfo.drivable,
+                    allocator);
+  addObjectAsMember(vehicleValue, "prevDrivable",
+                    vehicle.controllerInfo.prevDrivable, allocator);
+
+  vehicleValue.AddMember("approachingIntersectionDistance",
+                         vehicle.controllerInfo.approachingIntersectionDistance,
+                         allocator);
+  vehicleValue.AddMember("gap", vehicle.controllerInfo.gap, allocator);
+  vehicleValue.AddMember(
+      "enterLaneLinkTime",
+      static_cast<unsigned>(vehicle.controllerInfo.enterLaneLinkTime),
+      allocator);
+
+  addObjectAsMember(vehicleValue, "leader", vehicle.controllerInfo.leader,
+                    allocator);
+  addObjectAsMember(vehicleValue, "blocker", vehicle.controllerInfo.blocker,
+                    allocator);
 
-    void Archive::archiveDrivable(const Drivable *drivable, Archive::DrivableArchive &drivableArchive) {
-        for (const auto &vehicle : drivable->getVehicles())
-            drivableArchive.vehicles.emplace_back(getNewPointer(vehiclePool, vehicle));
-        if (drivable->isLane()) {
-            const Lane *lane = static_cast<const Lane *>(drivable);
-            for (const auto &vehicle : lane->getWaitingBuffer()) {
-                drivableArchive.waitingBuffer.emplace_back(getNewPointer(vehiclePool, vehicle));
-            }
-            drivableArchive.history = lane->history;
-            drivableArchive.historyVehicleNum = lane->historyVehicleNum;
-            drivableArchive.historyAverageSpeed = lane->historyAverageSpeed;
-        }
+  vehicleValue.AddMember("end", vehicle.controllerInfo.end, allocator);
+  vehicleValue.AddMember("running", vehicle.controllerInfo.running, allocator);
 
+  // save lane change info
+  vehicleValue.AddMember("partnerType", vehicle.laneChangeInfo.partnerType,
+                         allocator);
+  addObjectAsMember(vehicleValue, "partner", vehicle.laneChangeInfo.partner,
+                    allocator);
+  vehicleValue.AddMember("offset", vehicle.laneChangeInfo.offset, allocator);
+  if (vehicle.laneChange->signalSend) {
+    auto &signal = vehicle.laneChange->signalSend;
+    vehicleValue.AddMember("laneChangeUrgency", signal->urgency, allocator);
+    vehicleValue.AddMember("laneChangeDirection", signal->direction, allocator);
+    addObjectAsMember(vehicleValue, "laneChangeTarget", signal->target,
+                      allocator);
+  }
+  if (vehicle.laneChange->signalRecv) {
+    auto &signal = vehicle.laneChange->signalRecv;
+    addObjectAsMember(vehicleValue, "laneChangeRecv", signal->source,
+                      allocator);
+  }
+  addObjectAsMember(vehicleValue, "laneChangeLeader",
+                    vehicle.laneChange->targetLeader, allocator);
+  addObjectAsMember(vehicleValue, "laneChangeFollower",
+                    vehicle.laneChange->targetFollower, allocator);
+  vehicleValue.AddMember("laneChangeWaitingTime",
+                         vehicle.laneChange->waitingTime, allocator);
+  vehicleValue.AddMember("laneChanging", vehicle.laneChange->changing,
+                         allocator);
+  vehicleValue.AddMember("laneChangeLastTime",
+                         vehicle.laneChange->lastChangeTime, allocator);
+
+  return vehicleValue;
+}
+
+void Archive::dumpVehicles(rapidjson::Document &jsonRoot) const {
+  rapidjson::Value vehicleArray(rapidjson::kArrayType);
+  auto &allocator = jsonRoot.GetAllocator();
+  for (const auto &iter : this->vehiclePool) {
+    const auto &vehicle = iter.second.first;
+    assert(vehicle);
+    rapidjson::Value vehicleValue = dumpVehicle(*vehicle, jsonRoot);
+    vehicleArray.PushBack(vehicleValue, allocator);
+  }
+  jsonRoot.AddMember("vehicles", vehicleArray, allocator);
+}
+
+void Archive::dumpDrivables(rapidjson::Document &jsonRoot) const {
+  rapidjson::Value drivablesValue(rapidjson::kObjectType);
+  auto &allocator = jsonRoot.GetAllocator();
+  for (const auto &iter : drivablesArchive) {
+    rapidjson::Value drivableValue(rapidjson::kObjectType);
+    const Drivable *drivable = iter.first;
+    const DrivableArchive &drivableArchive = iter.second;
+
+    // save vehicles
+    rapidjson::Value vehicleList(rapidjson::kArrayType);
+    for (const auto &vehicle : drivableArchive.vehicles) {
+      pushBackObjectAsMember(vehicleList, vehicle, allocator);
     }
-
-    void Archive::archiveFlow(const Flow *flow, Archive::FlowArchive &flowArchive) {
-        flowArchive.currentTime = flow->currentTime;
-        flowArchive.nowTime = flow->nowTime;
-        flowArchive.cnt = flow->cnt;
+    drivableValue.AddMember("vehicles", vehicleList, allocator);
+
+    if (drivable->isLane()) {
+      // save waiting buffer
+      rapidjson::Value waitingBuffer(rapidjson::kArrayType);
+      for (const auto &vehicle : drivableArchive.waitingBuffer) {
+        pushBackObjectAsMember(waitingBuffer, vehicle, allocator);
+      }
+      drivableValue.AddMember("waitingBuffer", waitingBuffer, allocator);
+
+      // save history
+      rapidjson::Value historyValue(rapidjson::kArrayType);
+      for (const auto &record : drivableArchive.history) {
+        historyValue.PushBack(record.vehicleNum, allocator);
+        historyValue.PushBack(record.averageSpeed, allocator);
+      }
+      drivableValue.AddMember("history", historyValue, allocator);
+      drivableValue.AddMember("historyVehicleNum",
+                              drivableArchive.historyVehicleNum, allocator);
+      drivableValue.AddMember("historyAverageSpeed",
+                              drivableArchive.historyAverageSpeed, allocator);
     }
 
-    void Archive::archiveTrafficLight(const TrafficLight *light, Archive::TrafficLightArchive &trafficLightArchive) {
-        trafficLightArchive.curPhaseIndex = light->curPhaseIndex;
-        trafficLightArchive.remainDuration = light->remainDuration;
+    drivablesValue.AddMember(
+        rapidjson::Value(drivable->getId(), allocator).Move(), drivableValue,
+        allocator);
+  }
+  jsonRoot.AddMember("drivables", drivablesValue, allocator);
+}
+
+void Archive::dumpFlows(rapidjson::Document &jsonRoot) const {
+  rapidjson::Value flowsValue(rapidjson::kObjectType);
+  auto &allocator = jsonRoot.GetAllocator();
+  for (const auto &iter : flowsArchive) {
+    const auto &flow = iter.first;
+    const auto &flowArchive = iter.second;
+
+    rapidjson::Value flowValue(rapidjson::kObjectType);
+    flowValue.AddMember("nowTime", flowArchive.nowTime, allocator);
+    flowValue.AddMember("currentTime", flowArchive.currentTime, allocator);
+    flowValue.AddMember("cnt", static_cast<unsigned>(flowArchive.cnt),
+                        allocator);
+
+    flowsValue.AddMember(rapidjson::Value(flow->getId(), allocator).Move(),
+                         flowValue, allocator);
+  }
+  jsonRoot.AddMember("flows", flowsValue, allocator);
+}
+
+void Archive::dumpTrafficLights(rapidjson::Document &jsonRoot) const {
+  rapidjson::Value trafficLightsValue(rapidjson::kObjectType);
+  auto &allocator = jsonRoot.GetAllocator();
+  for (const auto &iter : trafficLightsArchive) {
+    const auto &intersection = iter.first;
+    const auto &trafficLightArchive = iter.second;
+
+    rapidjson::Value trafficLightValue(rapidjson::kObjectType);
+    trafficLightValue.AddMember("remainDuration",
+                                trafficLightArchive.remainDuration, allocator);
+    trafficLightValue.AddMember(
+        "curPhaseIndex",
+        static_cast<unsigned>(trafficLightArchive.curPhaseIndex), allocator);
+
+    trafficLightsValue.AddMember(
+        rapidjson::Value(intersection->getId(), allocator).Move(),
+        trafficLightValue, allocator);
+  }
+  jsonRoot.AddMember("trafficLights", trafficLightsValue, allocator);
+}
+
+Archive::Archive(Engine &engine, const std::string &filename) {
+  // read from file
+  rapidjson::Document jsonRoot;
+  readJsonFromFile(filename, jsonRoot);
+
+  std::mt19937 rndTemp;
+  // restore random seed
+  std::string rndString = getJsonMember<const char *>("rnd", jsonRoot);
+  std::istringstream istr(rndString);
+  istr >> rnd;
+
+  // restore engine info
+  step = getJsonMember<unsigned>("step", jsonRoot);
+  activeVehicleCount = getJsonMember<unsigned>("activeVehicleCount", jsonRoot);
+
+  // restore vehiclePool
+  auto &vehiclesValue = getJsonMemberArray("vehicles", jsonRoot);
+  std::map<const std::string, Vehicle *> vehicleDict;
+  for (auto &vehicleValue : vehiclesValue.GetArray()) {
+    VehicleInfo vehicleInfo;
+    vehicleInfo.speed = getJsonMember<double>("speed", vehicleValue);
+    vehicleInfo.len = getJsonMember<double>("len", vehicleValue);
+    vehicleInfo.width = getJsonMember<double>("width", vehicleValue);
+    vehicleInfo.maxPosAcc = getJsonMember<double>("maxPosAcc", vehicleValue);
+    vehicleInfo.maxNegAcc = getJsonMember<double>("maxNegAcc", vehicleValue);
+    vehicleInfo.usualPosAcc =
+        getJsonMember<double>("usualPosAcc", vehicleValue);
+    vehicleInfo.usualNegAcc =
+        getJsonMember<double>("usualNegAcc", vehicleValue);
+    vehicleInfo.minGap = getJsonMember<double>("minGap", vehicleValue);
+    vehicleInfo.maxSpeed = getJsonMember<double>("maxSpeed", vehicleValue);
+    vehicleInfo.headwayTime =
+        getJsonMember<double>("headwayTime", vehicleValue);
+    vehicleInfo.yieldDistance =
+        getJsonMember<double>("yieldDistance", vehicleValue);
+    vehicleInfo.turnSpeed = getJsonMember<double>("turnSpeed", vehicleValue);
+
+    // Rebuild Route
+    std::vector<Road *> route;
+    auto &routeValue = getJsonMemberArray("route", vehicleValue);
+    for (const auto &roadValue : routeValue.GetArray()) {
+      const auto &roadId = roadValue.GetString();
+      route.emplace_back(engine.roadnet.getRoadById(roadId));
     }
-
-    void Archive::resume(Engine &engine) const{
-        engine.step = step;
-        engine.activeVehicleCount = activeVehicleCount;
-        for (auto &veh : engine.vehiclePool) {
-            auto vehicle = veh.second.first;
-            delete vehicle;
-        }
-        engine.vehiclePool = copyVehiclePool(vehiclePool);
-        engine.vehicleMap.clear();
-        for (const auto &iter : engine.vehiclePool) {
-            Vehicle *vehicle = iter.second.first;
-            engine.vehicleMap.emplace(vehicle->getId(), vehicle);
-        }
-        engine.rnd = rnd;
-        for (auto &threadVeh : engine.threadVehiclePool)
-            threadVeh.clear();
-        for (const auto &pair : engine.vehiclePool) {
-            const auto &vehicle = pair.second.first;
-            size_t threadIndex = pair.second.second;
-            engine.threadVehiclePool[threadIndex].emplace(vehicle);
-        }
-        for (auto &drivable : engine.roadnet.getDrivables()) {
-            const auto &archive = drivablesArchive.find(drivable)->second;
-            drivable->vehicles.clear();
-            for (const auto &vehicle : archive.vehicles) {
-                drivable->vehicles.emplace_back(getNewPointer(engine.vehiclePool, vehicle));
-            }
-
-            if (drivable->isLane()) {
-                Lane *lane = static_cast<Lane *>(drivable);
-                lane->waitingBuffer.clear();
-                for (const auto &vehicle : archive.waitingBuffer) {
-                    lane->waitingBuffer.emplace_back(getNewPointer(engine.vehiclePool, vehicle));
-                }
-                lane->history = archive.history;
-                lane->historyVehicleNum = archive.historyVehicleNum;
-                lane->historyAverageSpeed = archive.historyAverageSpeed;
-            }
-        }
-        for (auto &flow : engine.flows) {
-            const auto &archive = flowsArchive.find(&flow)->second;
-            flow.currentTime = archive.currentTime;
-            flow.nowTime = archive.nowTime;
-            flow.cnt = archive.cnt;
-        }
-        for (auto &intersection : engine.roadnet.getIntersections()) {
-            auto &light = intersection.getTrafficLight();
-            const auto &archive = trafficLightsArchive.find(&intersection)->second;
-            light.remainDuration = archive.remainDuration;
-            light.curPhaseIndex = archive.curPhaseIndex;
-        }
-        engine.finishedVehicleCnt = this->finishedVehicleCnt;
-        engine.cumulativeTravelTime = this->cumulativeTravelTime;
+    vehicleInfo.route = std::make_shared<Route>(route);
+
+    Vehicle *vehicle = new Vehicle(
+        vehicleInfo, getJsonMember<const char *>("id", vehicleValue), &engine);
+
+    auto enterTime = getJsonMember<double>("enterTime", vehicleValue);
+    vehicle->enterTime = enterTime;
+
+    auto priority = getJsonMember<int>("priority", vehicleValue);
+    vehicle->priority = priority;
+    vehiclePool.emplace(priority,
+                        std::make_pair(vehicle, rndTemp() % engine.threadNum));
+    vehicleDict.emplace(vehicle->getId(), vehicle);
+
+    auto &controllerInfo = vehicle->controllerInfo;
+    controllerInfo.dis = getJsonMember<double>("dis", vehicleValue);
+    controllerInfo.approachingIntersectionDistance =
+        getJsonMember<double>("approachingIntersectionDistance", vehicleValue);
+    controllerInfo.gap = getJsonMember<double>("gap", vehicleValue);
+    controllerInfo.enterLaneLinkTime =
+        getJsonMember<int>("enterLaneLinkTime", vehicleValue);
+    controllerInfo.end = getJsonMember<bool>("end", vehicleValue);
+    controllerInfo.running = getJsonMember<bool>("running", vehicleValue);
+
+    auto &laneChangeInfo = vehicle->laneChangeInfo;
+    laneChangeInfo.partnerType =
+        getJsonMember<int>("partnerType", vehicleValue);
+    laneChangeInfo.offset = getJsonMember<double>("offset", vehicleValue);
+
+    // Construct the laneChange Object
+    vehicle->laneChange = std::make_shared<SimpleLaneChange>(vehicle);
+    auto &laneChange = vehicle->laneChange;
+    rapidjson::Value::ConstMemberIterator sendItr =
+        vehicleValue.FindMember("laneChangeUrgency");
+    if (sendItr != vehicleValue.MemberEnd()) {
+      auto signal = std::make_shared<LaneChange::Signal>();
+      signal->source = vehicle;
+      signal->urgency = sendItr->value.GetInt();
+      signal->direction =
+          getJsonMember<int>("laneChangeDirection", vehicleValue);
+      laneChange->signalSend = signal;
     }
-
-    Archive::VehiclePool Archive::copyVehiclePool(const VehiclePool &src) {
-        VehiclePool newPool;
-        for (const auto &veh : src) {
-            const Vehicle *oldVehicle = veh.second.first;
-            Vehicle *newVehicle = new Vehicle(*oldVehicle);
-            newPool.emplace(oldVehicle->getPriority(), std::make_pair(newVehicle, veh.second.second));
-        }
-
-        // update the vehicle pointers
-        for (const auto &veh : newPool) {
-            Vehicle *vehicle = veh.second.first;
-            vehicle->laneChangeInfo.partner = getNewPointer(newPool, vehicle->laneChangeInfo.partner);
-            vehicle->controllerInfo.leader  = getNewPointer(newPool, vehicle->controllerInfo.leader);
-            vehicle->controllerInfo.blocker = getNewPointer(newPool, vehicle->controllerInfo.blocker);
-
-            std::shared_ptr<LaneChange> laneChange = vehicle->laneChange;
-            laneChange->targetLeader = getNewPointer(newPool, laneChange->targetLeader);
-            laneChange->targetFollower = getNewPointer(newPool, laneChange->targetFollower);
-            if (laneChange->signalRecv) {
-                laneChange->signalRecv = getNewPointer(newPool, laneChange->signalRecv->source)->laneChange->signalSend;
-            }
-        }
-        return newPool;
+    laneChange->waitingTime =
+        getJsonMember<double>("laneChangeWaitingTime", vehicleValue);
+    laneChange->changing = getJsonMember<bool>("laneChanging", vehicleValue);
+    laneChange->lastChangeTime =
+        getJsonMember<double>("laneChangeLastTime", vehicleValue);
+  }
+
+  // restore pointer relations
+  for (auto &vehicleValue : vehiclesValue.GetArray()) {
+    std::string vehicleId = getJsonMember<const char *>("id", vehicleValue);
+    Vehicle *vehicle = vehicleDict[vehicleId];
+    const char *drivableId =
+        getJsonMember<const char *>("drivable", vehicleValue, nullptr);
+    assert(drivableId);
+    vehicle->controllerInfo.drivable =
+        engine.roadnet.getDrivableById(std::string(drivableId));
+    assert(vehicle->controllerInfo.drivable);
+    const char *prevDrivableId =
+        getJsonMember<const char *>("prevDrivable", vehicleValue, nullptr);
+    if (prevDrivableId) {
+      vehicle->controllerInfo.prevDrivable =
+          engine.roadnet.getDrivableById(std::string(prevDrivableId));
     }
-
-    void Archive::dump(const std::string &fileName) const {
-        rapidjson::Document jsonRoot;
-        jsonRoot.SetObject();
-        auto &allocator = jsonRoot.GetAllocator();
-
-        jsonRoot.AddMember("step", static_cast<unsigned>(this->step), allocator);
-        jsonRoot.AddMember("activeVehicleCount", static_cast<unsigned>(this->activeVehicleCount), allocator);
-
-        std::stringstream rndStringStream;
-        rndStringStream << this->rnd;
-        rapidjson::Value rndValue;
-        rndValue.SetString(rndStringStream.str().c_str(), jsonRoot.GetAllocator());
-        jsonRoot.AddMember("rnd", rndValue, allocator);
-        // Serialize the mt19937 object
-
-        dumpVehicles(jsonRoot);
-        dumpDrivables(jsonRoot);
-        dumpFlows(jsonRoot);
-        dumpTrafficLights(jsonRoot);
-
-        jsonRoot.AddMember("finishedVehicleCnt", finishedVehicleCnt, allocator);
-        jsonRoot.AddMember("cumulativeTravelTime", cumulativeTravelTime, allocator);
-
-        writeJsonToFile(fileName, jsonRoot);
+    const char *leaderId =
+        getJsonMember<const char *>("leader", vehicleValue, nullptr);
+    if (leaderId) {
+      vehicle->controllerInfo.leader = vehicleDict[leaderId];
     }
-
-    rapidjson::Value Archive::dumpVehicle(const Vehicle &vehicle, rapidjson::Document &jsonRoot) const {
-        rapidjson::Value vehicleValue(rapidjson::kObjectType);
-        auto &allocator = jsonRoot.GetAllocator();
-
-        vehicleValue.AddMember("priority", vehicle.priority, allocator);
-        vehicleValue.AddMember("id",
-                rapidjson::Value(vehicle.getId(), allocator).Move(),
-                allocator);
-        vehicleValue.AddMember("enterTime", vehicle.enterTime, allocator);
-
-        // save vehicleInfo
-        vehicleValue.AddMember("speed", vehicle.vehicleInfo.speed, allocator);
-        vehicleValue.AddMember("len", vehicle.vehicleInfo.len, allocator);
-        vehicleValue.AddMember("width", vehicle.vehicleInfo.width, allocator);
-        vehicleValue.AddMember("maxPosAcc", vehicle.vehicleInfo.maxPosAcc, allocator);
-        vehicleValue.AddMember("maxNegAcc", vehicle.vehicleInfo.maxNegAcc, allocator);
-        vehicleValue.AddMember("usualPosAcc", vehicle.vehicleInfo.usualPosAcc, allocator);
-        vehicleValue.AddMember("usualNegAcc", vehicle.vehicleInfo.usualNegAcc, allocator);
-        vehicleValue.AddMember("minGap", vehicle.vehicleInfo.minGap, allocator);
-        vehicleValue.AddMember("maxSpeed", vehicle.vehicleInfo.maxSpeed, allocator);
-        vehicleValue.AddMember("headwayTime", vehicle.vehicleInfo.headwayTime, allocator);
-        vehicleValue.AddMember("yieldDistance", vehicle.vehicleInfo.yieldDistance, allocator);
-        vehicleValue.AddMember("turnSpeed", vehicle.vehicleInfo.turnSpeed, allocator);
-
-
-        // save route
-        rapidjson::Value routeValue(rapidjson::kArrayType);
-        for (const auto &road : vehicle.controllerInfo.router.route) {
-            pushBackObjectAsMember(routeValue, road, allocator);
-        }
-        vehicleValue.AddMember("route", routeValue, allocator);
-
-        // save controllerInfo
-        vehicleValue.AddMember("dis", vehicle.controllerInfo.dis, allocator);
-        addObjectAsMember(vehicleValue, "drivable", vehicle.controllerInfo.drivable, allocator);
-        addObjectAsMember(vehicleValue, "prevDrivable", vehicle.controllerInfo.prevDrivable, allocator);
-
-        vehicleValue.AddMember("approachingIntersectionDistance",
-                vehicle.controllerInfo.approachingIntersectionDistance, allocator);
-        vehicleValue.AddMember("gap", vehicle.controllerInfo.gap, allocator);
-        vehicleValue.AddMember("enterLaneLinkTime",
-                static_cast<unsigned>(vehicle.controllerInfo.enterLaneLinkTime), allocator);
-
-        addObjectAsMember(vehicleValue, "leader", vehicle.controllerInfo.leader, allocator);
-        addObjectAsMember(vehicleValue, "blocker", vehicle.controllerInfo.blocker, allocator);
-
-        vehicleValue.AddMember("end", vehicle.controllerInfo.end, allocator);
-        vehicleValue.AddMember("running", vehicle.controllerInfo.running, allocator);
-
-        // save lane change info
-        vehicleValue.AddMember("partnerType", vehicle.laneChangeInfo.partnerType, allocator);
-        addObjectAsMember(vehicleValue, "partner", vehicle.laneChangeInfo.partner, allocator);
-        vehicleValue.AddMember("offset", vehicle.laneChangeInfo.offset, allocator);
-        if (vehicle.laneChange->signalSend) {
-            auto &signal = vehicle.laneChange->signalSend;
-            vehicleValue.AddMember("laneChangeUrgency", signal->urgency, allocator);
-            vehicleValue.AddMember("laneChangeDirection", signal->direction, allocator);
-            addObjectAsMember(vehicleValue, "laneChangeTarget", signal->target, allocator);
-        }
-        if (vehicle.laneChange->signalRecv) {
-            auto &signal = vehicle.laneChange->signalRecv;
-            addObjectAsMember(vehicleValue, "laneChangeRecv", signal->source, allocator);
-        }
-        addObjectAsMember(vehicleValue, "laneChangeLeader", vehicle.laneChange->targetLeader, allocator);
-        addObjectAsMember(vehicleValue, "laneChangeFollower", vehicle.laneChange->targetFollower, allocator);
-        vehicleValue.AddMember("laneChangeWaitingTime", vehicle.laneChange->waitingTime, allocator);
-        vehicleValue.AddMember("laneChanging", vehicle.laneChange->changing, allocator);
-        vehicleValue.AddMember("laneChangeLastTime", vehicle.laneChange->lastChangeTime, allocator);
-
-        return vehicleValue;
+    const char *blockerId =
+        getJsonMember<const char *>("blocker", vehicleValue, nullptr);
+    if (blockerId) {
+      vehicle->controllerInfo.blocker = vehicleDict[blockerId];
     }
-
-    void Archive::dumpVehicles(rapidjson::Document &jsonRoot) const {
-        rapidjson::Value vehicleArray(rapidjson::kArrayType);
-        auto &allocator = jsonRoot.GetAllocator();
-        for (const auto &iter : this->vehiclePool) {
-            const auto &vehicle = iter.second.first;
-            assert(vehicle);
-            rapidjson::Value vehicleValue = dumpVehicle(*vehicle, jsonRoot);
-            vehicleArray.PushBack(vehicleValue, allocator);
-        }
-        jsonRoot.AddMember("vehicles", vehicleArray, allocator);
+    const char *partnerId =
+        getJsonMember<const char *>("partner", vehicleValue, nullptr);
+    if (partnerId) {
+      vehicle->laneChangeInfo.partner = vehicleDict[partnerId];
     }
 
-    void Archive::dumpDrivables(rapidjson::Document &jsonRoot) const {
-        rapidjson::Value drivablesValue(rapidjson::kObjectType);
-        auto &allocator = jsonRoot.GetAllocator();
-        for (const auto &iter : drivablesArchive) {
-            rapidjson::Value drivableValue(rapidjson::kObjectType);
-            const Drivable *drivable = iter.first;
-            const DrivableArchive &drivableArchive = iter.second;
-
-            // save vehicles
-            rapidjson::Value vehicleList(rapidjson::kArrayType);
-            for (const auto &vehicle : drivableArchive.vehicles) {
-                pushBackObjectAsMember(vehicleList, vehicle, allocator);
-            }
-            drivableValue.AddMember("vehicles", vehicleList, allocator);
-
-            if (drivable->isLane()) {
-                // save waiting buffer
-                rapidjson::Value waitingBuffer(rapidjson::kArrayType);
-                for (const auto &vehicle : drivableArchive.waitingBuffer) {
-                    pushBackObjectAsMember(waitingBuffer, vehicle, allocator);
-                }
-                drivableValue.AddMember("waitingBuffer", waitingBuffer, allocator);
-
-                //save history
-                rapidjson::Value historyValue(rapidjson::kArrayType);
-                for (const auto &record : drivableArchive.history) {
-                    historyValue.PushBack(record.vehicleNum, allocator);
-                    historyValue.PushBack(record.averageSpeed, allocator);
-                }
-                drivableValue.AddMember("history", historyValue, allocator);
-                drivableValue.AddMember("historyVehicleNum", drivableArchive.historyVehicleNum, allocator);
-                drivableValue.AddMember("historyAverageSpeed", drivableArchive.historyAverageSpeed, allocator);
-            }
-
-            drivablesValue.AddMember(
-                    rapidjson::Value(drivable->getId(), allocator).Move(),
-                    drivableValue,
-                    allocator
-                    );
-        }
-        jsonRoot.AddMember("drivables", drivablesValue, allocator);
+    if (vehicle->laneChange->signalSend) {
+      auto &signal = vehicle->laneChange->signalSend;
+      const char *targetId = getJsonMember<const char *>("laneChangeTarget",
+                                                         vehicleValue, nullptr);
+      assert(targetId);
+      Drivable *target = engine.roadnet.getDrivableById(targetId);
+      assert(target->isLane());
+      signal->target = static_cast<Lane *>(target);
     }
 
-    void Archive::dumpFlows(rapidjson::Document &jsonRoot) const {
-        rapidjson::Value flowsValue(rapidjson::kObjectType);
-        auto &allocator = jsonRoot.GetAllocator();
-        for (const auto &iter : flowsArchive) {
-            const auto &flow = iter.first;
-            const auto &flowArchive = iter.second;
-
-            rapidjson::Value flowValue(rapidjson::kObjectType);
-            flowValue.AddMember("nowTime", flowArchive.nowTime, allocator);
-            flowValue.AddMember("currentTime", flowArchive.currentTime, allocator);
-            flowValue.AddMember("cnt", static_cast<unsigned>(flowArchive.cnt), allocator);
-
-            flowsValue.AddMember(
-                    rapidjson::Value(flow->getId(), allocator).Move(),
-                    flowValue,
-                    allocator);
-        }
-        jsonRoot.AddMember("flows", flowsValue, allocator);
+    rapidjson::Value::ConstMemberIterator signalRecvIter =
+        vehicleValue.FindMember("laneChangeRecv");
+    if (signalRecvIter != vehicleValue.MemberEnd()) {
+      std::string sourceId = signalRecvIter->value.GetString();
+      vehicle->laneChange->signalRecv =
+          vehicleDict[sourceId]->laneChange->signalSend;
     }
 
-    void Archive::dumpTrafficLights(rapidjson::Document &jsonRoot) const {
-        rapidjson::Value trafficLightsValue(rapidjson::kObjectType);
-        auto &allocator = jsonRoot.GetAllocator();
-        for (const auto &iter : trafficLightsArchive) {
-            const auto &intersection = iter.first;
-            const auto &trafficLightArchive = iter.second;
-
-            rapidjson::Value trafficLightValue(rapidjson::kObjectType);
-            trafficLightValue.AddMember("remainDuration", trafficLightArchive.remainDuration, allocator);
-            trafficLightValue.AddMember("curPhaseIndex", static_cast<unsigned>(trafficLightArchive.curPhaseIndex), allocator);
-
-            trafficLightsValue.AddMember(
-                    rapidjson::Value(intersection->getId(), allocator).Move(),
-                    trafficLightValue,
-                    allocator);
-        }
-        jsonRoot.AddMember("trafficLights", trafficLightsValue, allocator);
+    const char *laneChangeLeaderId =
+        getJsonMember<const char *>("laneChangeLeader", vehicleValue, nullptr);
+    if (laneChangeLeaderId) {
+      vehicle->laneChange->targetLeader = vehicleDict[laneChangeLeaderId];
     }
 
-    Archive::Archive(Engine &engine, const std::string &filename) {
-        // read from file
-        rapidjson::Document jsonRoot;
-        readJsonFromFile(filename, jsonRoot);
-
-        std::mt19937 rndTemp;
-        // restore random seed
-        std::string rndString = getJsonMember<const char *>("rnd", jsonRoot);
-        std::istringstream istr(rndString);
-        istr >> rnd;
-
-        // restore engine info
-        step = getJsonMember<unsigned>("step", jsonRoot);
-        activeVehicleCount = getJsonMember<unsigned>("activeVehicleCount", jsonRoot);
-
-        // restore vehiclePool
-        auto &vehiclesValue = getJsonMemberArray("vehicles", jsonRoot);
-        std::map<const std::string, Vehicle *> vehicleDict;
-        for (auto &vehicleValue : vehiclesValue.GetArray()) {
-            VehicleInfo vehicleInfo;
-            vehicleInfo.speed = getJsonMember<double>("speed", vehicleValue);
-            vehicleInfo.len = getJsonMember<double>("len", vehicleValue);
-            vehicleInfo.width = getJsonMember<double>("width", vehicleValue);
-            vehicleInfo.maxPosAcc = getJsonMember<double>("maxPosAcc", vehicleValue);
-            vehicleInfo.maxNegAcc = getJsonMember<double>("maxNegAcc", vehicleValue);
-            vehicleInfo.usualPosAcc = getJsonMember<double>("usualPosAcc", vehicleValue);
-            vehicleInfo.usualNegAcc = getJsonMember<double>("usualNegAcc", vehicleValue);
-            vehicleInfo.minGap = getJsonMember<double>("minGap", vehicleValue);
-            vehicleInfo.maxSpeed = getJsonMember<double>("maxSpeed", vehicleValue);
-            vehicleInfo.headwayTime = getJsonMember<double>("headwayTime", vehicleValue);
-            vehicleInfo.yieldDistance = getJsonMember<double>("yieldDistance", vehicleValue);
-            vehicleInfo.turnSpeed = getJsonMember<double>("turnSpeed", vehicleValue);
-
-            // Rebuild Route
-            std::vector<Road *> route;
-            auto &routeValue = getJsonMemberArray("route", vehicleValue);
-            for (const auto &roadValue : routeValue.GetArray()) {
-                const auto &roadId = roadValue.GetString();
-                route.emplace_back(engine.roadnet.getRoadById(roadId));
-            }
-            vehicleInfo.route = std::make_shared<Route>(route);
-
-            Vehicle *vehicle = new Vehicle(vehicleInfo,
-                    getJsonMember<const char *>("id", vehicleValue), &engine);
-
-            auto enterTime = getJsonMember<double>("enterTime", vehicleValue);
-            vehicle->enterTime = enterTime;
-
-            auto priority = getJsonMember<int>("priority", vehicleValue);
-            vehicle->priority = priority;
-            vehiclePool.emplace(priority, std::make_pair(vehicle, rndTemp() % engine.threadNum));
-            vehicleDict.emplace(vehicle->getId(), vehicle);
-
-            auto &controllerInfo = vehicle->controllerInfo;
-            controllerInfo.dis = getJsonMember<double>("dis", vehicleValue);
-            controllerInfo.approachingIntersectionDistance =
-                    getJsonMember<double>("approachingIntersectionDistance", vehicleValue);
-            controllerInfo.gap = getJsonMember<double>("gap", vehicleValue);
-            controllerInfo.enterLaneLinkTime = getJsonMember<int>("enterLaneLinkTime", vehicleValue);
-            controllerInfo.end = getJsonMember<bool>("end", vehicleValue);
-            controllerInfo.running = getJsonMember<bool>("running", vehicleValue);
-
-            auto &laneChangeInfo = vehicle->laneChangeInfo;
-            laneChangeInfo.partnerType = getJsonMember<int>("partnerType", vehicleValue);
-            laneChangeInfo.offset = getJsonMember<double>("offset", vehicleValue);
-
-            // Construct the laneChange Object
-            vehicle->laneChange = std::make_shared<SimpleLaneChange>(vehicle);
-            auto &laneChange = vehicle->laneChange;
-            rapidjson::Value::ConstMemberIterator sendItr = vehicleValue.FindMember("laneChangeUrgency");
-            if (sendItr != vehicleValue.MemberEnd()) {
-                auto signal = std::make_shared<LaneChange::Signal>();
-                signal->source = vehicle;
-                signal->urgency = sendItr->value.GetInt();
-                signal->direction = getJsonMember<int>("laneChangeDirection", vehicleValue);
-                laneChange->signalSend = signal;
-            }
-            laneChange->waitingTime = getJsonMember<double>("laneChangeWaitingTime", vehicleValue);
-            laneChange->changing = getJsonMember<bool>("laneChanging", vehicleValue);
-            laneChange->lastChangeTime = getJsonMember<double>("laneChangeLastTime", vehicleValue);
-        }
-
-        // restore pointer relations
-        for (auto &vehicleValue : vehiclesValue.GetArray()) {
-            std::string vehicleId = getJsonMember<const char*>("id", vehicleValue);
-            Vehicle *vehicle = vehicleDict[vehicleId];
-            const char *drivableId = getJsonMember<const char *>("drivable", vehicleValue, nullptr);
-            assert(drivableId);
-            vehicle->controllerInfo.drivable = engine.roadnet.getDrivableById(std::string(drivableId));
-            assert(vehicle->controllerInfo.drivable);
-            const char *prevDrivableId = getJsonMember<const char *>("prevDrivable", vehicleValue, nullptr);
-            if (prevDrivableId) {
-                vehicle->controllerInfo.prevDrivable = engine.roadnet.getDrivableById(std::string(prevDrivableId));
-            }
-            const char *leaderId = getJsonMember<const char *>("leader", vehicleValue, nullptr);
-            if (leaderId) {
-                vehicle->controllerInfo.leader = vehicleDict[leaderId];
-            }
-            const char *blockerId = getJsonMember<const char *>("blocker", vehicleValue, nullptr);
-            if (blockerId) {
-                vehicle->controllerInfo.blocker = vehicleDict[blockerId];
-            }
-            const char *partnerId = getJsonMember<const char *>("partner", vehicleValue, nullptr);
-            if (partnerId) {
-                vehicle->laneChangeInfo.partner = vehicleDict[partnerId];
-            }
-
-            if (vehicle->laneChange->signalSend) {
-                auto &signal = vehicle->laneChange->signalSend;
-                const char *targetId = getJsonMember<const char *>("laneChangeTarget", vehicleValue, nullptr);
-                assert(targetId);
-                Drivable *target = engine.roadnet.getDrivableById(targetId);
-                assert(target->isLane());
-                signal->target = static_cast<Lane *>(target);
-            }
-
-            rapidjson::Value::ConstMemberIterator signalRecvIter = vehicleValue.FindMember("laneChangeRecv");
-            if (signalRecvIter != vehicleValue.MemberEnd()) {
-                std::string sourceId = signalRecvIter->value.GetString();
-                vehicle->laneChange->signalRecv = vehicleDict[sourceId]->laneChange->signalSend;
-            }
-
-            const char *laneChangeLeaderId = getJsonMember<const char*>("laneChangeLeader", vehicleValue, nullptr);
-            if (laneChangeLeaderId) {
-                vehicle->laneChange->targetLeader = vehicleDict[laneChangeLeaderId];
-            }
-
-            const char *laneChangeFollowerId = getJsonMember<const char*>("laneChangeFollower", vehicleValue, nullptr);
-            if (laneChangeFollowerId) {
-                vehicle->laneChange->targetFollower = vehicleDict[laneChangeFollowerId];
-            }
-        }
-
-        // Ensure partners in the same thread
-        for (auto &iter : vehiclePool) {
-            auto &vehicle = iter.second.first;
-            if (!vehicle->isReal()) {
-                assert(vehicle->hasPartner());
-                auto partnerPriority = vehicle->getPartner()->getPriority();
-                iter.second.second = vehiclePool[partnerPriority].second;
-            }
-        }
-
-        // restore drivables
-        auto &drivablesValue = getJsonMemberObject("drivables", jsonRoot);
-        for (auto &drivable : engine.roadnet.getDrivables()) {
-            auto &drivableValue = getJsonMemberObject(drivable->getId(), drivablesValue);
-            auto result = drivablesArchive.emplace(drivable, DrivableArchive());
-            assert(result.second);
-            auto &drivableArchive = result.first->second;
-
-            auto &vehiclesValue = getJsonMemberArray("vehicles", drivableValue);
-            for (auto &vehicleValue : vehiclesValue.GetArray()) {
-                std::string vehicleId = vehicleValue.GetString();
-                drivableArchive.vehicles.emplace_back(vehicleDict[vehicleId]);
-            }
-
-            if (drivable->isLane()) {
-                auto &waitingBufferValue = getJsonMemberArray("waitingBuffer", drivableValue);
-                for (auto &vehicleValue : waitingBufferValue.GetArray()) {
-                    std::string vehicleId = vehicleValue.GetString();
-                    drivableArchive.waitingBuffer.emplace_back(vehicleDict[vehicleId]);
-                }
-                auto &historyValue = getJsonMemberArray("history", drivableValue);
-                int cnt = 0;
-                int vehicleNum = 0;
-                for (auto &recordValue : historyValue.GetArray()) {
-                    if (cnt % 2) {
-                        double averageSpeed = recordValue.GetDouble();
-                        drivableArchive.history.emplace_back(vehicleNum, averageSpeed);
-                    } else {
-                        vehicleNum = recordValue.GetInt();
-                    }
-                    ++cnt;
-                }
-                drivableArchive.historyAverageSpeed = getJsonMember<double>("historyAverageSpeed", drivableValue);
-                drivableArchive.historyVehicleNum = getJsonMember<int>("historyVehicleNum", drivableValue);
-            }
-        }
-
-        // restore flows
-        auto &flowsValue = getJsonMemberObject("flows", jsonRoot);
-        for (auto &flow : engine.flows) {
-            auto &flowValue = getJsonMemberObject(flow.getId(), flowsValue);
-            auto result = flowsArchive.emplace(&flow, FlowArchive());
-            assert(result.second);
-            auto &flowArchive = result.first->second;
-            flowArchive.nowTime = getJsonMember<double>("nowTime", flowValue);
-            flowArchive.currentTime = getJsonMember<double>("currentTime", flowValue);
-            flowArchive.cnt = getJsonMember<int>("cnt", flowValue);
-        }
+    const char *laneChangeFollowerId = getJsonMember<const char *>(
+        "laneChangeFollower", vehicleValue, nullptr);
+    if (laneChangeFollowerId) {
+      vehicle->laneChange->targetFollower = vehicleDict[laneChangeFollowerId];
+    }
+  }
+
+  // Ensure partners in the same thread
+  for (auto &iter : vehiclePool) {
+    auto &vehicle = iter.second.first;
+    if (!vehicle->isReal()) {
+      assert(vehicle->hasPartner());
+      auto partnerPriority = vehicle->getPartner()->getPriority();
+      iter.second.second = vehiclePool[partnerPriority].second;
+    }
+  }
+
+  // restore drivables
+  auto &drivablesValue = getJsonMemberObject("drivables", jsonRoot);
+  for (auto &drivable : engine.roadnet.getDrivables()) {
+    auto &drivableValue =
+        getJsonMemberObject(drivable->getId(), drivablesValue);
+    auto result = drivablesArchive.emplace(drivable, DrivableArchive());
+    assert(result.second);
+    auto &drivableArchive = result.first->second;
+
+    auto &vehiclesValue = getJsonMemberArray("vehicles", drivableValue);
+    for (auto &vehicleValue : vehiclesValue.GetArray()) {
+      std::string vehicleId = vehicleValue.GetString();
+      drivableArchive.vehicles.emplace_back(vehicleDict[vehicleId]);
+    }
 
-        // restore trafficlights
-        auto &trafficLightsValue = getJsonMemberObject("trafficLights", jsonRoot);
-        for (auto &intersection : engine.roadnet.getIntersections()) {
-            auto &trafficLightValue = getJsonMemberObject(intersection.getId(), trafficLightsValue);
-            auto result = trafficLightsArchive.emplace(&intersection, TrafficLightArchive());
-            assert(result.second);
-            auto &trafficLightArchive = result.first->second;
-            trafficLightArchive.remainDuration = getJsonMember<double>("remainDuration", trafficLightValue);
-            trafficLightArchive.curPhaseIndex = getJsonMember<int>("curPhaseIndex", trafficLightValue);
+    if (drivable->isLane()) {
+      auto &waitingBufferValue =
+          getJsonMemberArray("waitingBuffer", drivableValue);
+      for (auto &vehicleValue : waitingBufferValue.GetArray()) {
+        std::string vehicleId = vehicleValue.GetString();
+        drivableArchive.waitingBuffer.emplace_back(vehicleDict[vehicleId]);
+      }
+      auto &historyValue = getJsonMemberArray("history", drivableValue);
+      int cnt = 0;
+      int vehicleNum = 0;
+      for (auto &recordValue : historyValue.GetArray()) {
+        if (cnt % 2) {
+          double averageSpeed = recordValue.GetDouble();
+          drivableArchive.history.emplace_back(vehicleNum, averageSpeed);
+        } else {
+          vehicleNum = recordValue.GetInt();
         }
-
-        finishedVehicleCnt = getJsonMember<int>("finishedVehicleCnt", jsonRoot);
-        cumulativeTravelTime = getJsonMember<double>("cumulativeTravelTime", jsonRoot);
+        ++cnt;
+      }
+      drivableArchive.historyAverageSpeed =
+          getJsonMember<double>("historyAverageSpeed", drivableValue);
+      drivableArchive.historyVehicleNum =
+          getJsonMember<int>("historyVehicleNum", drivableValue);
     }
-
-
-}
\ No newline at end of file
+  }
+
+  // restore flows
+  auto &flowsValue = getJsonMemberObject("flows", jsonRoot);
+  for (auto &flow : engine.flows) {
+    auto &flowValue = getJsonMemberObject(flow.getId(), flowsValue);
+    auto result = flowsArchive.emplace(&flow, FlowArchive());
+    assert(result.second);
+    auto &flowArchive = result.first->second;
+    flowArchive.nowTime = getJsonMember<double>("nowTime", flowValue);
+    flowArchive.currentTime = getJsonMember<double>("currentTime", flowValue);
+    flowArchive.cnt = getJsonMember<int>("cnt", flowValue);
+  }
+
+  // restore trafficlights
+  auto &trafficLightsValue = getJsonMemberObject("trafficLights", jsonRoot);
+  for (auto &intersection : engine.roadnet.getIntersections()) {
+    auto &trafficLightValue =
+        getJsonMemberObject(intersection.getId(), trafficLightsValue);
+    auto result =
+        trafficLightsArchive.emplace(&intersection, TrafficLightArchive());
+    assert(result.second);
+    auto &trafficLightArchive = result.first->second;
+    trafficLightArchive.remainDuration =
+        getJsonMember<double>("remainDuration", trafficLightValue);
+    trafficLightArchive.curPhaseIndex =
+        getJsonMember<int>("curPhaseIndex", trafficLightValue);
+  }
+
+  finishedVehicleCnt = getJsonMember<int>("finishedVehicleCnt", jsonRoot);
+  cumulativeTravelTime =
+      getJsonMember<double>("cumulativeTravelTime", jsonRoot);
+}
+
+} // namespace CityFlow
\ No newline at end of file
diff --git a/src/engine/archive.h b/src/engine/archive.h
index a40ff0c..d38edaa 100644
--- a/src/engine/archive.h
+++ b/src/engine/archive.h
@@ -1,96 +1,97 @@
 #ifndef CITYFLOW_ARCHIVE_H
 #define CITYFLOW_ARCHIVE_H
 
-#include "rapidjson/document.h"
 #include "rapidjson/allocators.h"
+#include "rapidjson/document.h"
 #include "roadnet/roadnet.h"
 
 #include <deque>
 
 namespace CityFlow {
-    class Engine;
-    class Flow;
-    class Vehicle;
-    class TrafficLight;
-
-    class Archive {
-    private:
-        using VehiclePool = std::map<int, std::pair<Vehicle *, int>>;
-        struct TrafficLightArchive {
-            double remainDuration;
-            int curPhaseIndex;
-        };
-
-        struct FlowArchive {
-            double nowTime;
-            double currentTime;
-            int cnt;
-        };
-
-        struct DrivableArchive {
-            std::list<Vehicle *> vehicles;
-            std::deque<Vehicle *> waitingBuffer;
-
-            std::list<Lane::HistoryRecord> history;
-            int    historyVehicleNum = 0;
-            double historyAverageSpeed = 0;
-        };
-
-        VehiclePool vehiclePool;
-        std::map<const Drivable *, DrivableArchive> drivablesArchive;
-        std::map<const Flow *, FlowArchive> flowsArchive;
-        std::map<const Intersection *, TrafficLightArchive> trafficLightsArchive;
-        size_t step;
-        size_t activeVehicleCount;
-        std::mt19937 rnd;
-
-        int finishedVehicleCnt;
-        double cumulativeTravelTime;
-
-        static VehiclePool copyVehiclePool(const VehiclePool& src);
-        static Vehicle *getNewPointer(const VehiclePool &vehiclePool, const Vehicle *old);
-        void archiveDrivable(const Drivable *drivable, DrivableArchive &drivableArchive);
-        void archiveFlow(const Flow *flow, FlowArchive &flowArchive);
-        void archiveTrafficLight(const TrafficLight *light, TrafficLightArchive &trafficLightArchive);
-
-        rapidjson::Value dumpVehicle(const Vehicle &vehicle, rapidjson::Document &jsonRoot) const;
-        void dumpVehicles(rapidjson::Document &jsonRoot) const;
-        void dumpDrivables(rapidjson::Document &jsonRoot) const;
-        void dumpFlows(rapidjson::Document &jsonRoot) const;
-        void dumpTrafficLights(rapidjson::Document &jsonRoot) const;
-
-        template <typename T>
-        static void addObjectAsMember(rapidjson::Value &jsonObject, const std::string &name,
-                                      const T &object, rapidjson::MemoryPoolAllocator<> &allocator) {
-            if (object) {
-                jsonObject.AddMember(
-                        rapidjson::Value(name, allocator).Move(),
-                        rapidjson::Value(object->getId(), allocator).Move(),
-                        allocator
-                        );
-            }
-        }
-
-        template <typename T>
-        static void pushBackObjectAsMember(rapidjson::Value &jsonObject,
-                                      const T &object, rapidjson::MemoryPoolAllocator<> &allocator) {
-            if (object) {
-                jsonObject.PushBack(
-                        rapidjson::Value(object->getId(), allocator).Move(),
-                        allocator
-                );
-            }
-        }
-
-    public:
-        Archive() = default;
-        explicit Archive(const Engine &engine);
-        Archive(Engine &engine, const std::string &filename);
-        void resume(Engine &engine) const;
-        void dump(const std::string &fileName) const;
-    };
-
-}
-
-
-#endif //CITYFLOW_ARCHIVE_H
+class Engine;
+class Flow;
+class Vehicle;
+class TrafficLight;
+
+class Archive {
+private:
+  using VehiclePool = std::map<int, std::pair<Vehicle *, int>>;
+  struct TrafficLightArchive {
+    double remainDuration;
+    int curPhaseIndex;
+  };
+
+  struct FlowArchive {
+    double nowTime;
+    double currentTime;
+    int cnt;
+  };
+
+  struct DrivableArchive {
+    std::list<Vehicle *> vehicles;
+    std::deque<Vehicle *> waitingBuffer;
+
+    std::list<Lane::HistoryRecord> history;
+    int historyVehicleNum = 0;
+    double historyAverageSpeed = 0;
+  };
+
+  VehiclePool vehiclePool;
+  std::map<const Drivable *, DrivableArchive> drivablesArchive;
+  std::map<const Flow *, FlowArchive> flowsArchive;
+  std::map<const Intersection *, TrafficLightArchive> trafficLightsArchive;
+  size_t step;
+  size_t activeVehicleCount;
+  std::mt19937 rnd;
+
+  int finishedVehicleCnt;
+  double cumulativeTravelTime;
+
+  static VehiclePool copyVehiclePool(const VehiclePool &src);
+  static Vehicle *getNewPointer(const VehiclePool &vehiclePool,
+                                const Vehicle *old);
+  void archiveDrivable(const Drivable *drivable,
+                       DrivableArchive &drivableArchive);
+  void archiveFlow(const Flow *flow, FlowArchive &flowArchive);
+  void archiveTrafficLight(const TrafficLight *light,
+                           TrafficLightArchive &trafficLightArchive);
+
+  rapidjson::Value dumpVehicle(const Vehicle &vehicle,
+                               rapidjson::Document &jsonRoot) const;
+  void dumpVehicles(rapidjson::Document &jsonRoot) const;
+  void dumpDrivables(rapidjson::Document &jsonRoot) const;
+  void dumpFlows(rapidjson::Document &jsonRoot) const;
+  void dumpTrafficLights(rapidjson::Document &jsonRoot) const;
+
+  template <typename T>
+  static void addObjectAsMember(rapidjson::Value &jsonObject,
+                                const std::string &name, const T &object,
+                                rapidjson::MemoryPoolAllocator<> &allocator) {
+    if (object) {
+      jsonObject.AddMember(rapidjson::Value(name, allocator).Move(),
+                           rapidjson::Value(object->getId(), allocator).Move(),
+                           allocator);
+    }
+  }
+
+  template <typename T>
+  static void
+  pushBackObjectAsMember(rapidjson::Value &jsonObject, const T &object,
+                         rapidjson::MemoryPoolAllocator<> &allocator) {
+    if (object) {
+      jsonObject.PushBack(rapidjson::Value(object->getId(), allocator).Move(),
+                          allocator);
+    }
+  }
+
+public:
+  Archive() = default;
+  explicit Archive(const Engine &engine);
+  Archive(Engine &engine, const std::string &filename);
+  void resume(Engine &engine) const;
+  void dump(const std::string &fileName) const;
+};
+
+} // namespace CityFlow
+
+#endif // CITYFLOW_ARCHIVE_H
diff --git a/src/engine/engine.cpp b/src/engine/engine.cpp
index d4d7626..be22038 100644
--- a/src/engine/engine.cpp
+++ b/src/engine/engine.cpp
@@ -3,876 +3,1085 @@
 
 #include <algorithm>
 #include <cmath>
-#include <limits>
 #include <iostream>
+#include <limits>
 #include <memory>
 
 #include <ctime>
 namespace CityFlow {
 
-    Engine::Engine(const std::string &configFile, int threadNum) : threadNum(threadNum), startBarrier(threadNum + 1),
-                                                                   endBarrier(threadNum + 1) {
-        for (int i = 0; i < threadNum; i++) {
-            threadVehiclePool.emplace_back();
-            threadRoadPool.emplace_back();
-            threadIntersectionPool.emplace_back();
-            threadDrivablePool.emplace_back();
-        }
-        bool success = loadConfig(configFile);
-        if (!success) {
-            std::cerr << "load config failed!" << std::endl;
-        }
+Engine::Engine(const std::string &configFile, int threadNum)
+    : threadNum(threadNum), startBarrier(threadNum + 1),
+      endBarrier(threadNum + 1) {
+  _finished_vehicle_cnt = 0;
+  _running_vehicle_cnt = 0;
+  _finished_cumulative_traveling_time = 0;
+  for (int i = 0; i < threadNum; i++) {
+    threadVehiclePool.emplace_back();
+    threadRoadPool.emplace_back();
+    threadIntersectionPool.emplace_back();
+    threadDrivablePool.emplace_back();
+  }
+  bool success = loadConfig(configFile);
+  if (!success) {
+    std::cerr << "load config failed!" << std::endl;
+  }
+
+  for (int i = 0; i < threadNum; i++) {
+    threadPool.emplace_back(
+        &Engine::threadController, this, std::ref(threadVehiclePool[i]),
+        std::ref(threadRoadPool[i]), std::ref(threadIntersectionPool[i]),
+        std::ref(threadDrivablePool[i]));
+  }
+}
 
-        for (int i = 0; i < threadNum; i++) {
-            threadPool.emplace_back(&Engine::threadController, this,
-                                    std::ref(threadVehiclePool[i]),
-                                    std::ref(threadRoadPool[i]),
-                                    std::ref(threadIntersectionPool[i]),
-                                    std::ref(threadDrivablePool[i]));
-        }
+bool Engine::loadConfig(const std::string &configFile) {
+  rapidjson::Document document;
+  if (!readJsonFromFile(configFile, document)) {
+    std::cerr << "cannot open config file!" << std::endl;
+    return false;
+  }
+
+  if (!document.IsObject()) {
+    std::cerr << "wrong format of config file" << std::endl;
+    return false;
+  }
+
+  try {
+    interval = getJsonMember<double>("interval", document);
+    warnings = false;
+    rlTrafficLight = getJsonMember<bool>("rlTrafficLight", document);
+    laneChange = getJsonMember<bool>("laneChange", document, false);
+    seed = getJsonMember<int>("seed", document);
+    rnd.seed(seed);
+    dir = getJsonMember<const char *>("dir", document);
+    std::string roadnetFile =
+        getJsonMember<const char *>("roadnetFile", document);
+    std::string flowFile = getJsonMember<const char *>("flowFile", document);
+
+    if (!loadRoadNet(dir + roadnetFile)) {
+      std::cerr << "loading roadnet file error!" << std::endl;
+      return false;
+    }
 
+    if (!loadFlow(dir + flowFile)) {
+      std::cerr << "loading flow file error!" << std::endl;
+      return false;
     }
 
+    if (warnings)
+      checkWarning();
+    saveReplayInConfig = saveReplay =
+        getJsonMember<bool>("saveReplay", document);
+
+    if (saveReplay) {
+      std::string roadnetLogFile =
+          getJsonMember<const char *>("roadnetLogFile", document);
+      std::string replayLogFile =
+          getJsonMember<const char *>("replayLogFile", document);
+      setLogFile(dir + roadnetLogFile, dir + replayLogFile);
+    }
+  } catch (const JsonFormatError &e) {
+    std::cerr << e.what() << std::endl;
+    return false;
+  }
+  stepLog = "";
+  return true;
+}
 
-    bool Engine::loadConfig(const std::string &configFile) {
-        rapidjson::Document document;
-        if (!readJsonFromFile(configFile, document)) {
-            std::cerr << "cannot open config file!" << std::endl;
-            return false;
-        }
+bool Engine::loadRoadNet(const std::string &jsonFile) {
+  bool ans = roadnet.loadFromJson(jsonFile);
+  int cnt = 0;
+  for (Road &road : roadnet.getRoads()) {
+    threadRoadPool[cnt].push_back(&road);
+    cnt = (cnt + 1) % threadNum;
+  }
+  for (Intersection &intersection : roadnet.getIntersections()) {
+    threadIntersectionPool[cnt].push_back(&intersection);
+    cnt = (cnt + 1) % threadNum;
+  }
+  for (Drivable *drivable : roadnet.getDrivables()) {
+    threadDrivablePool[cnt].push_back(drivable);
+    cnt = (cnt + 1) % threadNum;
+  }
+  jsonRoot.SetObject();
+  jsonRoot.AddMember("static", roadnet.convertToJson(jsonRoot.GetAllocator()),
+                     jsonRoot.GetAllocator());
+  return ans;
+}
 
-        if (!document.IsObject()) {
-            std::cerr << "wrong format of config file" << std::endl;
-            return false;
-        }
+bool Engine::loadFlow(const std::string &jsonFilename) {
+  rapidjson::Document root;
+  if (!readJsonFromFile(jsonFilename, root)) {
+    std::cerr << "cannot open flow file!" << std::endl;
+    return false;
+  }
+  std::list<std::string> path;
+  try {
+    if (!root.IsArray())
+      throw JsonTypeError("flow file", "array");
+    for (rapidjson::SizeType i = 0; i < root.Size(); i++) {
+      path.emplace_back("flow[" + std::to_string(i) + "]");
+      rapidjson::Value &flow = root[i];
+      std::vector<Road *> roads;
+      const auto &routes = getJsonMemberArray("route", flow);
+      roads.reserve(routes.Size());
+      for (auto &route : routes.GetArray()) {
+        path.emplace_back("route[" + std::to_string(roads.size()) + "]");
+        if (!route.IsString())
+          throw JsonTypeError("route", "string");
+        std::string roadName = route.GetString();
+        auto road = roadnet.getRoadById(roadName);
+        if (!road)
+          throw JsonFormatError("No such road: " + roadName);
+        roads.push_back(road);
+        path.pop_back();
+      }
+      auto route = std::make_shared<const Route>(roads);
+
+      VehicleInfo vehicleInfo;
+      const auto &vehicle = getJsonMemberObject("vehicle", flow);
+      vehicleInfo.len = getJsonMember<double>("length", vehicle);
+      vehicleInfo.width = getJsonMember<double>("width", vehicle);
+      vehicleInfo.maxPosAcc = getJsonMember<double>("maxPosAcc", vehicle);
+      vehicleInfo.maxNegAcc = getJsonMember<double>("maxNegAcc", vehicle);
+      vehicleInfo.usualPosAcc = getJsonMember<double>("usualPosAcc", vehicle);
+      vehicleInfo.usualNegAcc = getJsonMember<double>("usualNegAcc", vehicle);
+      vehicleInfo.minGap = getJsonMember<double>("minGap", vehicle);
+      vehicleInfo.maxSpeed = getJsonMember<double>("maxSpeed", vehicle);
+      vehicleInfo.headwayTime = getJsonMember<double>("headwayTime", vehicle);
+      vehicleInfo.route = route;
+      int startTime = getJsonMember<int>("startTime", flow);
+      int endTime = getJsonMember<int>("endTime", flow);
+      Flow newFlow(vehicleInfo, getJsonMember<double>("interval", flow), this,
+                   startTime, endTime, "flow_" + std::to_string(i));
+      flows.push_back(newFlow);
+      path.pop_back();
+    }
+    assert(path.empty());
+  } catch (const JsonFormatError &e) {
+    std::cerr << "Error occurred when reading flow file" << std::endl;
+    for (const auto &node : path) {
+      std::cerr << "/" << node;
+    }
+    std::cerr << " " << e.what() << std::endl;
+    return false;
+  }
+  return true;
+}
 
-        try {
-            interval = getJsonMember<double>("interval", document);
-            warnings = false;
-            rlTrafficLight = getJsonMember<bool>("rlTrafficLight", document);
-            laneChange = getJsonMember<bool>("laneChange", document, false);
-            seed = getJsonMember<int>("seed", document);
-            rnd.seed(seed);
-            dir = getJsonMember<const char*>("dir", document);
-            std::string roadnetFile = getJsonMember<const char*>("roadnetFile", document);
-            std::string flowFile = getJsonMember<const char*>("flowFile", document);
-
-            if (!loadRoadNet(dir + roadnetFile)) {
-                std::cerr << "loading roadnet file error!" << std::endl;
-                return false;
-            }
-
-            if (!loadFlow(dir + flowFile)) {
-                std::cerr << "loading flow file error!" << std::endl;
-                return false;
-            }
-
-            if (warnings) checkWarning();
-            saveReplayInConfig = saveReplay = getJsonMember<bool>("saveReplay", document);
-
-            if (saveReplay) {
-                std::string roadnetLogFile = getJsonMember<const char*>("roadnetLogFile", document);
-                std::string replayLogFile = getJsonMember<const char*>("replayLogFile", document);
-                setLogFile(dir + roadnetLogFile, dir + replayLogFile);
-            }
-        } catch (const JsonFormatError &e) {
-            std::cerr << e.what() << std::endl;
-            return false;
-        }
-        stepLog = "";
-        return true;
+bool Engine::checkWarning() {
+  bool result = true;
+
+  if (interval < 0.2 || interval > 1.5) {
+    std::cerr
+        << "Deprecated time interval, recommended interval between 0.2 and 1.5"
+        << std::endl;
+    result = false;
+  }
+
+  for (Lane *lane : roadnet.getLanes()) {
+    if (lane->getLength() < 50) {
+      std::cerr << "Deprecated road length, recommended road length at least "
+                   "50 meters"
+                << std::endl;
+      result = false;
+    }
+    if (lane->getMaxSpeed() > 30) {
+      std::cerr << "Deprecated road max speed, recommended max speed at most "
+                   "30 meters/s"
+                << std::endl;
+      result = false;
     }
+  }
 
-    bool Engine::loadRoadNet(const std::string &jsonFile) {
-        bool ans = roadnet.loadFromJson(jsonFile);
-        int cnt = 0;
-        for (Road &road : roadnet.getRoads()) {
-            threadRoadPool[cnt].push_back(&road);
-            cnt = (cnt + 1) % threadNum;
-        }
-        for (Intersection &intersection : roadnet.getIntersections()) {
-            threadIntersectionPool[cnt].push_back(&intersection);
-            cnt = (cnt + 1) % threadNum;
-        }
-        for (Drivable *drivable : roadnet.getDrivables()) {
-            threadDrivablePool[cnt].push_back(drivable);
-            cnt = (cnt + 1) % threadNum;
-        }
-        jsonRoot.SetObject();
-        jsonRoot.AddMember("static", roadnet.convertToJson(jsonRoot.GetAllocator()), jsonRoot.GetAllocator());
-        return ans;
+  return result;
+}
+
+void Engine::vehicleControl(Vehicle &vehicle,
+                            std::vector<std::pair<Vehicle *, double>> &buffer) {
+  double nextSpeed;
+  if (vehicle.hasSetSpeed())
+    nextSpeed = vehicle.getBufferSpeed();
+  else
+    nextSpeed = vehicle.getNextSpeed(interval).speed;
+
+  if (laneChange) {
+    Vehicle *partner = vehicle.getPartner();
+    if (partner != nullptr && !partner->hasSetSpeed()) {
+      double partnerSpeed = partner->getNextSpeed(interval).speed;
+      nextSpeed = min2double(nextSpeed, partnerSpeed);
+      partner->setSpeed(nextSpeed);
+
+      if (partner->hasSetEnd())
+        vehicle.setEnd(true);
+    }
+  }
+
+  if (vehicle.getPartner()) {
+    assert(vehicle.getDistance() == vehicle.getPartner()->getDistance());
+  }
+
+  double deltaDis, speed = vehicle.getSpeed();
+
+  if (nextSpeed < 0) {
+    deltaDis = 0.5 * speed * speed / vehicle.getMaxNegAcc();
+    nextSpeed = 0;
+  } else {
+    deltaDis = (speed + nextSpeed) * interval / 2;
+  }
+  vehicle.setSpeed(nextSpeed);
+  vehicle.setDeltaDistance(deltaDis);
+
+  if (laneChange) {
+    if (!vehicle.isReal() && vehicle.getChangedDrivable() != nullptr) {
+      vehicle.abortLaneChange();
     }
 
-    bool Engine::loadFlow(const std::string &jsonFilename) {
-        rapidjson::Document root;
-        if (!readJsonFromFile(jsonFilename, root)) {
-            std::cerr << "cannot open flow file!" << std::endl;
-            return false;
-        }
-        std::list<std::string> path;
-        try {
-            if (!root.IsArray())
-                throw JsonTypeError("flow file", "array");
-            for (rapidjson::SizeType i = 0; i < root.Size(); i++) {
-                path.emplace_back("flow[" + std::to_string(i) + "]");
-                rapidjson::Value &flow = root[i];
-                std::vector<Road *> roads;
-                const auto &routes = getJsonMemberArray("route", flow);
-                roads.reserve(routes.Size());
-                for (auto &route: routes.GetArray()) {
-                    path.emplace_back("route[" + std::to_string(roads.size()) + "]");
-                    if (!route.IsString())
-                        throw JsonTypeError("route", "string");
-                    std::string roadName = route.GetString();
-                    auto road = roadnet.getRoadById(roadName);
-                    if (!road)
-                        throw JsonFormatError("No such road: " + roadName);
-                    roads.push_back(road);
-                    path.pop_back();
-                }
-                auto route = std::make_shared<const Route>(roads);
-
-                VehicleInfo vehicleInfo;
-                const auto &vehicle = getJsonMemberObject("vehicle", flow);
-                vehicleInfo.len = getJsonMember<double>("length", vehicle);
-                vehicleInfo.width = getJsonMember<double>("width", vehicle);
-                vehicleInfo.maxPosAcc = getJsonMember<double>("maxPosAcc", vehicle);
-                vehicleInfo.maxNegAcc = getJsonMember<double>("maxNegAcc", vehicle);
-                vehicleInfo.usualPosAcc = getJsonMember<double>("usualPosAcc", vehicle);
-                vehicleInfo.usualNegAcc = getJsonMember<double>("usualNegAcc", vehicle);
-                vehicleInfo.minGap = getJsonMember<double>("minGap", vehicle);
-                vehicleInfo.maxSpeed = getJsonMember<double>("maxSpeed", vehicle);
-                vehicleInfo.headwayTime = getJsonMember<double>("headwayTime", vehicle);
-                vehicleInfo.route = route;
-                int startTime = getJsonMember<int>("startTime", flow, 0);
-                int endTime = getJsonMember<int>("endTime", flow, -1);
-                Flow newFlow(vehicleInfo, getJsonMember<double>("interval", flow), this, startTime, endTime,
-                             "flow_" + std::to_string(i));
-                flows.push_back(newFlow);
-                path.pop_back();
-            }
-            assert(path.empty());
-        } catch (const JsonFormatError &e) {
-            std::cerr << "Error occurred when reading flow file" << std::endl;
-            for (const auto &node : path) {
-                std::cerr << "/" << node;
-            }
-            std::cerr << " " << e.what() << std::endl;
-            return false;
-        }
-        return true;
+    if (vehicle.isChanging()) {
+      assert(vehicle.isReal());
+
+      int dir = vehicle.getLaneChangeDirection();
+      double newOffset = fabs(vehicle.getOffset() +
+                              max2double(0.2 * nextSpeed, 1) * interval * dir);
+      newOffset = min2double(newOffset, vehicle.getMaxOffset());
+      vehicle.setOffset(newOffset * dir);
+
+      if (newOffset >= vehicle.getMaxOffset()) {
+        std::lock_guard<std::mutex> guard(lock);
+        vehicleMap.erase(vehicle.getPartner()->getId());
+        vehicleMap[vehicle.getId()] = vehicle.getPartner();
+        vehicle.finishChanging();
+      }
     }
+  }
 
-    bool Engine::checkWarning() {
-        bool result = true;
+  if (!vehicle.hasSetEnd() && vehicle.hasSetDrivable()) {
+    buffer.emplace_back(&vehicle, vehicle.getBufferDis());
+  }
+}
 
-        if (interval < 0.2 || interval > 1.5) {
-            std::cerr << "Deprecated time interval, recommended interval between 0.2 and 1.5" << std::endl;
-            result = false;
-        }
+void Engine::threadController(std::set<Vehicle *> &vehicles,
+                              std::vector<Road *> &roads,
+                              std::vector<Intersection *> &intersections,
+                              std::vector<Drivable *> &drivables) {
+  while (!finished) {
+    threadPlanRoute(roads);
+    if (laneChange) {
+      threadInitSegments(roads);
+      threadPlanLaneChange(vehicles);
+      threadUpdateLeaderAndGap(drivables);
+    }
+    threadNotifyCross(intersections);
+    threadGetAction(vehicles);
+    threadUpdateLocation(drivables);
+    threadUpdateAction(vehicles);
+    threadUpdateLeaderAndGap(drivables);
+  }
+}
+
+void Engine::threadPlanRoute(const std::vector<Road *> &roads) {
+  startBarrier.wait();
+  for (auto &road : roads) {
+    for (auto &vehicle : road->getPlanRouteBuffer()) {
+      vehicle->updateRoute();
+    }
+  }
+  endBarrier.wait();
+}
 
-        for (Lane *lane : roadnet.getLanes()) {
-            if (lane->getLength() < 50) {
-                std::cerr << "Deprecated road length, recommended road length at least 50 meters" << std::endl;
-                result = false;
-            }
-            if (lane->getMaxSpeed() > 30) {
-                std::cerr << "Deprecated road max speed, recommended max speed at most 30 meters/s" << std::endl;
-                result = false;
-            }
+void Engine::threadUpdateLocation(const std::vector<Drivable *> &drivables) {
+  startBarrier.wait();
+  for (Drivable *drivable : drivables) {
+    auto &vehicles = drivable->getVehicles();
+    auto vehicleItr = vehicles.begin();
+    while (vehicleItr != vehicles.end()) {
+      Vehicle *vehicle = *vehicleItr;
+
+      if ((vehicle->getChangedDrivable()) != nullptr || vehicle->hasSetEnd()) {
+        vehicleItr = vehicles.erase(vehicleItr);
+      } else {
+        vehicleItr++;
+      }
+
+      if (vehicle->hasSetEnd()) {
+        std::lock_guard<std::mutex> guard(lock);
+        vehicleRemoveBuffer.insert(vehicle);
+        if (!vehicle->getLaneChange()->hasFinished()) {
+          vehicleMap.erase(vehicle->getId());
+          finishedVehicleCnt += 1;
+          cumulativeTravelTime += getCurrentTime() - vehicle->getEnterTime();
+          if (vehicle->isReal()) {
+            ++_finished_vehicle_cnt;
+            --_running_vehicle_cnt;
+            _finished_cumulative_traveling_time +=
+                getCurrentTime() - vehicle->getEnterTime();
+          }
         }
+        auto iter = vehiclePool.find(vehicle->getPriority());
+        threadVehiclePool[iter->second.second].erase(vehicle);
+        //                    assert(vehicle->getPartner() == nullptr);
+        delete vehicle;
+        vehiclePool.erase(iter);
+        activeVehicleCount--;
+      }
+    }
+  }
+  endBarrier.wait();
+}
 
-        return result;
+void Engine::threadNotifyCross(
+    const std::vector<Intersection *> &intersections) {
+  // TODO: iterator for laneLink
+  startBarrier.wait();
+  for (Intersection *intersection : intersections)
+    for (Cross &cross : intersection->getCrosses())
+      cross.clearNotify();
+
+  for (Intersection *intersection : intersections)
+    for (LaneLink *laneLink : intersection->getLaneLinks()) {
+      // XXX: no cross in laneLink?
+      const auto &crosses = laneLink->getCrosses();
+      auto rIter = crosses.rbegin();
+
+      // first check the vehicle on the end lane
+      Vehicle *vehicle = laneLink->getEndLane()->getLastVehicle();
+      if (vehicle &&
+          static_cast<LaneLink *>(vehicle->getPrevDrivable()) == laneLink) {
+        double vehDistance = vehicle->getDistance() - vehicle->getLen();
+        while (rIter != crosses.rend()) {
+          double crossDistance =
+              laneLink->getLength() - (*rIter)->getDistanceByLane(laneLink);
+          if (crossDistance + vehDistance < (*rIter)->getLeaveDistance()) {
+            (*rIter)->notify(laneLink, vehicle,
+                             -(vehicle->getDistance() + crossDistance));
+            ++rIter;
+          } else
+            break;
+        }
+      }
+
+      // check each vehicle on laneLink
+      for (Vehicle *linkVehicle : laneLink->getVehicles()) {
+        double vehDistance = linkVehicle->getDistance();
+
+        while (rIter != crosses.rend()) {
+          double crossDistance = (*rIter)->getDistanceByLane(laneLink);
+          if (vehDistance > crossDistance) {
+            if (vehDistance - crossDistance - linkVehicle->getLen() <=
+                (*rIter)->getLeaveDistance()) {
+              (*rIter)->notify(laneLink, linkVehicle,
+                               crossDistance - vehDistance);
+            } else
+              break;
+          } else {
+            (*rIter)->notify(laneLink, linkVehicle,
+                             crossDistance - vehDistance);
+          }
+          ++rIter;
+        }
+      }
+
+      // check vehicle on the incoming lane
+      vehicle = laneLink->getStartLane()->getFirstVehicle();
+      if (vehicle &&
+          static_cast<LaneLink *>(vehicle->getNextDrivable()) == laneLink &&
+          laneLink->isAvailable()) {
+        double vehDistance =
+            laneLink->getStartLane()->getLength() - vehicle->getDistance();
+        while (rIter != crosses.rend()) {
+          (*rIter)->notify(laneLink, vehicle,
+                           vehDistance + (*rIter)->getDistanceByLane(laneLink));
+          ++rIter;
+        }
+      }
     }
+  endBarrier.wait();
+}
 
-    void Engine::vehicleControl(Vehicle &vehicle, std::vector<std::pair<Vehicle *, double>> &buffer) {
-        double nextSpeed;
-        if (vehicle.hasSetSpeed())
-            nextSpeed = vehicle.getBufferSpeed();
-        else
-            nextSpeed = vehicle.getNextSpeed(interval).speed;
+void Engine::threadPlanLaneChange(
+    const std::set<CityFlow::Vehicle *> &vehicles) {
+  startBarrier.wait();
+  std::vector<CityFlow::Vehicle *> buffer;
+
+  for (auto vehicle : vehicles)
+    if (vehicle->isRunning() && vehicle->isReal()) {
+      vehicle->makeLaneChangeSignal(interval);
+      if (vehicle->planLaneChange()) {
+        buffer.emplace_back(vehicle);
+      }
+    }
+  {
+    std::lock_guard<std::mutex> guard(lock);
+    laneChangeNotifyBuffer.insert(laneChangeNotifyBuffer.end(), buffer.begin(),
+                                  buffer.end());
+  }
+  endBarrier.wait();
+}
 
-        if (laneChange) {
-            Vehicle * partner = vehicle.getPartner();
-            if (partner != nullptr && !partner->hasSetSpeed()){
-                double partnerSpeed = partner->getNextSpeed(interval).speed;
-                nextSpeed = min2double(nextSpeed, partnerSpeed);
-                partner->setSpeed(nextSpeed);
+void Engine::threadInitSegments(const std::vector<Road *> &roads) {
+  startBarrier.wait();
+  for (Road *road : roads)
+    for (Lane &lane : road->getLanes()) {
+      lane.initSegments();
+    }
+  endBarrier.wait();
+}
 
-                if (partner->hasSetEnd())
-                    vehicle.setEnd(true);
-            }
-        }
+void Engine::threadGetAction(std::set<Vehicle *> &vehicles) {
+  startBarrier.wait();
+  std::vector<std::pair<Vehicle *, double>> buffer;
+  for (auto vehicle : vehicles)
+    if (vehicle->isRunning())
+      vehicleControl(*vehicle, buffer);
+  {
+    std::lock_guard<std::mutex> guard(lock);
+    pushBuffer.insert(pushBuffer.end(), buffer.begin(), buffer.end());
+  }
+  endBarrier.wait();
+}
 
-        if (vehicle.getPartner()) {
-            assert(vehicle.getDistance() == vehicle.getPartner()->getDistance());
+void Engine::threadUpdateAction(std::set<Vehicle *> &vehicles) {
+  startBarrier.wait();
+  for (auto vehicle : vehicles)
+    if (vehicle->isRunning()) {
+      if (vehicleRemoveBuffer.count(vehicle->getBufferBlocker())) {
+        vehicle->setBlocker(nullptr);
+      }
 
-        }
+      vehicle->update();
+      vehicle->clearSignal();
+    }
+  endBarrier.wait();
+}
 
-        double deltaDis, speed = vehicle.getSpeed();
+void Engine::threadUpdateLeaderAndGap(
+    const std::vector<Drivable *> &drivables) {
+  startBarrier.wait();
+  for (Drivable *drivable : drivables) {
+    Vehicle *leader = nullptr;
+    for (Vehicle *vehicle : drivable->getVehicles()) {
+      vehicle->updateLeaderAndGap(leader);
+      leader = vehicle;
+    }
+    if (drivable->isLane()) {
+      static_cast<Lane *>(drivable)->updateHistory();
+    }
+  }
+  endBarrier.wait();
+}
 
-        if (nextSpeed < 0) {
-            deltaDis = 0.5 * speed * speed / vehicle.getMaxNegAcc();
-            nextSpeed = 0;
-        } else {
-            deltaDis = (speed + nextSpeed) * interval / 2;
-        }
-        vehicle.setSpeed(nextSpeed);
-        vehicle.setDeltaDistance(deltaDis);
-
-        if (laneChange) {
-            if (!vehicle.isReal() && vehicle.getChangedDrivable() != nullptr) {
-                vehicle.abortLaneChange();
-            }
-
-            if (vehicle.isChanging()) {
-                assert(vehicle.isReal());
-
-                int dir = vehicle.getLaneChangeDirection();
-                double newOffset = fabs(vehicle.getOffset() + max2double(0.2 * nextSpeed, 1) * interval * dir);
-                newOffset = min2double(newOffset, vehicle.getMaxOffset());
-                vehicle.setOffset(newOffset * dir);
-
-                if (newOffset >= vehicle.getMaxOffset()) {
-                    std::lock_guard<std::mutex> guard(lock);
-                    vehicleMap.erase(vehicle.getPartner()->getId());
-                    vehicleMap[vehicle.getId()] = vehicle.getPartner();
-                    vehicle.finishChanging();
-                }
-
-            }
-        }
+void Engine::planLaneChange() {
+  startBarrier.wait();
+  endBarrier.wait();
+  scheduleLaneChange();
+}
 
+void Engine::planRoute() {
+  startBarrier.wait();
+  endBarrier.wait();
+  for (auto &road : roadnet.getRoads()) {
+    for (auto &vehicle : road.getPlanRouteBuffer())
+      if (vehicle->isRouteValid()) {
+        vehicle->setFirstDrivable();
+        vehicle->getCurLane()->pushWaitingVehicle(vehicle);
+      } else {
+        Flow *flow = vehicle->getFlow();
+        if (flow)
+          flow->setValid(false);
+
+        // remove this vehicle
+        auto iter = vehiclePool.find(vehicle->getPriority());
+        threadVehiclePool[iter->second.second].erase(vehicle);
+        delete vehicle;
+        vehiclePool.erase(iter);
+      }
+    road.clearPlanRouteBuffer();
+  }
+}
 
-        if (!vehicle.hasSetEnd() && vehicle.hasSetDrivable()) {
-            buffer.emplace_back(&vehicle, vehicle.getBufferDis());
-        }
+void Engine::getAction() {
+  startBarrier.wait();
+  endBarrier.wait();
+}
 
+void Engine::updateLocation() {
+  startBarrier.wait();
+  endBarrier.wait();
+  std::sort(pushBuffer.begin(), pushBuffer.end(), vehicleCmp);
+  for (auto &vehiclePair : pushBuffer) {
+    Vehicle *vehicle = vehiclePair.first;
+    Drivable *drivable = vehicle->getChangedDrivable();
+    if (drivable != nullptr) {
+      drivable->pushVehicle(vehicle);
+      if (drivable->isLaneLink()) {
+        vehicle->setEnterLaneLinkTime(step);
+      } else {
+        vehicle->setEnterLaneLinkTime(std::numeric_limits<int>::max());
+      }
     }
+  }
+  pushBuffer.clear();
+}
 
-    void Engine::threadController(std::set<Vehicle *> &vehicles, 
-                                  std::vector<Road *> &roads,
-                                  std::vector<Intersection *> &intersections,
-                                  std::vector<Drivable *> &drivables) {
-        while (!finished) {
-            threadPlanRoute(roads);
-            if (laneChange) {
-                threadInitSegments(roads);
-                threadPlanLaneChange(vehicles);
-                threadUpdateLeaderAndGap(drivables);
-            }
-            threadNotifyCross(intersections);
-            threadGetAction(vehicles);
-            threadUpdateLocation(drivables);
-            threadUpdateAction(vehicles);
-            threadUpdateLeaderAndGap(drivables);
-        }
+void Engine::updateAction() {
+  startBarrier.wait();
+  endBarrier.wait();
+  vehicleRemoveBuffer.clear();
+}
+
+void Engine::handleWaiting() {
+  for (Lane *lane : roadnet.getLanes()) {
+    auto &buffer = lane->getWaitingBuffer();
+    if (buffer.empty())
+      continue;
+    auto &vehicle = buffer.front();
+    if (lane->available(vehicle)) {
+      vehicle->setRunning(true);
+      activeVehicleCount += 1;
+      Vehicle *tail = lane->getLastVehicle();
+      lane->pushVehicle(vehicle);
+      vehicle->updateLeaderAndGap(tail);
+      buffer.pop_front();
     }
+  }
+}
 
-    void Engine::threadPlanRoute(const std::vector<Road *> &roads) {
-        startBarrier.wait();
-        for (auto &road : roads) {
-            for (auto &vehicle : road->getPlanRouteBuffer()) {
-                vehicle->updateRoute();
-            }
-        }
-        endBarrier.wait();
-    }
-
-    void Engine::threadUpdateLocation(const std::vector<Drivable *> &drivables) {
-        startBarrier.wait();
-        for (Drivable *drivable : drivables) {
-            auto &vehicles   = drivable->getVehicles();
-            auto vehicleItr = vehicles.begin();
-            while (vehicleItr != vehicles.end()) {
-                Vehicle *vehicle = *vehicleItr;
-
-                if ((vehicle->getChangedDrivable()) != nullptr || vehicle->hasSetEnd()) {
-                    vehicleItr = vehicles.erase(vehicleItr);
-                }else{
-                    vehicleItr++;
-                }
-
-                if (vehicle->hasSetEnd()) {
-                    std::lock_guard<std::mutex> guard(lock);
-                    vehicleRemoveBuffer.insert(vehicle);
-                    if (!vehicle->getLaneChange()->hasFinished()) {
-                        vehicleMap.erase(vehicle->getId());
-                        finishedVehicleCnt += 1;
-                        cumulativeTravelTime += getCurrentTime() - vehicle->getEnterTime();
-                    }
-                    auto iter = vehiclePool.find(vehicle->getPriority());
-                    threadVehiclePool[iter->second.second].erase(vehicle);
-//                    assert(vehicle->getPartner() == nullptr);
-                    delete vehicle;
-                    vehiclePool.erase(iter);
-                    activeVehicleCount--;
-                }
-
-            }
-        }
-        endBarrier.wait();
-    }
-
-    void Engine::threadNotifyCross(const std::vector<Intersection *> &intersections) {
-        //TODO: iterator for laneLink
-        startBarrier.wait();
-        for (Intersection *intersection : intersections)
-            for (Cross &cross : intersection->getCrosses())
-                cross.clearNotify();
-
-        for (Intersection *intersection : intersections)
-            for (LaneLink *laneLink : intersection->getLaneLinks()) {
-                // XXX: no cross in laneLink?
-                const auto &crosses = laneLink->getCrosses();
-                auto rIter = crosses.rbegin();
-
-                // first check the vehicle on the end lane
-                Vehicle *vehicle = laneLink->getEndLane()->getLastVehicle();
-                if (vehicle && static_cast<LaneLink *>(vehicle->getPrevDrivable()) == laneLink) {
-                    double vehDistance = vehicle->getDistance() - vehicle->getLen();
-                    while (rIter != crosses.rend()) {
-                        double crossDistance = laneLink->getLength() - (*rIter)->getDistanceByLane(laneLink);
-                        if (crossDistance + vehDistance < (*rIter)->getLeaveDistance()) {
-                            (*rIter)->notify(laneLink, vehicle, -(vehicle->getDistance() + crossDistance));
-                            ++rIter;
-                        } else break;
-                    }
-                }
-
-                // check each vehicle on laneLink
-                for (Vehicle *linkVehicle : laneLink->getVehicles()) {
-                    double vehDistance = linkVehicle->getDistance();
-
-                    while (rIter != crosses.rend()) {
-                        double crossDistance = (*rIter)->getDistanceByLane(laneLink);
-                        if (vehDistance > crossDistance) {
-                            if (vehDistance - crossDistance - linkVehicle->getLen() <=
-                                (*rIter)->getLeaveDistance()) {
-                                (*rIter)->notify(laneLink, linkVehicle, crossDistance - vehDistance);
-                            } else break;
-                        } else {
-                            (*rIter)->notify(laneLink, linkVehicle, crossDistance - vehDistance);
-                        }
-                        ++rIter;
-                    }
-                }
-
-                // check vehicle on the incoming lane
-                vehicle = laneLink->getStartLane()->getFirstVehicle();
-                if (vehicle && static_cast<LaneLink *>(vehicle->getNextDrivable()) == laneLink && laneLink->isAvailable()) {
-                    double vehDistance = laneLink->getStartLane()->getLength() - vehicle->getDistance();
-                    while (rIter != crosses.rend()) {
-                        (*rIter)->notify(laneLink, vehicle, vehDistance + (*rIter)->getDistanceByLane(laneLink));
-                        ++rIter;
-                    }
-                }
-            }
-        endBarrier.wait();
-    }
-
-    void Engine::threadPlanLaneChange(const std::set<CityFlow::Vehicle *> &vehicles) {
-        startBarrier.wait();
-        std::vector<CityFlow::Vehicle *> buffer;
-
-        for (auto vehicle : vehicles)
-            if (vehicle->isRunning() && vehicle->isReal()) {
-                vehicle->makeLaneChangeSignal(interval);
-                if (vehicle->planLaneChange()){
-                    buffer.emplace_back(vehicle);
-                }
-            }
-        {
-            std::lock_guard<std::mutex> guard(lock);
-            laneChangeNotifyBuffer.insert(laneChangeNotifyBuffer.end(), buffer.begin(), buffer.end());
+void Engine::updateLog() {
+  std::string result;
+  for (const Vehicle *vehicle : getRunningVehicles()) {
+    Point pos = vehicle->getPoint();
+    Point dir = vehicle->getCurDrivable()->getDirectionByDistance(
+        vehicle->getDistance());
+
+    int lc = vehicle->lastLaneChangeDirection();
+    result.append(double2string(pos.x) + " " + double2string(pos.y) + " " +
+                  double2string(atan2(dir.y, dir.x)) + " " + vehicle->getId() +
+                  " " + std::to_string(lc) + " " +
+                  double2string(vehicle->getLen()) + " " +
+                  double2string(vehicle->getWidth()) + ",");
+  }
+  result.append(";");
+
+  for (const Road &road : roadnet.getRoads()) {
+    if (road.getEndIntersection().isVirtualIntersection())
+      continue;
+    result.append(road.getId());
+    for (const Lane &lane : road.getLanes()) {
+      if (lane.getEndIntersection()->isImplicitIntersection()) {
+        result.append(" i");
+        continue;
+      }
+
+      bool can_go = true;
+      for (LaneLink *laneLink : lane.getLaneLinks()) {
+        if (!laneLink->isAvailable()) {
+          can_go = false;
+          break;
         }
-        endBarrier.wait();
+      }
+      result.append(can_go ? " g" : " r");
     }
+    result.append(",");
+  }
+  logOut << result << std::endl;
+}
 
-    void Engine::threadInitSegments(const std::vector<Road *> &roads) {
-        startBarrier.wait();
-        for (Road *road : roads)
-            for (Lane &lane : road->getLanes()) {
-                lane.initSegments();
-            }
-        endBarrier.wait();
-    }
+void Engine::updateLeaderAndGap() {
+  startBarrier.wait();
+  endBarrier.wait();
+}
 
+void Engine::notifyCross() {
+  startBarrier.wait();
+  endBarrier.wait();
+}
 
-    void Engine::threadGetAction(std::set<Vehicle *> &vehicles) {
-        startBarrier.wait();
-        std::vector<std::pair<Vehicle *, double>> buffer;
-        for (auto vehicle: vehicles)
-            if (vehicle->isRunning()) 
-                vehicleControl(*vehicle, buffer);
-        {
-            std::lock_guard<std::mutex> guard(lock);
-            pushBuffer.insert(pushBuffer.end(), buffer.begin(), buffer.end());
-        }
-        endBarrier.wait();
-    }
-
-    void Engine::threadUpdateAction(std::set<Vehicle *> &vehicles) {
-        startBarrier.wait();
-        for (auto vehicle: vehicles)
-            if (vehicle->isRunning()) {
-                if (vehicleRemoveBuffer.count(vehicle->getBufferBlocker())){
-                    vehicle->setBlocker(nullptr);
-                }
-
-                vehicle->update();
-                vehicle->clearSignal();
-            }
-        endBarrier.wait();
-    }
-
-    void Engine::threadUpdateLeaderAndGap(const std::vector<Drivable *> &drivables) {
-        startBarrier.wait();
-        for (Drivable *drivable : drivables) {
-            Vehicle *leader = nullptr;
-            for (Vehicle *vehicle : drivable->getVehicles()) {
-                vehicle->updateLeaderAndGap(leader);
-                leader = vehicle;
-            }
-            if (drivable->isLane()){
-                static_cast<Lane *>(drivable)->updateHistory();
-            }
-        }
-        endBarrier.wait();
-    }
-
-    void Engine::planLaneChange() {
-        startBarrier.wait();
-        endBarrier.wait();
-        scheduleLaneChange();
-    }
-
-    void Engine::planRoute() {
-        startBarrier.wait();
-        endBarrier.wait();
-        for (auto &road : roadnet.getRoads()) {
-            for (auto &vehicle : road.getPlanRouteBuffer())
-                if (vehicle->isRouteValid()) {
-                    vehicle->setFirstDrivable();
-                    vehicle->getCurLane()->pushWaitingVehicle(vehicle);
-                }else {
-                    Flow *flow = vehicle->getFlow();
-                    if (flow) flow->setValid(false);
-
-                    //remove this vehicle
-                    auto iter = vehiclePool.find(vehicle->getPriority());
-                    threadVehiclePool[iter->second.second].erase(vehicle);
-                    delete vehicle;
-                    vehiclePool.erase(iter);
-                }
-            road.clearPlanRouteBuffer();
-        }
-    }
+void Engine::nextStep() {
+  for (auto &flow : flows)
+    flow.nextStep(interval);
+  planRoute();
+  handleWaiting();
+  if (laneChange) {
+    initSegments();
+    planLaneChange();
+    updateLeaderAndGap();
+  }
+  notifyCross();
+
+  getAction();
+  updateLocation();
+  updateAction();
+  updateLeaderAndGap();
+
+  if (!rlTrafficLight) {
+    std::vector<Intersection> &intersections = roadnet.getIntersections();
+    for (auto &intersection : intersections)
+      intersection.getTrafficLight().passTime(interval);
+  }
+
+  if (saveReplay) {
+    updateLog();
+  }
+
+  step += 1;
+}
 
-    void Engine::getAction() {
-        startBarrier.wait();
-        endBarrier.wait();
-    }
-
-    void Engine::updateLocation() {
-        startBarrier.wait();
-        endBarrier.wait();
-        std::sort(pushBuffer.begin(), pushBuffer.end(), vehicleCmp);
-        for (auto &vehiclePair : pushBuffer) {
-            Vehicle *vehicle = vehiclePair.first;
-            Drivable *drivable = vehicle->getChangedDrivable();
-            if (drivable != nullptr) {
-                drivable->pushVehicle(vehicle);
-                if (drivable->isLaneLink()) {
-                    vehicle->setEnterLaneLinkTime(step);
-                } else {
-                    vehicle->setEnterLaneLinkTime(std::numeric_limits<int>::max());
-                }
-            }
-        }
-        pushBuffer.clear();
-    }
-
-    void Engine::updateAction() {
-        startBarrier.wait();
-        endBarrier.wait();
-        vehicleRemoveBuffer.clear();
-    }
-
-    void Engine::handleWaiting() {
-        for (Lane *lane : roadnet.getLanes()) {
-            auto &buffer = lane->getWaitingBuffer();
-            if (buffer.empty()) continue;
-            auto &vehicle = buffer.front();
-            if (lane->available(vehicle)) {
-                vehicle->setRunning(true);
-                activeVehicleCount += 1;
-                Vehicle * tail = lane->getLastVehicle();
-                lane->pushVehicle(vehicle);
-                vehicle->updateLeaderAndGap(tail);
-                buffer.pop_front();
-            }
-        }
-    }
+void Engine::initSegments() {
+  startBarrier.wait();
+  endBarrier.wait();
+}
 
-    void Engine::updateLog() {
-        std::string result;
-        for (const Vehicle* vehicle: getRunningVehicles()) {
-            Point pos = vehicle->getPoint();
-            Point dir = vehicle->getCurDrivable()->getDirectionByDistance(vehicle->getDistance());
+bool Engine::checkPriority(int priority) {
+  return vehiclePool.find(priority) != vehiclePool.end();
+}
 
-            int lc = vehicle->lastLaneChangeDirection();
-            result.append(
-                    double2string(pos.x) + " " + double2string(pos.y) + " " + double2string(atan2(dir.y, dir.x)) + " "
-                            + vehicle->getId() + " " + std::to_string(lc) + " " + double2string(vehicle->getLen()) + " "
-                            + double2string(vehicle->getWidth()) + ",");
-        }
-        result.append(";");
-
-        for (const Road &road : roadnet.getRoads()) {
-            if (road.getEndIntersection().isVirtualIntersection())
-                continue;
-            result.append(road.getId());
-            for (const Lane &lane : road.getLanes()) {
-                if (lane.getEndIntersection()->isImplicitIntersection()){
-                    result.append(" i");
-                    continue;
-                }
-
-                bool can_go = true;
-                for (LaneLink *laneLink : lane.getLaneLinks()) {
-                    if (!laneLink->isAvailable()) {
-                        can_go = false;
-                        break;
-                    }
-                }
-                result.append(can_go ? " g" : " r");
-            }
-            result.append(",");
-        }
-        logOut << result << std::endl;
-    }
+void Engine::pushVehicle(Vehicle *const vehicle, bool pushToDrivable) {
+  size_t threadIndex = rnd() % threadNum;
+  vehiclePool.emplace(vehicle->getPriority(),
+                      std::make_pair(vehicle, threadIndex));
+  vehicleMap.emplace(vehicle->getId(), vehicle);
+  threadVehiclePool[threadIndex].insert(vehicle);
 
-    void Engine::updateLeaderAndGap() {
-        startBarrier.wait();
-        endBarrier.wait();
+  if (pushToDrivable)
+    ((Lane *)vehicle->getCurDrivable())->pushWaitingVehicle(vehicle);
+}
+
+size_t Engine::getVehicleCount() const { return activeVehicleCount; }
+
+std::vector<std::string> Engine::getVehicles(bool includeWaiting) const {
+  std::vector<std::string> ret;
+  ret.reserve(activeVehicleCount);
+  for (const Vehicle *vehicle : getRunningVehicles(includeWaiting)) {
+    ret.emplace_back(vehicle->getId());
+  }
+  return ret;
+}
+
+std::map<std::string, int> Engine::getLaneVehicleCount() const {
+  std::map<std::string, int> ret;
+  for (const Lane *lane : roadnet.getLanes()) {
+    ret.emplace(lane->getId(), lane->getVehicleCount());
+  }
+  return ret;
+}
+
+std::map<std::string, int> Engine::getLaneWaitingVehicleCount() const {
+  std::map<std::string, int> ret;
+  for (const Lane *lane : roadnet.getLanes()) {
+    int cnt = 0;
+    for (Vehicle *vehicle : lane->getVehicles()) {
+      if (vehicle->getSpeed() < 0.1) { // TODO: better waiting critera
+        cnt += 1;
+      }
     }
+    ret.emplace(lane->getId(), cnt);
+  }
+  return ret;
+}
 
-    void Engine::notifyCross() {
-        startBarrier.wait();
-        endBarrier.wait();
+std::map<std::string, std::vector<std::string>> Engine::getLaneVehicles() {
+  std::map<std::string, std::vector<std::string>> ret;
+  for (const Lane *lane : roadnet.getLanes()) {
+    std::vector<std::string> vehicles;
+    for (Vehicle *vehicle : lane->getVehicles()) {
+      vehicles.push_back(vehicle->getId());
     }
+    ret.emplace(lane->getId(), vehicles);
+  }
+  return ret;
+}
 
-    void Engine::nextStep() {
-        for (auto &flow : flows)
-            flow.nextStep(interval);
-        planRoute();
-        handleWaiting();
-        if (laneChange) {
-            initSegments();
-            planLaneChange();
-            updateLeaderAndGap();
-        }
-        notifyCross();
+std::map<std::string, double> Engine::getVehicleSpeed() const {
+  std::map<std::string, double> ret;
+  for (const Vehicle *vehicle : getRunningVehicles()) {
+    ret.emplace(vehicle->getId(), vehicle->getSpeed());
+  }
+  return ret;
+}
 
-        getAction();
-        updateLocation();
-        updateAction();
-        updateLeaderAndGap();
+std::map<std::string, double> Engine::getVehicleDistance() const {
+  std::map<std::string, double> ret;
+  for (const Vehicle *vehicle : getRunningVehicles()) {
+    ret.emplace(vehicle->getId(), vehicle->getDistance());
+  }
+  return ret;
+}
 
-        if (!rlTrafficLight) {
-            std::vector<Intersection> &intersections = roadnet.getIntersections();
-            for (auto &intersection : intersections)
-                intersection.getTrafficLight().passTime(interval);
-        }
+double Engine::getCurrentTime() const { return step * interval; }
+
+double Engine::getAverageTravelTime() const {
+  double tt = cumulativeTravelTime;
+  int n = finishedVehicleCnt;
+  for (auto &vehicle_pair : vehiclePool) {
+    auto &vehicle = vehicle_pair.second.first;
+    tt += getCurrentTime() - vehicle->getEnterTime();
+    n++;
+  }
+  return n == 0 ? 0 : tt / n;
+}
 
-        if (saveReplay) {
-            updateLog();
-        }
+void Engine::pushVehicle(const std::map<std::string, double> &info,
+                         const std::vector<std::string> &roads) {
+  VehicleInfo vehicleInfo;
+  std::map<std::string, double>::const_iterator it;
+  if ((it = info.find("speed")) != info.end())
+    vehicleInfo.speed = it->second;
+  if ((it = info.find("length")) != info.end())
+    vehicleInfo.len = it->second;
+  if ((it = info.find("width")) != info.end())
+    vehicleInfo.width = it->second;
+  if ((it = info.find("maxPosAcc")) != info.end())
+    vehicleInfo.maxPosAcc = it->second;
+  if ((it = info.find("maxNegAcc")) != info.end())
+    vehicleInfo.maxNegAcc = it->second;
+  if ((it = info.find("usualPosAcc")) != info.end())
+    vehicleInfo.usualPosAcc = it->second;
+  if ((it = info.find("usualNegAcc")) != info.end())
+    vehicleInfo.usualNegAcc = it->second;
+  if ((it = info.find("minGap")) != info.end())
+    vehicleInfo.minGap = it->second;
+  if ((it = info.find("maxSpeed")) != info.end())
+    vehicleInfo.maxSpeed = it->second;
+  if ((it = info.find("headwayTime")) != info.end())
+    vehicleInfo.headwayTime = it->second;
+
+  std::vector<Road *> routes;
+  routes.reserve(roads.size());
+  for (auto &road : roads)
+    routes.emplace_back(roadnet.getRoadById(road));
+  auto route = std::make_shared<const Route>(routes);
+  vehicleInfo.route = route;
+
+  Vehicle *vehicle =
+      new Vehicle(vehicleInfo,
+                  "manually_pushed_" + std::to_string(manuallyPushCnt++), this);
+  pushVehicle(vehicle, false);
+  vehicle->getFirstRoad()->addPlanRouteVehicle(vehicle);
+}
 
-        step += 1;
-    }
+void Engine::setTrafficLightPhase(const std::string &id, int phaseIndex) {
+  if (!rlTrafficLight) {
+    std::cerr
+        << "please set rlTrafficLight to true to enable traffic light control"
+        << std::endl;
+    return;
+  }
+  roadnet.getIntersectionById(id)->getTrafficLight().setPhase(phaseIndex);
+}
 
-    void Engine::initSegments() {
-        startBarrier.wait();
-        endBarrier.wait();
-    }
+void Engine::setReplayLogFile(const std::string &logFile) {
+  if (!saveReplayInConfig) {
+    std::cerr << "saveReplay is not set to true in config file!" << std::endl;
+    return;
+  }
+  if (logOut.is_open())
+    logOut.close();
+  logOut.open(dir + logFile);
+}
 
-    bool Engine::checkPriority(int priority) {
-        return vehiclePool.find(priority) != vehiclePool.end();
-    }
+void Engine::setSaveReplay(bool open) {
+  if (!saveReplayInConfig) {
+    std::cerr << "saveReplay is not set to true in config file!" << std::endl;
+    return;
+  }
+  saveReplay = open;
+}
 
-    void Engine::pushVehicle(Vehicle *const vehicle, bool pushToDrivable) {
-        size_t threadIndex = rnd() % threadNum;
-        vehiclePool.emplace(vehicle->getPriority(), std::make_pair(vehicle, threadIndex));
-        vehicleMap.emplace(vehicle->getId(), vehicle);
-        threadVehiclePool[threadIndex].insert(vehicle);
+void Engine::reset(bool resetRnd) {
+  for (auto &vehiclePair : vehiclePool)
+    delete vehiclePair.second.first;
+  for (auto &pool : threadVehiclePool)
+    pool.clear();
+  vehiclePool.clear();
+  vehicleMap.clear();
+  roadnet.reset();
+
+  finishedVehicleCnt = 0;
+  cumulativeTravelTime = 0;
+
+  for (auto &flow : flows)
+    flow.reset();
+  step = 0;
+  activeVehicleCount = 0;
+  _finished_vehicle_cnt = 0;
+  _running_vehicle_cnt = 0;
+  _finished_cumulative_traveling_time = 0;
+  if (resetRnd) {
+    rnd.seed(seed);
+  }
+}
 
-        if (pushToDrivable)
-            ((Lane *) vehicle->getCurDrivable())->pushWaitingVehicle(vehicle);
-    }
+Engine::~Engine() {
+  logOut.close();
+  finished = true;
+  for (int i = 0; i < (laneChange ? 9 : 6); ++i) {
+    startBarrier.wait();
+    endBarrier.wait();
+  }
+  for (auto &thread : threadPool)
+    thread.join();
+  for (auto &vehiclePair : vehiclePool)
+    delete vehiclePair.second.first;
+}
 
-    size_t Engine::getVehicleCount() const {
-        return activeVehicleCount;
-    }
+void Engine::setLogFile(const std::string &jsonFile,
+                        const std::string &logFile) {
+  if (!writeJsonToFile(jsonFile, jsonRoot)) {
+    std::cerr << "write roadnet log file error" << std::endl;
+  }
+  logOut.open(logFile);
+}
 
-    std::vector<std::string> Engine::getVehicles(bool includeWaiting) const {
-        std::vector<std::string> ret;
-        ret.reserve(activeVehicleCount);
-        for (const Vehicle* vehicle : getRunningVehicles(includeWaiting)) {
-            ret.emplace_back(vehicle->getId());
-        }
-        return ret;
+std::vector<const Vehicle *>
+Engine::getRunningVehicles(bool includeWaiting) const {
+  std::vector<const Vehicle *> ret;
+  ret.reserve(activeVehicleCount);
+  for (const auto &vehiclePair : vehiclePool) {
+    const Vehicle *vehicle = vehiclePair.second.first;
+    if (vehicle->isReal() && (includeWaiting || vehicle->isRunning())) {
+      ret.emplace_back(vehicle);
     }
+  }
+  return ret;
+}
 
-    std::map<std::string, int> Engine::getLaneVehicleCount() const {
-        std::map<std::string, int> ret;
-        for (const Lane *lane : roadnet.getLanes()) {
-            ret.emplace(lane->getId(), lane->getVehicleCount());
-        }
-        return ret;
-    }
-
-    std::map<std::string, int> Engine::getLaneWaitingVehicleCount() const {
-        std::map<std::string, int> ret;
-        for (const Lane *lane : roadnet.getLanes()) {
-            int cnt = 0;
-            for (Vehicle *vehicle : lane->getVehicles()) {
-                if (vehicle->getSpeed() < 0.1) { //TODO: better waiting critera
-                    cnt += 1;
-                }
-            }
-            ret.emplace(lane->getId(), cnt);
-        }
-        return ret;
+void Engine::scheduleLaneChange() {
+  std::sort(laneChangeNotifyBuffer.begin(), laneChangeNotifyBuffer.end(),
+            [](Vehicle *a, Vehicle *b) {
+              return a->laneChangeUrgency() > b->laneChangeUrgency();
+            });
+  for (auto v : laneChangeNotifyBuffer) {
+    v->updateLaneChangeNeighbor();
+    v->sendSignal();
+    // Lane Change
+    // Insert a shadow vehicle
+    if (v->planLaneChange() && v->canChange() && !v->isChanging()) {
+      std::shared_ptr<LaneChange> lc = v->getLaneChange();
+      if (lc->isGapValid() && v->getCurDrivable()->isLane()) {
+        //                    std::cerr << getCurrentTime() <<" " << v->getId()
+        //                    << " dis: "<< v->getDistance() <<" Can Change from
+        //                    "
+        //                              <<
+        //                              ((Lane*)v->getCurDrivable())->getId()<<
+        //                              " to " << lc->getTarget()->getId() <<
+        //                              std::endl;
+        insertShadow(v);
+      }
     }
+  }
+  laneChangeNotifyBuffer.clear();
+}
 
-    std::map<std::string, std::vector<std::string>> Engine::getLaneVehicles() {
-        std::map<std::string, std::vector<std::string>> ret;
-        for (const Lane *lane : roadnet.getLanes()) {
-            std::vector<std::string> vehicles;
-            for (Vehicle *vehicle : lane->getVehicles()) {
-                vehicles.push_back(vehicle->getId());
-            }
-            ret.emplace(lane->getId(), vehicles);
-        }
-        return ret;
-    }
+void Engine::insertShadow(Vehicle *vehicle) {
+  size_t threadIndex = vehiclePool.at(vehicle->getPriority()).second;
+  Vehicle *shadow = new Vehicle(*vehicle, vehicle->getId() + "_shadow", this);
+  vehicleMap.emplace(shadow->getId(), shadow);
+  vehiclePool.emplace(shadow->getPriority(),
+                      std::make_pair(shadow, threadIndex));
+  threadVehiclePool[threadIndex].insert(shadow);
+  vehicle->insertShadow(shadow);
+  activeVehicleCount++;
+}
 
-    std::map<std::string, double> Engine::getVehicleSpeed() const {
-        std::map<std::string, double> ret;
-        for (const Vehicle* vehicle : getRunningVehicles()) {
-            ret.emplace(vehicle->getId(), vehicle->getSpeed());
-        }
-        return ret;
-    }
+void Engine::loadFromFile(const char *fileName) {
+  Archive archive(*this, fileName);
+  archive.resume(*this);
+}
 
-    std::map<std::string, double> Engine::getVehicleDistance() const {
-        std::map<std::string, double> ret;
-        for (const Vehicle* vehicle : getRunningVehicles()) {
-            ret.emplace(vehicle->getId(), vehicle->getDistance());
-        }
-        return ret;
-    }
+void Engine::setVehicleSpeed(const std::string &id, double speed) {
+  auto iter = vehicleMap.find(id);
+  if (iter == vehicleMap.end()) {
+    throw std::runtime_error("Vehicle '" + id + "' not found");
+  } else {
+    iter->second->setCustomSpeed(speed);
+  }
+}
 
-    double Engine::getCurrentTime() const {
-        return step * interval;
+std::string Engine::getLeader(const std::string &vehicleId) const {
+  auto iter = vehicleMap.find(vehicleId);
+  if (iter == vehicleMap.end()) {
+    throw std::runtime_error("Vehicle '" + vehicleId + "' not found");
+  } else {
+    Vehicle *vehicle = iter->second;
+    if (laneChange) {
+      if (!vehicle->isReal())
+        vehicle = vehicle->getPartner();
     }
+    Vehicle *leader = vehicle->getLeader();
+    if (leader)
+      return leader->getId();
+    else
+      return "";
+  }
+}
 
-    double Engine::getAverageTravelTime() const {
-        double tt = cumulativeTravelTime;
-        int n = finishedVehicleCnt;
-        for (auto &vehicle_pair : vehiclePool) {
-            auto &vehicle = vehicle_pair.second.first;
-            tt += getCurrentTime() - vehicle->getEnterTime();
-            n++;
-        }
-        return n == 0 ? 0 : tt / n;
-    }
-
-    void Engine::pushVehicle(const std::map<std::string, double> &info, const std::vector<std::string> &roads) {
-        VehicleInfo vehicleInfo;
-        std::map<std::string, double>::const_iterator it;
-        if ((it = info.find("speed")) != info.end()) vehicleInfo.speed = it->second;
-        if ((it = info.find("length")) != info.end()) vehicleInfo.len = it->second;
-        if ((it = info.find("width")) != info.end()) vehicleInfo.width = it->second;
-        if ((it = info.find("maxPosAcc")) != info.end()) vehicleInfo.maxPosAcc = it->second;
-        if ((it = info.find("maxNegAcc")) != info.end()) vehicleInfo.maxNegAcc = it->second;
-        if ((it = info.find("usualPosAcc")) != info.end()) vehicleInfo.usualPosAcc = it->second;
-        if ((it = info.find("usualNegAcc")) != info.end()) vehicleInfo.usualNegAcc = it->second;
-        if ((it = info.find("minGap")) != info.end()) vehicleInfo.minGap = it->second;
-        if ((it = info.find("maxSpeed")) != info.end()) vehicleInfo.maxSpeed = it->second;
-        if ((it = info.find("headwayTime")) != info.end()) vehicleInfo.headwayTime = it->second;
-
-        std::vector<Road *> routes;
-        routes.reserve(roads.size());
-        for (auto &road: roads) routes.emplace_back(roadnet.getRoadById(road));
-        auto route = std::make_shared<const Route>(routes);
-        vehicleInfo.route = route;
-        
-        Vehicle *vehicle = new Vehicle(vehicleInfo,
-            "manually_pushed_" + std::to_string(manuallyPushCnt++), this);
-        pushVehicle(vehicle, false);
-        vehicle->getFirstRoad()->addPlanRouteVehicle(vehicle);
-    }
-
-    void Engine::setTrafficLightPhase(const std::string &id, int phaseIndex) {
-        if (!rlTrafficLight) {
-            std::cerr << "please set rlTrafficLight to true to enable traffic light control" << std::endl;
-            return;
-        }
-        roadnet.getIntersectionById(id)->getTrafficLight().setPhase(phaseIndex);
-    }
+bool Engine::setRoute(const std::string &vehicle_id,
+                      const std::vector<std::string> &anchor_id) {
+  auto vehicle_itr = vehicleMap.find(vehicle_id);
+  if (vehicle_itr == vehicleMap.end())
+    return false;
+  Vehicle *vehicle = vehicle_itr->second;
+
+  std::vector<Road *> anchors;
+  for (const auto &id : anchor_id) {
+    auto anchor = roadnet.getRoadById(id);
+    if (!anchor)
+      return false;
+    anchors.emplace_back(anchor);
+  }
+
+  return vehicle->setRoute(anchors);
+}
 
-    void Engine::setReplayLogFile(const std::string &logFile) {
-        if (!saveReplayInConfig) {
-            std::cerr << "saveReplay is not set to true in config file!" << std::endl;
-            return;
-        }
-        if (logOut.is_open()) logOut.close();
-        logOut.open(dir + logFile);
-    }
+std::map<std::string, std::string>
+Engine::getVehicleInfo(const std::string &id) const {
+  auto iter = vehicleMap.find(id);
+  if (iter == vehicleMap.end()) {
+    throw std::runtime_error("Vehicle '" + id + "' not found");
+  } else {
+    Vehicle *vehicle = iter->second;
+    return vehicle->getInfo();
+  }
+}
 
-    void Engine::setSaveReplay(bool open) {
-        if (!saveReplayInConfig) {
-            std::cerr << "saveReplay is not set to true in config file!" << std::endl;
-            return;
-        }
-        saveReplay = open;
-    }
-    
-    void Engine::reset(bool resetRnd) {
-        for (auto &vehiclePair : vehiclePool) delete vehiclePair.second.first;
-        for (auto &pool : threadVehiclePool) pool.clear();
-        vehiclePool.clear();
-        vehicleMap.clear();
-        roadnet.reset();
-
-        finishedVehicleCnt = 0;
-        cumulativeTravelTime = 0;
-
-        for (auto &flow : flows) flow.reset();
-        step = 0;
-        activeVehicleCount = 0;
-        if (resetRnd) {
-            rnd.seed(seed);
-        }
+int Engine::get_running_vehicle_count() const {
+  int cnt = 0;
+  for (auto &p : vehicleMap) {
+    auto *v = p.second;
+    if (v->isReal()) {
+      ++cnt;
     }
+  }
+  assert(cnt == _running_vehicle_cnt);
+  return _running_vehicle_cnt;
+}
 
-    Engine::~Engine() {
-        logOut.close();
-        finished = true;
-        for (int i = 0; i < (laneChange ? 9 : 6); ++i) {
-            startBarrier.wait();
-            endBarrier.wait();
-        }
-        for (auto &thread : threadPool) thread.join();
-        for (auto &vehiclePair : vehiclePool) delete vehiclePair.second.first;
-    }
-    
-    void Engine::setLogFile(const std::string &jsonFile, const std::string &logFile) {
-        if (!writeJsonToFile(jsonFile, jsonRoot)) {
-            std::cerr << "write roadnet log file error" << std::endl;
-        }
-        logOut.open(logFile);
-    }
+int Engine::get_finished_vehicle_count() const { return _finished_vehicle_cnt; }
 
-    std::vector<const Vehicle *> Engine::getRunningVehicles(bool includeWaiting) const {
-        std::vector<const Vehicle *> ret;
-        ret.reserve(activeVehicleCount);
-        for (const auto &vehiclePair: vehiclePool) {
-            const Vehicle *vehicle = vehiclePair.second.first;
-            if (vehicle->isReal() && (includeWaiting || vehicle->isRunning())) {
-                ret.emplace_back(vehicle);
-            }
-        }
-        return ret;
-    }
-
-    void Engine::scheduleLaneChange() {
-        std::sort(laneChangeNotifyBuffer.begin(), laneChangeNotifyBuffer.end(),
-                [](Vehicle *a, Vehicle *b){return a->laneChangeUrgency() > b->laneChangeUrgency();});
-        for (auto v : laneChangeNotifyBuffer){
-            v->updateLaneChangeNeighbor();
-            v->sendSignal();
-            // Lane Change
-            // Insert a shadow vehicle
-            if (v->planLaneChange() && v->canChange() && !v->isChanging()) {
-                std::shared_ptr<LaneChange> lc = v->getLaneChange();
-                if (lc->isGapValid() && v->getCurDrivable()->isLane()) {
-//                    std::cerr << getCurrentTime() <<" " << v->getId() << " dis: "<< v->getDistance() <<" Can Change from "
-//                              << ((Lane*)v->getCurDrivable())->getId()<< " to " << lc->getTarget()->getId() << std::endl;
-                insertShadow(v);
-                }
-            }
-        }
-        laneChangeNotifyBuffer.clear();
+double Engine::get_departed_vehicle_average_traveling_time() const {
+  double t = _finished_cumulative_traveling_time;
+  int n = _finished_vehicle_cnt;
+  for (auto &p : vehicleMap) {
+    auto *v = p.second;
+    if (v->isReal()) {
+      t += getCurrentTime() - v->getEnterTime();
+      n++;
     }
+  }
+  return n == 0 ? NAN : t / n;
+}
 
-    void Engine::insertShadow(Vehicle *vehicle) {
-        size_t threadIndex = vehiclePool.at(vehicle->getPriority()).second;
-        Vehicle *shadow = new Vehicle(*vehicle, vehicle->getId() + "_shadow", this);
-        vehicleMap.emplace(shadow->getId(), shadow);
-        vehiclePool.emplace(shadow->getPriority(), std::make_pair(shadow, threadIndex));
-        threadVehiclePool[threadIndex].insert(shadow);
-        vehicle->insertShadow(shadow);
-        activeVehicleCount++;
-    }
+double Engine::get_finished_vehicle_average_traveling_time() const {
+  double t = _finished_cumulative_traveling_time;
+  int n = _finished_vehicle_cnt;
+  return n == 0 ? NAN : t / n;
+}
 
-    void Engine::loadFromFile(const char *fileName) {
-        Archive archive(*this, fileName);
-        archive.resume(*this);
-    }
+std::vector<double> Engine::get_lane_lengths() const {
+  std::vector<double> out;
+  out.reserve(roadnet.lanes.size());
+  for (auto *l : roadnet.lanes) {
+    out.push_back(l->getLength());
+  }
+  return out;
+}
 
-    void Engine::setVehicleSpeed(const std::string &id, double speed) {
-        auto iter = vehicleMap.find(id);
-        if (iter == vehicleMap.end()) {
-            throw std::runtime_error("Vehicle '" + id + "' not found");
-        }else {
-            iter->second->setCustomSpeed(speed);
-        }
-    }
+std::vector<int> Engine::get_lane_vehicle_counts() const {
+  std::vector<int> out;
+  out.reserve(roadnet.lanes.size());
+  for (auto *l : roadnet.lanes) {
+    out.push_back(l->getVehicleCount());
+  }
+  return out;
+}
 
-    std::string Engine::getLeader(const std::string &vehicleId) const {
-        auto iter = vehicleMap.find(vehicleId);
-        if (iter == vehicleMap.end()) {
-            throw std::runtime_error("Vehicle '" + vehicleId + "' not found");
-        }else {
-            Vehicle *vehicle = iter->second;
-            if (laneChange) {
-                if (!vehicle->isReal())
-                    vehicle = vehicle->getPartner();
-            }
-            Vehicle *leader = vehicle->getLeader();
-            if (leader) return leader->getId();
-            else return "";
-        }
+std::vector<int>
+Engine::get_lane_waiting_vehicle_counts(float speed_threshold) const {
+  std::vector<int> out;
+  out.reserve(roadnet.lanes.size());
+  for (auto *l : roadnet.lanes) {
+    int cnt = 0;
+    for (auto *v : l->getVehicles()) {
+      if (v->getSpeed() < speed_threshold) {
+        ++cnt;
+      }
     }
+    out.push_back(cnt);
+  }
+  return out;
+}
 
-    bool Engine::setRoute(const std::string &vehicle_id, const std::vector<std::string> &anchor_id) {
-        auto vehicle_itr = vehicleMap.find(vehicle_id);
-        if (vehicle_itr == vehicleMap.end()) return false;
-        Vehicle *vehicle = vehicle_itr->second;
-
-        std::vector<Road *> anchors;
-        for (const auto &id : anchor_id) {
-            auto anchor = roadnet.getRoadById(id);
-            if (!anchor)
-                return false;
-            anchors.emplace_back(anchor);
-        }
+std::vector<int>
+Engine::get_lane_waiting_at_end_vehicle_counts(float speed_threshold,
+                                               float distance_to_end) const {
+  std::vector<int> out;
+  out.reserve(roadnet.lanes.size());
+  for (auto *l : roadnet.lanes) {
+    int cnt = 0;
+    for (auto *v : l->getVehicles()) {
+      auto d = l->getLength() - distance_to_end;
+      if (v->getSpeed() < speed_threshold && v->getDistance() >= d) {
+        ++cnt;
+      }
+    }
+    out.push_back(cnt);
+  }
+  return out;
+}
 
-        return vehicle->setRoute(anchors);
+std::vector<std::pair<int, double>> Engine::get_vehicle_road_speed() const {
+  std::vector<std::pair<int, double>> out;
+  for (const Vehicle *vehicle : getRunningVehicles()) {
+    auto *lane = vehicle->getCurLane();
+    if (!lane) {
+      continue;
     }
+    out.push_back({stoi(lane->getBelongRoad()->getId()), vehicle->getSpeed()});
+  }
+  return out;
+}
 
-    std::map<std::string, std::string> Engine::getVehicleInfo(const std::string &id) const {
-        auto iter = vehicleMap.find(id);
-        if (iter == vehicleMap.end()) {
-            throw std::runtime_error("Vehicle '" + id + "' not found");
-        }else {
-            Vehicle *vehicle = iter->second;
-            return vehicle->getInfo();
-        }
+std::vector<std::tuple<int, double, std::string>>
+Engine::get_vehicle_road_speed_id() const {
+  std::vector<std::tuple<int, double, std::string>> out;
+  for (const Vehicle *vehicle : getRunningVehicles()) {
+    auto *lane = vehicle->getCurLane();
+    if (!lane) {
+      continue;
     }
+    out.push_back({stoi(lane->getBelongRoad()->getId()), vehicle->getSpeed(),
+                   vehicle->getId()});
+  }
+  return out;
+}
 
+std::vector<std::pair<std::vector<int>, std::vector<int>>>
+Engine::get_junction_inout_lanes() const {
+  std::vector<std::pair<std::vector<int>, std::vector<int>>> out;
+  for (auto &i : roadnet.intersections) {
+    out.push_back(i.get_inout_lanes());
+  }
+  return out;
 }
+
+std::vector<std::vector<std::pair<std::vector<int>, std::vector<int>>>>
+Engine::get_junction_phase_lanes() const {
+  std::vector<std::vector<std::pair<std::vector<int>, std::vector<int>>>> out;
+  for (auto &i : roadnet.intersections) {
+    out.push_back(i.get_phase_lanes());
+  }
+  return out;
+}
+
+void Engine::set_tl_phase(int junction_id, int phase_id) {
+  if (!rlTrafficLight) {
+    std::cerr
+        << "please set rlTrafficLight to true to enable traffic light control"
+        << std::endl;
+    return;
+  }
+  roadnet.intersections.at(junction_id).getTrafficLight().setPhase(phase_id);
+}
+
+} // namespace CityFlow
diff --git a/src/engine/engine.h b/src/engine/engine.h
index afe10d7..e6709e3 100644
--- a/src/engine/engine.h
+++ b/src/engine/engine.h
@@ -1,187 +1,254 @@
 #ifndef CITYFLOW_ENGINE_H
 #define CITYFLOW_ENGINE_H
 
+#include "engine/archive.h"
 #include "flow/flow.h"
 #include "roadnet/roadnet.h"
-#include "engine/archive.h"
 #include "utility/barrier.h"
 
+#include <atomic>
+#include <fstream>
 #include <mutex>
-#include <thread>
-#include <set>
 #include <random>
-#include <fstream>
-
+#include <set>
+#include <thread>
 
 namespace CityFlow {
 
-    class Engine {
-        friend class Archive;
-    private:
-        static bool vehicleCmp(const std::pair<Vehicle *, double> &a, const std::pair<Vehicle *, double> &b) {
-            return a.second > b.second;
-        }
+class Engine {
+  friend class Archive;
+
+private:
+  static bool vehicleCmp(const std::pair<Vehicle *, double> &a,
+                         const std::pair<Vehicle *, double> &b) {
+    return a.second > b.second;
+  }
+
+  std::map<int, std::pair<Vehicle *, int>> vehiclePool;
+  std::map<std::string, Vehicle *> vehicleMap;
+  std::vector<std::set<Vehicle *>> threadVehiclePool;
+  std::vector<std::vector<Road *>> threadRoadPool;
+  std::vector<std::vector<Intersection *>> threadIntersectionPool;
+  std::vector<std::vector<Drivable *>> threadDrivablePool;
+  std::vector<Flow> flows;
+  RoadNet roadnet;
+  int threadNum;
+  double interval;
+  bool saveReplay;
+  bool saveReplayInConfig; // saveReplay option in config json
+  bool warnings;
+  std::vector<std::pair<Vehicle *, double>> pushBuffer;
+  std::vector<Vehicle *> laneChangeNotifyBuffer;
+  std::set<Vehicle *> vehicleRemoveBuffer;
+  rapidjson::Document jsonRoot;
+  std::string stepLog;
+
+  size_t step = 0;
+  size_t activeVehicleCount = 0;
+  int seed;
+  std::mutex lock;
+  Barrier startBarrier, endBarrier;
+  std::vector<std::thread> threadPool;
+  bool finished = false;
+  std::string dir;
+  std::ofstream logOut;
+
+  bool rlTrafficLight;
+  bool laneChange;
+  int manuallyPushCnt = 0;
+
+  int finishedVehicleCnt = 0;
+  double cumulativeTravelTime = 0;
+
+public:
+  // finished
+  int _finished_vehicle_cnt;
+  double _finished_cumulative_traveling_time;
+  // runningflowatomic
+  std::atomic_int _running_vehicle_cnt;
+
+private:
+  void vehicleControl(Vehicle &vehicle,
+                      std::vector<std::pair<Vehicle *, double>> &buffer);
+
+  void planRoute();
+
+  void getAction();
+
+  void updateAction();
+
+  void updateLocation();
+
+  void updateLeaderAndGap();
+
+  void planLaneChange();
+
+  void threadController(std::set<Vehicle *> &vehicles,
+                        std::vector<Road *> &roads,
+                        std::vector<Intersection *> &intersections,
+                        std::vector<Drivable *> &drivables);
+
+  void threadPlanRoute(const std::vector<Road *> &roads);
+
+  void threadGetAction(std::set<Vehicle *> &vehicles);
+
+  void threadUpdateAction(std::set<Vehicle *> &vehicles);
+
+  void threadUpdateLeaderAndGap(const std::vector<Drivable *> &drivables);
+
+  void threadUpdateLocation(const std::vector<Drivable *> &drivables);
 
-        std::map<int, std::pair<Vehicle *, int>> vehiclePool;
-        std::map<std::string, Vehicle *> vehicleMap;
-        std::vector<std::set<Vehicle *>> threadVehiclePool;
-        std::vector<std::vector<Road *>> threadRoadPool;
-        std::vector<std::vector<Intersection *>> threadIntersectionPool;
-        std::vector<std::vector<Drivable *>> threadDrivablePool;
-        std::vector<Flow> flows;
-        RoadNet roadnet;
-        int threadNum;
-        double interval;
-        bool saveReplay;
-        bool saveReplayInConfig; // saveReplay option in config json
-        bool warnings;
-        std::vector<std::pair<Vehicle *, double>> pushBuffer;
-        std::vector<Vehicle *> laneChangeNotifyBuffer;
-        std::set<Vehicle *> vehicleRemoveBuffer;
-        rapidjson::Document jsonRoot;
-        std::string stepLog;
+  void threadNotifyCross(const std::vector<Intersection *> &intersections);
 
-        size_t step = 0;
-        size_t activeVehicleCount = 0;
-        int seed;
-        std::mutex lock;
-        Barrier startBarrier, endBarrier;
-        std::vector<std::thread> threadPool;
-        bool finished = false;
-        std::string dir;
-        std::ofstream logOut;
+  void threadInitSegments(const std::vector<Road *> &roads);
 
-        bool rlTrafficLight;
-        bool laneChange;
-        int manuallyPushCnt = 0;
+  void threadPlanLaneChange(const std::set<Vehicle *> &vehicles);
 
-        int finishedVehicleCnt = 0;
-        double cumulativeTravelTime = 0;
+  void handleWaiting();
 
-    private:
-        void vehicleControl(Vehicle &vehicle, std::vector<std::pair<Vehicle *, double>> &buffer);
+  void updateLog();
 
-        void planRoute();
+  bool checkWarning();
 
-        void getAction();
+  bool loadRoadNet(const std::string &jsonFile);
 
-        void updateAction();
+  bool loadFlow(const std::string &jsonFilename);
 
-        void updateLocation();
+  std::vector<const Vehicle *>
+  getRunningVehicles(bool includeWaiting = false) const;
 
-        void updateLeaderAndGap();
+  void scheduleLaneChange();
 
-        void planLaneChange();
+  void insertShadow(Vehicle *vehicle);
 
+public:
+  std::mt19937 rnd;
 
-        void threadController(std::set<Vehicle *> &vehicles, 
-                              std::vector<Road *> &roads,
-                              std::vector<Intersection *> &intersections,
-                              std::vector<Drivable *> &drivables);
+  Engine(const std::string &configFile, int threadNum);
 
-        void threadPlanRoute(const std::vector<Road *> &roads);
+  double getInterval() const { return interval; }
 
-        void threadGetAction(std::set<Vehicle *> &vehicles);
+  bool hasLaneChange() const { return laneChange; }
 
-        void threadUpdateAction(std::set<Vehicle *> &vehicles);
+  bool loadConfig(const std::string &configFile);
 
-        void threadUpdateLeaderAndGap(const std::vector<Drivable *> &drivables);
+  void notifyCross();
 
-        void threadUpdateLocation(const std::vector<Drivable *> &drivables);
+  void nextStep();
 
-        void threadNotifyCross(const std::vector<Intersection *> &intersections);
+  bool checkPriority(int priority);
 
-        void threadInitSegments(const std::vector<Road *> &roads);
+  void pushVehicle(Vehicle *const vehicle, bool pushToDrivable = true);
 
-        void threadPlanLaneChange(const std::set<Vehicle *> &vehicles);
+  void setLogFile(const std::string &jsonFile, const std::string &logFile);
 
-        void handleWaiting();
+  void initSegments();
 
-        void updateLog();
+  ~Engine();
 
-        bool checkWarning();
+  // RL related api
 
-        bool loadRoadNet(const std::string &jsonFile);
+  void pushVehicle(const std::map<std::string, double> &info,
+                   const std::vector<std::string> &roads);
 
-        bool loadFlow(const std::string &jsonFilename);
+  size_t getVehicleCount() const;
 
-        std::vector<const Vehicle *> getRunningVehicles(bool includeWaiting=false) const;
+  std::vector<std::string> getVehicles(bool includeWaiting = false) const;
 
-        void scheduleLaneChange();
+  std::map<std::string, int> getLaneVehicleCount() const;
 
-        void insertShadow(Vehicle *vehicle);
+  std::map<std::string, int> getLaneWaitingVehicleCount() const;
 
-    public:
-        std::mt19937 rnd;
+  std::map<std::string, std::vector<std::string>> getLaneVehicles();
 
-        Engine(const std::string &configFile, int threadNum);
+  std::map<std::string, double> getVehicleSpeed() const;
 
-        double getInterval() const { return interval; }
+  std::map<std::string, double> getVehicleDistance() const;
 
-        bool hasLaneChange() const { return laneChange; }
+  std::string getLeader(const std::string &vehicleId) const;
 
-        bool loadConfig(const std::string &configFile);
+  double getCurrentTime() const;
 
-        void notifyCross();
+  double getAverageTravelTime() const;
 
-        void nextStep();
+  void setTrafficLightPhase(const std::string &id, int phaseIndex);
 
-        bool checkPriority(int priority);
+  void setReplayLogFile(const std::string &logFile);
 
-        void pushVehicle(Vehicle *const vehicle, bool pushToDrivable = true);
+  void setSaveReplay(bool open);
 
-        void setLogFile(const std::string &jsonFile, const std::string &logFile);
+  void setVehicleSpeed(const std::string &id, double speed);
 
-        void initSegments();
+  void setRandomSeed(int seed) { rnd.seed(seed); }
 
-        ~Engine();
+  void reset(bool resetRnd = false);
 
-        // RL related api
+  // archive
+  void load(const Archive &archive) { archive.resume(*this); }
+  Archive snapshot() { return Archive(*this); }
+  void loadFromFile(const char *fileName);
 
-        void pushVehicle(const std::map<std::string, double> &info, const std::vector<std::string> &roads);
+  bool setRoute(const std::string &vehicle_id,
+                const std::vector<std::string> &anchor_id);
 
-        size_t getVehicleCount() const;
+  std::map<std::string, std::string>
+  getVehicleInfo(const std::string &id) const;
 
-        std::vector<std::string> getVehicles(bool includeWaiting = false) const;
+  void next_step(uint n) {
+    for (int i = 0; i < n; ++i) {
+      nextStep();
+    }
+  }
 
-        std::map<std::string, int> getLaneVehicleCount() const;
+  int get_junction_count() const { return roadnet.intersections.size(); };
 
-        std::map<std::string, int> getLaneWaitingVehicleCount() const;
+  std::vector<int> get_junction_phase_counts() const {
+    std::vector<int> out;
+    for (auto &i : roadnet.intersections) {
+      out.push_back(i.getTrafficLight().getPhases().size());
+    }
+    return out;
+  }
 
-        std::map<std::string, std::vector<std::string>> getLaneVehicles();
+  int get_running_vehicle_count() const;
 
-        std::map<std::string, double> getVehicleSpeed() const;
+  int get_finished_vehicle_count() const;
 
-        std::map<std::string, double> getVehicleDistance() const;
+  double get_finished_vehicle_average_traveling_time() const;
 
-        std::string getLeader(const std::string &vehicleId) const;
+  double get_departed_vehicle_average_traveling_time() const;
 
-        double getCurrentTime() const;
+  std::vector<double> get_lane_lengths() const;
 
-        double getAverageTravelTime() const;
+  std::vector<int> get_lane_vehicle_counts() const;
 
-        void setTrafficLightPhase(const std::string &id, int phaseIndex);
+  std::vector<int> get_lane_waiting_vehicle_counts(float speed_threshold) const;
+  std::vector<int>
 
-        void setReplayLogFile(const std::string &logFile);
+  get_lane_waiting_at_end_vehicle_counts(float speed_threshold,
+                                         float distance_to_end) const;
 
-        void setSaveReplay(bool open);
+  std::vector<std::pair<int, double>> get_vehicle_road_speed() const;
 
-        void setVehicleSpeed(const std::string &id, double speed);
+  std::vector<std::tuple<int, double, std::string>>
+  get_vehicle_road_speed_id() const;
 
-        void setRandomSeed(int seed) { rnd.seed(seed); }
-        
-        void reset(bool resetRnd = false);
+  std::vector<std::pair<std::vector<int>, std::vector<int>>>
+  get_junction_inout_lanes() const;
 
-        // archive
-        void load(const Archive &archive) { archive.resume(*this); }
-        Archive snapshot() { return Archive(*this); }
-        void loadFromFile(const char *fileName);
+  std::vector<std::vector<std::pair<std::vector<int>, std::vector<int>>>>
+  get_junction_phase_lanes() const;
 
-        bool setRoute(const std::string &vehicle_id, const std::vector<std::string> &anchor_id);
+  void set_tl_phase(int junction_id, int phase_id);
 
-        std::map<std::string, std::string> getVehicleInfo(const std::string &id) const;
-    };
+  void set_tl_phase_batch(const std::vector<uint> &junction_ids,
+                          const std::vector<uint> &phase_ids) {
+    for (int i = 0, s = junction_ids.size(); i < s; ++i) {
+      set_tl_phase(junction_ids[i], phase_ids[i]);
+    }
+  }
+};
 
-}
+} // namespace CityFlow
 
-#endif //CITYFLOW_ENGINE_H
+#endif // CITYFLOW_ENGINE_H
diff --git a/src/flow/flow.cpp b/src/flow/flow.cpp
index cc2612c..021517e 100644
--- a/src/flow/flow.cpp
+++ b/src/flow/flow.cpp
@@ -1,33 +1,35 @@
 #include "flow/flow.h"
 #include "engine/engine.h"
 
-
 namespace CityFlow {
-    void Flow::nextStep(double timeInterval) {
-        if (!valid) return;
-        if (endTime != -1 && currentTime > endTime) return;
-        if (currentTime >= startTime) {
-            while (nowTime >= interval) {
-                Vehicle* vehicle = new Vehicle(vehicleTemplate, id + "_" + std::to_string(cnt++), engine, this);
-                int priority = vehicle->getPriority();
-                while (engine->checkPriority(priority)) priority = engine->rnd();
-                vehicle->setPriority(priority);
-                engine->pushVehicle(vehicle, false);
-                vehicle->getFirstRoad()->addPlanRouteVehicle(vehicle);
-                nowTime -= interval;
-            }
-            nowTime += timeInterval;
-        }
-        currentTime += timeInterval;
+void Flow::nextStep(double timeInterval) {
+  if (!valid)
+    return;
+  if (endTime != -1 && currentTime > endTime)
+    return;
+  if (currentTime >= startTime) {
+    while (nowTime >= interval) {
+      Vehicle *vehicle = new Vehicle(
+          vehicleTemplate, id + "_" + std::to_string(cnt++), engine, this);
+      int priority = vehicle->getPriority();
+      while (engine->checkPriority(priority))
+        priority = engine->rnd();
+      vehicle->setPriority(priority);
+      engine->pushVehicle(vehicle, false);
+      ++engine->_running_vehicle_cnt;
+      vehicle->getFirstRoad()->addPlanRouteVehicle(vehicle);
+      nowTime -= interval;
     }
+    nowTime += timeInterval;
+  }
+  currentTime += timeInterval;
+}
 
-    std::string Flow::getId() const {
-        return id;
-    }
+std::string Flow::getId() const { return id; }
 
-    void Flow::reset() {
-        nowTime = interval;
-        currentTime = 0;
-        cnt = 0;
-    }
-}
\ No newline at end of file
+void Flow::reset() {
+  nowTime = interval;
+  currentTime = 0;
+  cnt = 0;
+}
+} // namespace CityFlow
\ No newline at end of file
diff --git a/src/flow/flow.h b/src/flow/flow.h
index 111dcb9..f7271e9 100644
--- a/src/flow/flow.h
+++ b/src/flow/flow.h
@@ -3,53 +3,54 @@
 
 #include <iostream>
 
-#include "vehicle/vehicle.h"
 #include "flow/route.h"
+#include "vehicle/vehicle.h"
 
 namespace CityFlow {
-    class Engine;
-
-    struct VehicleInfo;
-
-    class Flow {
-        friend class Archive;
-    private:
-        VehicleInfo vehicleTemplate;
-        std::shared_ptr<const Route> route;
-        double interval;
-        double nowTime = 0;
-        double currentTime = 0;
-        int startTime = 0;
-        int endTime = -1;
-        int cnt = 0;
-        Engine *engine;
-        std::string id;
-        bool valid = true;
-
-    public:
-        Flow(const VehicleInfo &vehicleTemplate, double timeInterval,
-            Engine *engine, int startTime, int endTime, const std::string &id) 
-            : vehicleTemplate(vehicleTemplate), interval(timeInterval),
-              startTime(startTime), endTime(endTime), engine(engine), id(id) {
-            assert(timeInterval >= 1 || (startTime == endTime));
-            nowTime = interval;
-        }
-
-        void nextStep(double timeInterval);
-
-        std::string getId() const;
-
-        bool isValid() const { return this->valid; }
-
-        void setValid(const bool valid) {
-            if (this->valid && !valid)
-                std::cerr << "[warning] Invalid route '" << id << "'. Omitted by default." << std::endl;
-            this->valid = valid;
-        }
-
-        void reset();
-
-    };
-}
-
-#endif //CITYFLOW_FLOW_H
+class Engine;
+
+struct VehicleInfo;
+
+class Flow {
+  friend class Archive;
+
+private:
+  VehicleInfo vehicleTemplate;
+  std::shared_ptr<const Route> route;
+  double interval;
+  double nowTime = 0;
+  double currentTime = 0;
+  int startTime = 0;
+  int endTime = -1;
+  int cnt = 0;
+  Engine *engine;
+  std::string id;
+  bool valid = true;
+
+public:
+  Flow(const VehicleInfo &vehicleTemplate, double timeInterval, Engine *engine,
+       int startTime, int endTime, const std::string &id)
+      : vehicleTemplate(vehicleTemplate), interval(timeInterval),
+        startTime(startTime), endTime(endTime), engine(engine), id(id) {
+    assert(timeInterval >= 1 || (startTime == endTime));
+    nowTime = interval;
+  }
+
+  void nextStep(double timeInterval);
+
+  std::string getId() const;
+
+  bool isValid() const { return this->valid; }
+
+  void setValid(const bool valid) {
+    if (this->valid && !valid)
+      std::cerr << "[warning] Invalid route '" << id << "'. Omitted by default."
+                << std::endl;
+    this->valid = valid;
+  }
+
+  void reset();
+};
+} // namespace CityFlow
+
+#endif // CITYFLOW_FLOW_H
diff --git a/src/flow/route.h b/src/flow/route.h
index b8f1f8c..60dd91b 100644
--- a/src/flow/route.h
+++ b/src/flow/route.h
@@ -4,19 +4,18 @@
 #include <vector>
 
 namespace CityFlow {
-    class Road;
+class Road;
 
-    class Route {
-    private:
-        std::vector<Road *> route;
+class Route {
+private:
+  std::vector<Road *> route;
 
-    public:
+public:
+  Route() = default;
 
-        Route() = default;
+  explicit Route(const std::vector<Road *> &route) : route(route) {}
 
-        explicit Route(const std::vector<Road *> &route) : route(route) { }
-
-        std::vector<Road *> getRoute() const { return route; }
-    };
-}
-#endif //CITYFLOW_ROUTE_H
+  std::vector<Road *> getRoute() const { return route; }
+};
+} // namespace CityFlow
+#endif // CITYFLOW_ROUTE_H
diff --git a/src/roadnet/roadnet.cpp b/src/roadnet/roadnet.cpp
index aff5371..42bc8e5 100644
--- a/src/roadnet/roadnet.cpp
+++ b/src/roadnet/roadnet.cpp
@@ -5,946 +5,1064 @@
 #include "rapidjson/document.h"
 #include "rapidjson/filereadstream.h"
 
-#include <iostream>
 #include <algorithm>
+#include <iostream>
 
 using std::map;
 using std::string;
-
+template <class T> std::vector<T> &remove_duplicate(std::vector<T> &arr) {
+  std::sort(arr.begin(), arr.end());
+  arr.erase(std::unique(arr.begin(), arr.end()), arr.end());
+  return arr;
+}
 namespace CityFlow {
-    static double getLengthOfPoints(const std::vector<Point> &points);
-
-    static Point getPointByDistance(const std::vector<Point> &points, double dis) {
-        dis = min2double(max2double(dis, 0), getLengthOfPoints(points));
-        if (dis <= 0.0)
-            return points[0];
-        for (size_t i = 1; i < points.size(); i++) {
-            double len = (points[i - 1] - points[i]).len();
-            if (dis > len)
-                dis -= len;
-            else
-                return points[i - 1] + (points[i] - points[i - 1]) * (dis / len);
-        }
-        return points.back();
-    }
+static double getLengthOfPoints(const std::vector<Point> &points);
+
+static Point getPointByDistance(const std::vector<Point> &points, double dis) {
+  dis = min2double(max2double(dis, 0), getLengthOfPoints(points));
+  if (dis <= 0.0)
+    return points[0];
+  for (size_t i = 1; i < points.size(); i++) {
+    double len = (points[i - 1] - points[i]).len();
+    if (dis > len)
+      dis -= len;
+    else
+      return points[i - 1] + (points[i] - points[i - 1]) * (dis / len);
+  }
+  return points.back();
+}
 
-    static double getLengthOfPoints(const std::vector<Point> &points) {
-        double length = 0.0;
-        for (size_t i = 0; i + 1 < points.size(); i++)
-            length += (points[i + 1] - points[i]).len();
-        return length;
+static double getLengthOfPoints(const std::vector<Point> &points) {
+  double length = 0.0;
+  for (size_t i = 0; i + 1 < points.size(); i++)
+    length += (points[i + 1] - points[i]).len();
+  return length;
+}
+
+Point RoadNet::getPoint(const Point &p1, const Point &p2, double a) {
+  return Point((p2.x - p1.x) * a + p1.x, (p2.y - p1.y) * a + p1.y);
+}
+
+bool RoadNet::loadFromJson(std::string jsonFileName) {
+  rapidjson::Document document;
+  if (!readJsonFromFile(jsonFileName, document)) {
+    std::cerr << "cannot open roadnet file" << std::endl;
+    return false;
+  }
+  // std::clog << root << std::endl;
+  std::list<std::string> path;
+  if (!document.IsObject())
+    throw JsonTypeError("roadnet config file", "object");
+  try {
+    const rapidjson::Value &interValues =
+        getJsonMemberArray("intersections", document);
+    const rapidjson::Value &roadValues = getJsonMemberArray("roads", document);
+
+    //  build mapping
+    roads.resize(roadValues.Size());
+    intersections.resize(interValues.Size());
+    for (rapidjson::SizeType i = 0; i < roadValues.Size(); i++) {
+      path.emplace_back("road[" + std::to_string(i) + "]");
+      std::string id = getJsonMember<const char *>("id", roadValues[i]);
+      roadMap[id] = &roads[i];
+      roads[i].id = id;
+      path.pop_back();
+    }
+    assert(path.empty());
+
+    for (rapidjson::SizeType i = 0; i < interValues.Size(); i++) {
+      path.emplace_back("intersection[" + std::to_string(i) + "]");
+      std::string id = getJsonMember<const char *>("id", interValues[i]);
+      ;
+      interMap[id] = &intersections[i];
+      intersections[i].id = id;
+      path.pop_back();
+    }
+    assert(path.empty());
+
+    //  read roads
+    path.emplace_back("roads");
+    for (rapidjson::SizeType i = 0; i < roadValues.Size(); i++) {
+      //  read startIntersection, endIntersection
+      path.emplace_back(roads[i].getId());
+      const auto &curRoadValue = roadValues[i];
+      if (!curRoadValue.IsObject()) {
+        throw JsonTypeError("road[" + std::to_string(i) + "]", "object");
+      }
+      roads[i].startIntersection = interMap[getJsonMember<const char *>(
+          "startIntersection", curRoadValue)];
+      roads[i].endIntersection = interMap[getJsonMember<const char *>(
+          "endIntersection", curRoadValue)];
+
+      // Check
+      if (!roads[i].startIntersection)
+        throw JsonFormatError("startIntersection does not exist.");
+      if (!roads[i].endIntersection)
+        throw JsonFormatError("endIntersection does not exist.");
+
+      //  read lanes
+      const auto &lanesValue = getJsonMemberArray("lanes", curRoadValue);
+      int laneIndex = 0;
+      for (const auto &laneValue : lanesValue.GetArray()) {
+        path.emplace_back("lane[" + std::to_string(laneIndex) + "]");
+        if (!laneValue.IsObject())
+          throw JsonTypeError("lane", "object");
+        double width = getJsonMember<double>("width", laneValue);
+        double maxSpeed = getJsonMember<double>("maxSpeed", laneValue);
+        roads[i].lanes.emplace_back(width, maxSpeed, laneIndex, &roads[i]);
+        laneIndex++;
+        path.pop_back();
+      }
+
+      for (auto &lane : roads[i].lanes) {
+        drivableMap[lane.getId()] = &lane;
+      }
+
+      //  read points
+      const auto &pointsValue = getJsonMemberArray("points", curRoadValue);
+      for (const auto &pointValue : pointsValue.GetArray()) {
+        path.emplace_back("point[" + std::to_string(roads[i].points.size()) +
+                          "]");
+        if (!pointValue.IsObject())
+          throw JsonTypeError("point of road", "object");
+        double x = getJsonMember<double>("x", pointValue);
+        double y = getJsonMember<double>("y", pointValue);
+        roads[i].points.emplace_back(x, y);
+        path.pop_back();
+      }
+      path.pop_back();
     }
+    path.pop_back();
+    assert(path.empty());
 
-    Point RoadNet::getPoint(const Point &p1, const Point &p2, double a) {
-        return Point((p2.x - p1.x) * a + p1.x, (p2.y - p1.y) * a + p1.y);
+    for (rapidjson::SizeType i = 0; i < roadValues.Size(); i++) {
+      roads[i].initLanesPoints();
     }
 
-    bool RoadNet::loadFromJson(std::string jsonFileName) {
-        rapidjson::Document document;
-        if (!readJsonFromFile(jsonFileName, document)) {
-            std::cerr << "cannot open roadnet file" << std::endl;
-            return false;
-        }
-        //std::clog << root << std::endl;
-        std::list<std::string> path;
-        if (!document.IsObject())
-            throw JsonTypeError("roadnet config file", "object");
-        try {
-            const rapidjson::Value &interValues = getJsonMemberArray("intersections", document);
-            const rapidjson::Value &roadValues = getJsonMemberArray("roads", document);
-
-            //  build mapping
-            roads.resize(roadValues.Size());
-            intersections.resize(interValues.Size());
-            for (rapidjson::SizeType i = 0; i < roadValues.Size(); i++) {
-                path.emplace_back("road[" + std::to_string(i) + "]");
-                std::string id = getJsonMember<const char*>("id", roadValues[i]);
-                roadMap[id] = &roads[i];
-                roads[i].id = id;
-                path.pop_back();
-            }
-            assert(path.empty());
-
-            for (rapidjson::SizeType i = 0; i < interValues.Size(); i++) {
-                path.emplace_back("intersection[" + std::to_string(i) + "]");
-                std::string id = getJsonMember<const char*>("id", interValues[i]);;
-                interMap[id] = &intersections[i];
-                intersections[i].id = id;
-                path.pop_back();
-            }
-            assert(path.empty());
-
-            //  read roads
-            path.emplace_back("roads");
-            for (rapidjson::SizeType i = 0; i < roadValues.Size(); i++) {
-                //  read startIntersection, endIntersection
-                path.emplace_back(roads[i].getId());
-                const auto &curRoadValue = roadValues[i];
-                if (!curRoadValue.IsObject()) {
-                    throw JsonTypeError("road[" + std::to_string(i) + "]", "object");
-                }
-                roads[i].startIntersection = interMap[getJsonMember<const char*>("startIntersection", curRoadValue)];
-                roads[i].endIntersection = interMap[getJsonMember<const char*>("endIntersection", curRoadValue)];
-                
-                // Check
-                if (!roads[i].startIntersection) throw JsonFormatError("startIntersection does not exist.");
-                if (!roads[i].endIntersection) throw JsonFormatError("endIntersection does not exist.");
-
-                //  read lanes
-                const auto &lanesValue = getJsonMemberArray("lanes", curRoadValue);
-                int laneIndex = 0;
-                for (const auto &laneValue : lanesValue.GetArray()) {
-                    path.emplace_back("lane[" + std::to_string(laneIndex) + "]");
-                    if (!laneValue.IsObject())
-                        throw JsonTypeError("lane", "object");
-                    double width = getJsonMember<double>("width", laneValue);
-                    double maxSpeed = getJsonMember<double>("maxSpeed", laneValue);
-                    roads[i].lanes.emplace_back(width, maxSpeed, laneIndex, &roads[i]);
-                    laneIndex++;
-                    path.pop_back();
-                }
-
-                for (auto &lane : roads[i].lanes) {
-                    drivableMap[lane.getId()] = &lane;
-                }
-
-                //  read points
-                const auto &pointsValue = getJsonMemberArray("points", curRoadValue);
-                for (const auto &pointValue : pointsValue.GetArray()) {
-                    path.emplace_back("point[" + std::to_string(roads[i].points.size()) + "]");
-                    if (!pointValue.IsObject())
-                        throw JsonTypeError("point of road", "object");
-                    double x = getJsonMember<double>("x", pointValue);
-                    double y = getJsonMember<double>("y", pointValue);
-                    roads[i].points.emplace_back(x, y);
-                    path.pop_back();
-                }
-                path.pop_back();
+    //  read intersections
+    std::map<std::string, RoadLinkType> typeMap = {
+        {"turn_left", turn_left},
+        {"turn_right", turn_right},
+        {"go_straight", go_straight}};
+    path.emplace_back("intersections");
+    for (rapidjson::SizeType i = 0; i < interValues.Size(); i++) {
+      path.emplace_back(intersections[i].getId());
+      const auto &curInterValue = interValues[i];
+      if (!curInterValue.IsObject()) {
+        throw JsonTypeError("intersection", "object");
+        return false;
+      }
+
+      //  read point
+      const auto &pointValue = getJsonMemberObject("point", curInterValue);
+      intersections[i].isVirtual =
+          getJsonMember<bool>("virtual", curInterValue);
+      double x = getJsonMember<double>("x", pointValue);
+      double y = getJsonMember<double>("y", pointValue);
+      intersections[i].point = Point(x, y);
+
+      //  read roads
+      const auto &roadsValue = getJsonMemberArray("roads", curInterValue);
+      for (auto &roadNameValue : roadsValue.GetArray()) {
+        path.emplace_back("roads[" +
+                          std::to_string(intersections[i].roads.size()) + "]");
+        std::string roadName = roadNameValue.GetString();
+        if (!roadMap.count(roadName))
+          throw JsonFormatError("No such road: " + roadName);
+        intersections[i].roads.push_back(roadMap[roadName]);
+        path.pop_back();
+      }
+
+      //  skip other information if intersection is virtual
+      intersections[i].trafficLight.intersection = &intersections[i];
+      if (intersections[i].isVirtual) {
+        path.pop_back();
+        continue;
+      }
+
+      //  read width
+      intersections[i].width = getJsonMember<double>("width", curInterValue);
+
+      //  read laneLinks
+      const auto &roadLinksValue =
+          getJsonMemberArray("roadLinks", curInterValue);
+      intersections[i].roadLinks.resize(roadLinksValue.Size());
+      int roadLinkIndex = 0;
+      for (const auto &roadLinkValue : roadLinksValue.GetArray()) {
+        path.emplace_back("roadLinks[" + std::to_string(roadLinkIndex) + "]");
+        if (!roadLinkValue.IsObject())
+          throw JsonTypeError("roadLink", "object");
+        RoadLink &roadLink = intersections[i].roadLinks[roadLinkIndex];
+        roadLink.index = roadLinkIndex++;
+        roadLink.type =
+            typeMap[getJsonMember<const char *>("type", roadLinkValue)];
+        roadLink.startRoad =
+            roadMap[getJsonMember<const char *>("startRoad", roadLinkValue)];
+        roadLink.endRoad =
+            roadMap[getJsonMember<const char *>("endRoad", roadLinkValue)];
+
+        const auto &laneLinksValue =
+            getJsonMemberArray("laneLinks", roadLinkValue);
+        roadLink.laneLinks.resize(laneLinksValue.Size());
+        int laneLinkIndex = 0;
+        for (const auto &laneLinkValue : laneLinksValue.GetArray()) {
+          path.emplace_back("laneLinks[" + std::to_string(laneLinkIndex) + "]");
+          if (!laneLinkValue.IsObject())
+            throw JsonTypeError("laneLink", "object");
+          LaneLink &laneLink = roadLink.laneLinks[laneLinkIndex++];
+
+          int startLaneIndex =
+              getJsonMember<int>("startLaneIndex", laneLinkValue);
+          int endLaneIndex = getJsonMember<int>("endLaneIndex", laneLinkValue);
+          if (startLaneIndex >=
+                  static_cast<int>(roadLink.startRoad->lanes.size()) ||
+              startLaneIndex < 0)
+            throw JsonFormatError("startLaneIndex out of range");
+          if (endLaneIndex >=
+                  static_cast<int>(roadLink.endRoad->lanes.size()) ||
+              endLaneIndex < 0)
+            throw JsonFormatError("startLaneIndex out of range");
+          Lane *startLane = &roadLink.startRoad->lanes[startLaneIndex];
+          Lane *endLane = &roadLink.endRoad->lanes[endLaneIndex];
+
+          auto iter = laneLinkValue.FindMember("points");
+          if (iter != laneLinkValue.MemberEnd() && !iter->value.IsArray())
+            throw JsonTypeError("points in laneLink", "array");
+          if (iter != laneLinkValue.MemberEnd() && !iter->value.Empty())
+            for (const auto &pValue : iter->value.GetArray()) {
+              laneLink.points.emplace_back(getJsonMember<double>("x", pValue),
+                                           getJsonMember<double>("y", pValue));
             }
-            path.pop_back();
-            assert(path.empty());
-
-            for (rapidjson::SizeType i = 0; i < roadValues.Size(); i++) {
-                roads[i].initLanesPoints();
+          else {
+            Point start = Point(startLane->getPointByDistance(
+                startLane->getLength() -
+                startLane->getEndIntersection()->width));
+            Point end = Point(endLane->getPointByDistance(
+                0.0 + endLane->getStartIntersection()->width));
+            double len = (Point(end.x - start.x, end.y - start.y)).len();
+            Point startDirection = startLane->getDirectionByDistance(
+                startLane->getLength() -
+                startLane->getEndIntersection()->width);
+            Point endDirection = endLane->getDirectionByDistance(
+                0.0 + endLane->getStartIntersection()->width);
+            double minGap = 5;
+            double gap1X = startDirection.x * len * 0.5;
+            double gap1Y = startDirection.y * len * 0.5;
+            double gap2X = -endDirection.x * len * 0.5;
+            double gap2Y = -endDirection.y * len * 0.5;
+            if (gap1X * gap1X + gap1Y * gap1Y < 25 &&
+                startLane->getEndIntersection()->width >= 5) {
+              gap1X = minGap * startDirection.x;
+              gap1Y = minGap * startDirection.y;
             }
-
-            //  read intersections
-            std::map<std::string, RoadLinkType> typeMap = {{"turn_left",   turn_left},
-                                                           {"turn_right",  turn_right},
-                                                           {"go_straight", go_straight}};
-            path.emplace_back("intersections");
-            for (rapidjson::SizeType i = 0; i < interValues.Size(); i++) {
-                path.emplace_back(intersections[i].getId());
-                const auto &curInterValue = interValues[i];
-                if (!curInterValue.IsObject()) {
-                    throw JsonTypeError("intersection", "object");
-                    return false;
-                }
-
-                //  read point
-                const auto &pointValue = getJsonMemberObject("point", curInterValue);
-                intersections[i].isVirtual = getJsonMember<bool>("virtual", curInterValue);
-                double x = getJsonMember<double>("x", pointValue);
-                double y = getJsonMember<double>("y", pointValue);
-                intersections[i].point = Point(x, y);
-
-                //  read roads
-                const auto &roadsValue = getJsonMemberArray("roads", curInterValue);
-                for (auto &roadNameValue : roadsValue.GetArray()) {
-                    path.emplace_back("roads[" + std::to_string(intersections[i].roads.size()) + "]");
-                    std::string roadName = roadNameValue.GetString();
-                    if (!roadMap.count(roadName))
-                        throw JsonFormatError("No such road: " + roadName);
-                    intersections[i].roads.push_back(roadMap[roadName]);
-                    path.pop_back();
-                }
-
-                //  skip other information if intersection is virtual
-                intersections[i].trafficLight.intersection = &intersections[i];
-                if (intersections[i].isVirtual) {
-                    path.pop_back();
-                    continue;
-                }
-
-                //  read width
-                intersections[i].width = getJsonMember<double>("width", curInterValue);
-
-                //  read laneLinks
-                const auto &roadLinksValue = getJsonMemberArray("roadLinks", curInterValue);
-                intersections[i].roadLinks.resize(roadLinksValue.Size());
-                int roadLinkIndex = 0;
-                for (const auto &roadLinkValue : roadLinksValue.GetArray()) {
-                    path.emplace_back("roadLinks[" + std::to_string(roadLinkIndex) + "]");
-                    if (!roadLinkValue.IsObject())
-                        throw JsonTypeError("roadLink", "object");
-                    RoadLink &roadLink = intersections[i].roadLinks[roadLinkIndex];
-                    roadLink.index = roadLinkIndex++;
-                    roadLink.type = typeMap[getJsonMember<const char*>("type", roadLinkValue)];
-                    roadLink.startRoad = roadMap[getJsonMember<const char*>("startRoad", roadLinkValue)];
-                    roadLink.endRoad = roadMap[getJsonMember<const char*>("endRoad", roadLinkValue)];
-
-                    const auto &laneLinksValue = getJsonMemberArray("laneLinks", roadLinkValue);
-                    roadLink.laneLinks.resize(laneLinksValue.Size());
-                    int laneLinkIndex = 0;
-                    for (const auto &laneLinkValue : laneLinksValue.GetArray()) {
-                        path.emplace_back("laneLinks[" + std::to_string(laneLinkIndex) + "]");
-                        if (!laneLinkValue.IsObject())
-                            throw JsonTypeError("laneLink", "object");
-                        LaneLink &laneLink = roadLink.laneLinks[laneLinkIndex++];
-
-                        int startLaneIndex = getJsonMember<int>("startLaneIndex", laneLinkValue);
-                        int endLaneIndex = getJsonMember<int>("endLaneIndex", laneLinkValue);
-                        if (startLaneIndex >= static_cast<int>(roadLink.startRoad->lanes.size()) || startLaneIndex < 0)
-                            throw JsonFormatError("startLaneIndex out of range");
-                        if (endLaneIndex >= static_cast<int>(roadLink.endRoad->lanes.size()) || endLaneIndex < 0)
-                            throw JsonFormatError("startLaneIndex out of range");
-                        Lane *startLane = &roadLink.startRoad->lanes[startLaneIndex];
-                        Lane *endLane = &roadLink.endRoad->lanes[endLaneIndex];
-
-                        auto iter = laneLinkValue.FindMember("points");
-                        if (iter != laneLinkValue.MemberEnd() && !iter->value.IsArray())
-                            throw JsonTypeError("points in laneLink", "array");
-                        if (iter != laneLinkValue.MemberEnd() && !iter->value.Empty())
-                            for (const auto &pValue : iter->value.GetArray()) {
-                                laneLink.points.emplace_back(getJsonMember<double>("x", pValue),
-                                                             getJsonMember<double>("y", pValue));
-                            }
-                        else {
-                            Point start = Point(startLane->getPointByDistance(
-                                    startLane->getLength() - startLane->getEndIntersection()->width));
-                            Point end = Point(
-                                    endLane->getPointByDistance(0.0 + endLane->getStartIntersection()->width));
-                            double len = (Point(end.x - start.x, end.y - start.y)).len();
-                            Point startDirection = startLane->getDirectionByDistance(
-                                    startLane->getLength() - startLane->getEndIntersection()->width);
-                            Point endDirection = endLane->getDirectionByDistance(
-                                    0.0 + endLane->getStartIntersection()->width);
-                            double minGap = 5;
-                            double gap1X = startDirection.x * len * 0.5;
-                            double gap1Y = startDirection.y * len * 0.5;
-                            double gap2X = -endDirection.x * len * 0.5;
-                            double gap2Y = -endDirection.y * len * 0.5;
-                            if (gap1X * gap1X + gap1Y * gap1Y < 25 && startLane->getEndIntersection()->width >= 5) {
-                                gap1X = minGap * startDirection.x;
-                                gap1Y = minGap * startDirection.y;
-                            }
-                            if (gap2X * gap2X + gap2Y * gap2Y < 25 && endLane->getStartIntersection()->width >= 5) {
-                                gap2X = minGap * endDirection.x;
-                                gap2Y = minGap * endDirection.y;
-                            }
-                            Point mid1 = Point(start.x + gap1X,start.y + gap1Y);
-                            Point mid2 = Point(end.x + gap2X,end.y + gap2Y);
-                            int numPoints = 10;
-                            for (int i = 0; i <= numPoints; i++) {
-                                Point p1 = getPoint(start, mid1, i / double(numPoints));
-                                Point p2 = getPoint(mid1, mid2, i / double(numPoints));
-                                Point p3 = getPoint(mid2, end, i / double(numPoints));
-                                Point p4 = getPoint(p1, p2, i / double(numPoints));
-                                Point p5 = getPoint(p2, p3, i / double(numPoints));
-                                Point p6 = getPoint(p4, p5, i / double(numPoints));
-                                laneLink.points.emplace_back(p6.x, p6.y);
-                            }
-                        }
-                        laneLink.roadLink = &roadLink;
-
-                        laneLink.startLane = startLane;
-                        laneLink.endLane = endLane;
-                        laneLink.length = getLengthOfPoints(laneLink.points);
-                        startLane->laneLinks.push_back(&laneLink);
-                        drivableMap.emplace(laneLink.getId(), &laneLink);
-                        path.pop_back();
-                    }
-                    roadLink.intersection = &intersections[i];
-                    path.pop_back();
-                }
-
-                //  read trafficLight
-                const auto &trafficLightValue = getJsonMemberObject("trafficLight", curInterValue);
-                path.emplace_back("trafficLight");
-                const auto &lightPhasesValue = getJsonMemberArray("lightphases", trafficLightValue);
-                for (const auto &lightPhaseValue : lightPhasesValue.GetArray()) {
-                    path.emplace_back("lightphases[" + std::to_string(intersections[i].trafficLight.phases.size()) + "]");
-                    if (!lightPhaseValue.IsObject())
-                        throw JsonTypeError("lightphase", "object");
-                    LightPhase lightPhase;
-                    lightPhase.time = getJsonMember<double>("time", lightPhaseValue);
-                    lightPhase.roadLinkAvailable = std::vector<bool>(intersections[i].roadLinks.size(), false);
-                    const auto& availableRoadLinksValue =
-                            getJsonMemberArray("availableRoadLinks", lightPhaseValue);
-                    for (rapidjson::SizeType index = 0; index < availableRoadLinksValue.Size(); index++) {
-                        path.emplace_back("availableRoadLinks[" + std::to_string(index) + "]");
-                        if (!availableRoadLinksValue[index].IsInt())
-                            throw JsonTypeError("availableRoadLink", "int");
-                        size_t indexInRoadLinks = availableRoadLinksValue[index].GetUint();
-                        if (indexInRoadLinks >= lightPhase.roadLinkAvailable.size())
-                            throw JsonFormatError("index out of range");
-                        lightPhase.roadLinkAvailable[indexInRoadLinks] = true;
-                        path.pop_back();
-                    }
-                    intersections[i].trafficLight.phases.push_back(lightPhase);
-                    path.pop_back();
-                }
-                path.pop_back(); // End of traffic light
-                intersections[i].trafficLight.init(0);
-
-                path.pop_back(); // End of intersection
+            if (gap2X * gap2X + gap2Y * gap2Y < 25 &&
+                endLane->getStartIntersection()->width >= 5) {
+              gap2X = minGap * endDirection.x;
+              gap2Y = minGap * endDirection.y;
             }
-            path.pop_back();
-            assert(path.empty());
-        }catch (const JsonFormatError &e) {
-            std::cerr << "Error occurred when reading the roadnet file: " << std::endl;
-            for (const auto &node : path) {
-                std::cerr << "/" << node;
+            Point mid1 = Point(start.x + gap1X, start.y + gap1Y);
+            Point mid2 = Point(end.x + gap2X, end.y + gap2Y);
+            int numPoints = 10;
+            for (int i = 0; i <= numPoints; i++) {
+              Point p1 = getPoint(start, mid1, i / double(numPoints));
+              Point p2 = getPoint(mid1, mid2, i / double(numPoints));
+              Point p3 = getPoint(mid2, end, i / double(numPoints));
+              Point p4 = getPoint(p1, p2, i / double(numPoints));
+              Point p5 = getPoint(p2, p3, i / double(numPoints));
+              Point p6 = getPoint(p4, p5, i / double(numPoints));
+              laneLink.points.emplace_back(p6.x, p6.y);
             }
-            std::cerr << " " << e.what() << std::endl;
-            return false;
+          }
+          laneLink.roadLink = &roadLink;
+
+          laneLink.startLane = startLane;
+          laneLink.endLane = endLane;
+          laneLink.length = getLengthOfPoints(laneLink.points);
+          assert(!std::isnan(laneLink.length));
+          startLane->laneLinks.push_back(&laneLink);
+          drivableMap.emplace(laneLink.getId(), &laneLink);
+          path.pop_back();
         }
-
-        for (auto &intersection : intersections)
-            intersection.initCrosses();
-        VehicleInfo vehicleTemplate;
-
-        for (auto &road : roads)
-            road.initLanesPoints();
-
-        for (auto &road : roads) {
-            road.buildSegmentationByInterval((vehicleTemplate.len + vehicleTemplate.minGap) * MAX_NUM_CARS_ON_SEGMENT);
+        roadLink.intersection = &intersections[i];
+        path.pop_back();
+      }
+
+      //  read trafficLight
+      const auto &trafficLightValue =
+          getJsonMemberObject("trafficLight", curInterValue);
+      path.emplace_back("trafficLight");
+      const auto &lightPhasesValue =
+          getJsonMemberArray("lightphases", trafficLightValue);
+      for (const auto &lightPhaseValue : lightPhasesValue.GetArray()) {
+        path.emplace_back(
+            "lightphases[" +
+            std::to_string(intersections[i].trafficLight.phases.size()) + "]");
+        if (!lightPhaseValue.IsObject())
+          throw JsonTypeError("lightphase", "object");
+        LightPhase lightPhase;
+        lightPhase.time = getJsonMember<double>("time", lightPhaseValue);
+        lightPhase.roadLinkAvailable =
+            std::vector<bool>(intersections[i].roadLinks.size(), false);
+        const auto &availableRoadLinksValue =
+            getJsonMemberArray("availableRoadLinks", lightPhaseValue);
+        for (rapidjson::SizeType index = 0;
+             index < availableRoadLinksValue.Size(); index++) {
+          path.emplace_back("availableRoadLinks[" + std::to_string(index) +
+                            "]");
+          if (!availableRoadLinksValue[index].IsInt())
+            throw JsonTypeError("availableRoadLink", "int");
+          size_t indexInRoadLinks = availableRoadLinksValue[index].GetUint();
+          if (indexInRoadLinks >= lightPhase.roadLinkAvailable.size())
+            throw JsonFormatError("index out of range");
+          lightPhase.roadLinkAvailable[indexInRoadLinks] = true;
+          path.pop_back();
         }
+        intersections[i].trafficLight.phases.push_back(lightPhase);
+        path.pop_back();
+      }
+      path.pop_back(); // End of traffic light
+      intersections[i].trafficLight.init(0);
 
-        for (auto &road : roads) {
-            auto &roadLanes = road.getLanePointers();
-            lanes.insert(lanes.end(), roadLanes.begin(), roadLanes.end());
-            drivables.insert(drivables.end(), roadLanes.begin(), roadLanes.end());
-        }
-        for (auto &intersection : intersections) {
-            auto &intersectionLaneLinks = intersection.getLaneLinks();
-            laneLinks.insert(laneLinks.end(), intersectionLaneLinks.begin(), intersectionLaneLinks.end());
-            drivables.insert(drivables.end(), intersectionLaneLinks.begin(), intersectionLaneLinks.end());
-        }
-        return true;
+      path.pop_back(); // End of intersection
     }
-
-    rapidjson::Value RoadNet::convertToJson(rapidjson::Document::AllocatorType &allocator) {
-        rapidjson::Value jsonRoot(rapidjson::kObjectType);
-        // write nodes
-        rapidjson::Value jsonNodes(rapidjson::kArrayType);
-        for (size_t i = 0; i < intersections.size(); ++i) {
-            rapidjson::Value jsonNode(rapidjson::kObjectType), jsonPoint(rapidjson::kArrayType);
-            rapidjson::Value idValue;
-            idValue.SetString(rapidjson::StringRef(intersections[i].id.c_str()));
-            jsonNode.AddMember("id", idValue, allocator);
-            jsonPoint.PushBack(intersections[i].point.x, allocator);
-            jsonPoint.PushBack(intersections[i].point.y, allocator);
-            jsonNode.AddMember("point", jsonPoint, allocator);
-            jsonNode.AddMember("virtual", intersections[i].isVirtual, allocator);
-            if (!intersections[i].isVirtual) {
-                jsonNode.AddMember("width", intersections[i].width, allocator);
-            }
-
-            rapidjson::Value jsonOutline(rapidjson::kArrayType);
-            for (auto &point: intersections[i].getOutline()) {
-                jsonOutline.PushBack(point.x, allocator);
-                jsonOutline.PushBack(point.y, allocator);
-            }
-            jsonNode.AddMember("outline", jsonOutline, allocator);
-            jsonNodes.PushBack(jsonNode, allocator);
-        }
-        jsonRoot.AddMember("nodes", jsonNodes, allocator);
-
-        //write edges
-        rapidjson::Value jsonEdges(rapidjson::kArrayType);
-        for (size_t i = 0; i < roads.size(); ++i) {
-            rapidjson::Value jsonEdge(rapidjson::kObjectType);
-            rapidjson::Value jsonPoints(rapidjson::kArrayType);
-            rapidjson::Value jsonLaneWidths(rapidjson::kArrayType);
-            rapidjson::Value jsonDirs(rapidjson::kArrayType);
-
-            rapidjson::Value idValue;
-            idValue.SetString(rapidjson::StringRef(roads[i].id.c_str()));
-            jsonEdge.AddMember("id", idValue, allocator);
-            rapidjson::Value startValue;
-            if (roads[i].startIntersection)
-                startValue.SetString(rapidjson::StringRef(roads[i].startIntersection->id.c_str()));
-            else
-                startValue.SetString("null");
-            jsonEdge.AddMember("from", startValue, allocator);
-
-            rapidjson::Value endValue;
-            if (roads[i].endIntersection)
-                endValue.SetString(rapidjson::StringRef(roads[i].endIntersection->id.c_str()));
-            else
-                endValue.SetString("null");
-            jsonEdge.AddMember("to", endValue, allocator);
-            for (size_t j = 0; j < roads[i].points.size(); ++j) {
-                rapidjson::Value jsonPoint(rapidjson::kArrayType);
-                jsonPoint.PushBack(roads[i].points[j].x, allocator);
-                jsonPoint.PushBack(roads[i].points[j].y, allocator);
-                jsonPoints.PushBack(jsonPoint, allocator);
-            }
-            jsonEdge.AddMember("points", jsonPoints, allocator);
-            jsonEdge.AddMember("nLane", static_cast<int>(roads[i].lanes.size()), allocator);
-            for (size_t j = 0; j < roads[i].lanes.size(); ++j) {
-                jsonLaneWidths.PushBack(roads[i].lanes[j].width, allocator);
-            }
-            jsonEdge.AddMember("laneWidths", jsonLaneWidths, allocator);
-            jsonEdges.PushBack(jsonEdge, allocator);
-        }
-        jsonRoot.AddMember("edges", jsonEdges, allocator);
-        return jsonRoot;
+    path.pop_back();
+    assert(path.empty());
+  } catch (const JsonFormatError &e) {
+    std::cerr << "Error occurred when reading the roadnet file: " << std::endl;
+    for (const auto &node : path) {
+      std::cerr << "/" << node;
     }
+    std::cerr << " " << e.what() << std::endl;
+    return false;
+  }
+
+  for (auto &intersection : intersections)
+    intersection.initCrosses();
+  VehicleInfo vehicleTemplate;
+
+  for (auto &road : roads)
+    road.initLanesPoints();
+
+  for (auto &road : roads) {
+    road.buildSegmentationByInterval(
+        (vehicleTemplate.len + vehicleTemplate.minGap) *
+        MAX_NUM_CARS_ON_SEGMENT);
+  }
+
+  for (auto &road : roads) {
+    auto &roadLanes = road.getLanePointers();
+    lanes.insert(lanes.end(), roadLanes.begin(), roadLanes.end());
+    drivables.insert(drivables.end(), roadLanes.begin(), roadLanes.end());
+  }
+  for (int i = 0, j = lanes.size(); i < j; ++i) {
+    lanes[i]->_index = i;
+  }
+  for (auto &intersection : intersections) {
+    auto &intersectionLaneLinks = intersection.getLaneLinks();
+    laneLinks.insert(laneLinks.end(), intersectionLaneLinks.begin(),
+                     intersectionLaneLinks.end());
+    drivables.insert(drivables.end(), intersectionLaneLinks.begin(),
+                     intersectionLaneLinks.end());
+  }
+  for (int i = 0, j = intersections.size(); i < j; ++i) {
+    intersections[i]._index = i;
+  }
+  return true;
+}
 
-    Point Drivable::getPointByDistance(double dis) const {
-        return CityFlow::getPointByDistance(points, dis);
+rapidjson::Value
+RoadNet::convertToJson(rapidjson::Document::AllocatorType &allocator) {
+  rapidjson::Value jsonRoot(rapidjson::kObjectType);
+  // write nodes
+  rapidjson::Value jsonNodes(rapidjson::kArrayType);
+  for (size_t i = 0; i < intersections.size(); ++i) {
+    rapidjson::Value jsonNode(rapidjson::kObjectType),
+        jsonPoint(rapidjson::kArrayType);
+    rapidjson::Value idValue;
+    idValue.SetString(rapidjson::StringRef(intersections[i].id.c_str()));
+    jsonNode.AddMember("id", idValue, allocator);
+    jsonPoint.PushBack(intersections[i].point.x, allocator);
+    jsonPoint.PushBack(intersections[i].point.y, allocator);
+    jsonNode.AddMember("point", jsonPoint, allocator);
+    jsonNode.AddMember("virtual", intersections[i].isVirtual, allocator);
+    if (!intersections[i].isVirtual) {
+      jsonNode.AddMember("width", intersections[i].width, allocator);
     }
 
-    Point Drivable::getDirectionByDistance(double dis) const {
-        double remain = dis;
-        for (int i = 0; i + 1 < (int) points.size(); i++) {
-            double len = (points[i + 1] - points[i]).len();
-            if (remain < len)
-                return (points[i + 1] - points[i]).unit();
-            else
-                remain -= len;
-        }
-        return (points[points.size() - 1] - points[points.size() - 2]).unit();
+    rapidjson::Value jsonOutline(rapidjson::kArrayType);
+    for (auto &point : intersections[i].getOutline()) {
+      jsonOutline.PushBack(point.x, allocator);
+      jsonOutline.PushBack(point.y, allocator);
     }
-
-    Lane::Lane() {
-        width = 0;
-        maxSpeed = 0;
-        laneIndex = -1;
-        belongRoad = 0;
-        drivableType = LANE;
+    jsonNode.AddMember("outline", jsonOutline, allocator);
+    jsonNodes.PushBack(jsonNode, allocator);
+  }
+  jsonRoot.AddMember("nodes", jsonNodes, allocator);
+
+  // write edges
+  rapidjson::Value jsonEdges(rapidjson::kArrayType);
+  for (size_t i = 0; i < roads.size(); ++i) {
+    rapidjson::Value jsonEdge(rapidjson::kObjectType);
+    rapidjson::Value jsonPoints(rapidjson::kArrayType);
+    rapidjson::Value jsonLaneWidths(rapidjson::kArrayType);
+    rapidjson::Value jsonDirs(rapidjson::kArrayType);
+
+    rapidjson::Value idValue;
+    idValue.SetString(rapidjson::StringRef(roads[i].id.c_str()));
+    jsonEdge.AddMember("id", idValue, allocator);
+    rapidjson::Value startValue;
+    if (roads[i].startIntersection)
+      startValue.SetString(
+          rapidjson::StringRef(roads[i].startIntersection->id.c_str()));
+    else
+      startValue.SetString("null");
+    jsonEdge.AddMember("from", startValue, allocator);
+
+    rapidjson::Value endValue;
+    if (roads[i].endIntersection)
+      endValue.SetString(
+          rapidjson::StringRef(roads[i].endIntersection->id.c_str()));
+    else
+      endValue.SetString("null");
+    jsonEdge.AddMember("to", endValue, allocator);
+    for (size_t j = 0; j < roads[i].points.size(); ++j) {
+      rapidjson::Value jsonPoint(rapidjson::kArrayType);
+      jsonPoint.PushBack(roads[i].points[j].x, allocator);
+      jsonPoint.PushBack(roads[i].points[j].y, allocator);
+      jsonPoints.PushBack(jsonPoint, allocator);
     }
-
-    Lane::Lane(double width, double maxSpeed, int laneIndex, Road *belongRoad) {
-        this->width = width;
-        this->maxSpeed = maxSpeed;
-        this->laneIndex = laneIndex;
-        this->belongRoad = belongRoad;
-        drivableType = LANE;
+    jsonEdge.AddMember("points", jsonPoints, allocator);
+    jsonEdge.AddMember("nLane", static_cast<int>(roads[i].lanes.size()),
+                       allocator);
+    for (size_t j = 0; j < roads[i].lanes.size(); ++j) {
+      jsonLaneWidths.PushBack(roads[i].lanes[j].width, allocator);
     }
+    jsonEdge.AddMember("laneWidths", jsonLaneWidths, allocator);
+    jsonEdges.PushBack(jsonEdge, allocator);
+  }
+  jsonRoot.AddMember("edges", jsonEdges, allocator);
+  return jsonRoot;
+}
 
-    bool Lane::available(const Vehicle *vehicle) const {
-        if (!vehicles.empty()) {
-            Vehicle *tail = vehicles.back();
-            return tail->getDistance() > tail->getLen() + vehicle->getMinGap();
-        } else {
-            return true;
-        }
-    }
+Point Drivable::getPointByDistance(double dis) const {
+  return CityFlow::getPointByDistance(points, dis);
+}
 
-    bool Lane::canEnter(const Vehicle *vehicle) const {
-        if (!vehicles.empty()) {
-            Vehicle *tail = vehicles.back();
-            return tail->getDistance() > tail->getLen() + vehicle->getLen() ||
-                   tail->getSpeed() >= 2; //todo: speed > 2 or?
-        } else {
-            return true;
-        }
-    }
+Point Drivable::getDirectionByDistance(double dis) const {
+  double remain = dis;
+  for (int i = 0; i + 1 < (int)points.size(); i++) {
+    double len = (points[i + 1] - points[i]).len();
+    if (remain < len)
+      return (points[i + 1] - points[i]).unit();
+    else
+      remain -= len;
+  }
+  return (points[points.size() - 1] - points[points.size() - 2]).unit();
+}
 
-    std::vector<LaneLink *> Lane::getLaneLinksToRoad(const Road *road) const {
-        std::vector<LaneLink *> ret;
-        for (auto &laneLink : laneLinks) {
-            if (laneLink->getEndLane()->getBelongRoad() == road)
-                ret.push_back(laneLink);
-        }
-        return ret;
-    }
+Lane::Lane() {
+  width = 0;
+  maxSpeed = 0;
+  laneIndex = -1;
+  belongRoad = 0;
+  drivableType = LANE;
+}
 
-    void Road::initLanesPoints() {
-        double dsum = 0.0;
-        std::vector<Point> roadPoints = this->points;
+Lane::Lane(double width, double maxSpeed, int laneIndex, Road *belongRoad) {
+  this->width = width;
+  this->maxSpeed = maxSpeed;
+  this->laneIndex = laneIndex;
+  this->belongRoad = belongRoad;
+  drivableType = LANE;
+}
 
-        assert(roadPoints.size() >= 2);
+bool Lane::available(const Vehicle *vehicle) const {
+  if (!vehicles.empty()) {
+    Vehicle *tail = vehicles.back();
+    return tail->getDistance() > tail->getLen() + vehicle->getMinGap();
+  } else {
+    return true;
+  }
+}
 
-        if (!startIntersection->isVirtualIntersection()) {
-            double width = startIntersection->width;
-            Point p1 = roadPoints[0];
-            Point p2 = roadPoints[1];
-            roadPoints[0] = p1 + (p2 - p1).unit() * width;
-        }
+bool Lane::canEnter(const Vehicle *vehicle) const {
+  if (!vehicles.empty()) {
+    Vehicle *tail = vehicles.back();
+    return tail->getDistance() > tail->getLen() + vehicle->getLen() ||
+           tail->getSpeed() >= 2; // todo: speed > 2 or?
+  } else {
+    return true;
+  }
+}
 
-        if (!endIntersection->isVirtualIntersection()) {
-            double width = endIntersection->width;
-            Point p1 = roadPoints[roadPoints.size() - 2];
-            Point p2 = roadPoints[roadPoints.size() - 1];
-            roadPoints[roadPoints.size() - 1] = p2 - (p2 - p1).unit() * width;
-        }
+std::vector<LaneLink *> Lane::getLaneLinksToRoad(const Road *road) const {
+  std::vector<LaneLink *> ret;
+  for (auto &laneLink : laneLinks) {
+    if (laneLink->getEndLane()->getBelongRoad() == road)
+      ret.push_back(laneLink);
+  }
+  return ret;
+}
 
-        for (Lane &lane : lanes) {
-            double dmin = dsum;
-            double dmax = dsum + lane.width;
-            lane.points.clear();
-            for (int j = 0; j < (int) roadPoints.size(); j++) {
-                // TODO: the '(dmin + dmax) / 2.0' is wrong
-                std::vector<Point> &lanePoints = lane.points;
-                if (j == 0) {
-                    Vector u = (roadPoints[1] - roadPoints[0]).unit();
-                    Vector v = -u.normal();
-                    Point startPoint = roadPoints[j] + v * ((dmin + dmax) / 2.0);
-                    lanePoints.push_back(startPoint);
-                } else if (j + 1 == (int) roadPoints.size()) {
-                    Vector u = (roadPoints[j] - roadPoints[j - 1]).unit();
-                    Vector v = -u.normal();
-                    Point endPoint = roadPoints[j] + v * ((dmin + dmax) / 2.0);
-                    lanePoints.push_back(endPoint);
-                } else {
-                    Vector u1 = (roadPoints[j + 1] - roadPoints[j]).unit();
-                    Vector u2 = (roadPoints[j] - roadPoints[j - 1]).unit();
-                    Vector u = (u1 + u2).unit();
-                    Vector v = -u.normal();
-                    Point interPoint = roadPoints[j] + v * ((dmin + dmax) / 2.0);
-                    lanePoints.push_back(interPoint);
-                }
-            }
-            lane.length = getLengthOfPoints(lane.points);
-            dsum += lane.width;
-        }
+void Road::initLanesPoints() {
+  double dsum = 0.0;
+  std::vector<Point> roadPoints = this->points;
+
+  assert(roadPoints.size() >= 2);
+
+  if (!startIntersection->isVirtualIntersection()) {
+    double width = startIntersection->width;
+    Point p1 = roadPoints[0];
+    Point p2 = roadPoints[1];
+    roadPoints[0] = p1 + (p2 - p1).unit() * width;
+  }
+
+  if (!endIntersection->isVirtualIntersection()) {
+    double width = endIntersection->width;
+    Point p1 = roadPoints[roadPoints.size() - 2];
+    Point p2 = roadPoints[roadPoints.size() - 1];
+    roadPoints[roadPoints.size() - 1] = p2 - (p2 - p1).unit() * width;
+  }
+
+  for (Lane &lane : lanes) {
+    double dmin = dsum;
+    double dmax = dsum + lane.width;
+    lane.points.clear();
+    for (int j = 0; j < (int)roadPoints.size(); j++) {
+      // TODO: the '(dmin + dmax) / 2.0' is wrong
+      std::vector<Point> &lanePoints = lane.points;
+      if (j == 0) {
+        Vector u = (roadPoints[1] - roadPoints[0]).unit();
+        Vector v = -u.normal();
+        Point startPoint = roadPoints[j] + v * ((dmin + dmax) / 2.0);
+        lanePoints.push_back(startPoint);
+      } else if (j + 1 == (int)roadPoints.size()) {
+        Vector u = (roadPoints[j] - roadPoints[j - 1]).unit();
+        Vector v = -u.normal();
+        Point endPoint = roadPoints[j] + v * ((dmin + dmax) / 2.0);
+        lanePoints.push_back(endPoint);
+      } else {
+        Vector u1 = (roadPoints[j + 1] - roadPoints[j]).unit();
+        Vector u2 = (roadPoints[j] - roadPoints[j - 1]).unit();
+        Vector u = (u1 + u2).unit();
+        Vector v = -u.normal();
+        Point interPoint = roadPoints[j] + v * ((dmin + dmax) / 2.0);
+        lanePoints.push_back(interPoint);
+      }
     }
+    lane.length = getLengthOfPoints(lane.points);
+    assert(!std::isnan(lane.length));
+    dsum += lane.width;
+  }
+}
 
-    const std::vector<Lane *> &Road::getLanePointers() {
-        if (lanePointers.size()) return lanePointers;
-        for (auto &lane : lanes) {
-            lanePointers.push_back(&lane);
-        }
-        return lanePointers;
-    }
+const std::vector<Lane *> &Road::getLanePointers() {
+  if (lanePointers.size())
+    return lanePointers;
+  for (auto &lane : lanes) {
+    lanePointers.push_back(&lane);
+  }
+  return lanePointers;
+}
 
-    void Intersection::initCrosses() {
-        std::vector<LaneLink *> allLaneLinks;
-        for (auto &roadLink : roadLinks) {
-            for (auto &laneLink : roadLink.getLaneLinks())
-                allLaneLinks.push_back(&laneLink);
-        }
-        int n = (int) allLaneLinks.size();
-
-        for (int i = 0; i < n; i++) {
-            for (int j = i + 1; j < n; j++) {
-                LaneLink *la = allLaneLinks[i];
-                LaneLink *lb = allLaneLinks[j];
-                std::vector<Point> &va = la->points;
-                std::vector<Point> &vb = lb->points;
-                double disa = 0.0;
-                for (int ia = 0; ia + 1 < (int) va.size(); ia++) {
-                    double disb = 0.0;
-                    for (int ib = 0; ib + 1 < (int) vb.size(); ib++) {
-                        Point A1 = va[ia], A2 = va[ia + 1];
-                        Point B1 = vb[ib], B2 = vb[ib + 1];
-                        if (Point::sign(crossMultiply(A2 - A1, B2 - B1)) == 0) continue;
-                        Point P = calcIntersectPoint(A1, A2, B1, B2);
-                        if (onSegment(A1, A2, P) && onSegment(B1, B2, P)) {
-                            Cross cross;
-                            cross.laneLinks[0] = la;
-                            cross.laneLinks[1] = lb;
-                            cross.notifyVehicles[0] = nullptr;
-                            cross.notifyVehicles[1] = nullptr;
-                            cross.distanceOnLane[0] = disa + (P - A1).len();
-                            cross.distanceOnLane[1] = disb + (P - B1).len();
-                            cross.ang = calcAng(A2 - A1, B2 - B1);
-                            //assert(cross.ang > 0 && cross.ang < M_PI / 2); // assert cannot pass why?
-                            double w1 = la->getWidth();
-                            double w2 = lb->getWidth();
-                            double c1 = w1 / sin(cross.ang);
-                            double c2 = w2 / sin(cross.ang);
-                            double diag = (c1 * c1 + c2 * c2 + 2 * c1 * c2 * cos(cross.ang)) / 4;
-                            cross.safeDistances[0] = sqrt(diag - w2 * w2 / 4);
-                            cross.safeDistances[1] = sqrt(diag - w1 * w1 / 4);
-                            this->crosses.push_back(cross);
-                            goto FOUND;
-                        }
-                        disb += (vb[ib + 1] - vb[ib]).len();
-                    }
-                    disa += (va[ia + 1] - va[ia]).len();
-                }
-FOUND:;
-            }
-        }
-        for (Cross &cross : this->crosses) {
-            cross.laneLinks[0]->getCrosses().push_back(&cross);
-            cross.laneLinks[1]->getCrosses().push_back(&cross);
-        }
-        for (auto laneLink : allLaneLinks) {
-            std::vector<Cross *> &crosses = laneLink->getCrosses();
-            sort(crosses.begin(), crosses.end(), [laneLink](Cross *ca, Cross *cb) -> bool {
-                double da = ca->distanceOnLane[ca->laneLinks[0] != laneLink];
-                double db = cb->distanceOnLane[cb->laneLinks[0] != laneLink];
-                return da < db;
-            });
+void Intersection::initCrosses() {
+  std::vector<LaneLink *> allLaneLinks;
+  for (auto &roadLink : roadLinks) {
+    for (auto &laneLink : roadLink.getLaneLinks())
+      allLaneLinks.push_back(&laneLink);
+  }
+  int n = (int)allLaneLinks.size();
+
+  for (int i = 0; i < n; i++) {
+    for (int j = i + 1; j < n; j++) {
+      LaneLink *la = allLaneLinks[i];
+      LaneLink *lb = allLaneLinks[j];
+      std::vector<Point> &va = la->points;
+      std::vector<Point> &vb = lb->points;
+      double disa = 0.0;
+      for (int ia = 0; ia + 1 < (int)va.size(); ia++) {
+        double disb = 0.0;
+        for (int ib = 0; ib + 1 < (int)vb.size(); ib++) {
+          Point A1 = va[ia], A2 = va[ia + 1];
+          Point B1 = vb[ib], B2 = vb[ib + 1];
+          if (Point::sign(crossMultiply(A2 - A1, B2 - B1)) == 0)
+            continue;
+          Point P = calcIntersectPoint(A1, A2, B1, B2);
+          if (onSegment(A1, A2, P) && onSegment(B1, B2, P)) {
+            Cross cross;
+            cross.laneLinks[0] = la;
+            cross.laneLinks[1] = lb;
+            cross.notifyVehicles[0] = nullptr;
+            cross.notifyVehicles[1] = nullptr;
+            cross.distanceOnLane[0] = disa + (P - A1).len();
+            cross.distanceOnLane[1] = disb + (P - B1).len();
+            cross.ang = calcAng(A2 - A1, B2 - B1);
+            // assert(cross.ang > 0 && cross.ang < M_PI / 2); // assert cannot
+            // pass why?
+            double w1 = la->getWidth();
+            double w2 = lb->getWidth();
+            double c1 = w1 / sin(cross.ang);
+            double c2 = w2 / sin(cross.ang);
+            double diag =
+                (c1 * c1 + c2 * c2 + 2 * c1 * c2 * cos(cross.ang)) / 4;
+            cross.safeDistances[0] = sqrt(diag - w2 * w2 / 4);
+            cross.safeDistances[1] = sqrt(diag - w1 * w1 / 4);
+            this->crosses.push_back(cross);
+            goto FOUND;
+          }
+          disb += (vb[ib + 1] - vb[ib]).len();
         }
+        disa += (va[ia + 1] - va[ia]).len();
+      }
+    FOUND:;
     }
+  }
+  for (Cross &cross : this->crosses) {
+    cross.laneLinks[0]->getCrosses().push_back(&cross);
+    cross.laneLinks[1]->getCrosses().push_back(&cross);
+  }
+  for (auto laneLink : allLaneLinks) {
+    std::vector<Cross *> &crosses = laneLink->getCrosses();
+    sort(crosses.begin(), crosses.end(),
+         [laneLink](Cross *ca, Cross *cb) -> bool {
+           double da = ca->distanceOnLane[ca->laneLinks[0] != laneLink];
+           double db = cb->distanceOnLane[cb->laneLinks[0] != laneLink];
+           return da < db;
+         });
+  }
+}
 
-    const std::vector<LaneLink *> &Intersection::getLaneLinks() {
-        if (laneLinks.size() > 0) return laneLinks;
-        for (auto &roadLink : roadLinks) {
-            auto &roadLaneLinks = roadLink.getLaneLinkPointers();
-            laneLinks.insert(laneLinks.end(), roadLaneLinks.begin(), roadLaneLinks.end());
-        }
-        return laneLinks;
-    }
+const std::vector<LaneLink *> &Intersection::getLaneLinks() {
+  if (laneLinks.size() > 0)
+    return laneLinks;
+  for (auto &roadLink : roadLinks) {
+    auto &roadLaneLinks = roadLink.getLaneLinkPointers();
+    laneLinks.insert(laneLinks.end(), roadLaneLinks.begin(),
+                     roadLaneLinks.end());
+  }
+  return laneLinks;
+}
 
-    const std::vector<LaneLink *> &RoadLink::getLaneLinkPointers() {
-        if (laneLinkPointers.size() > 0) return laneLinkPointers;
-        for (auto &laneLink : laneLinks) {
-            laneLinkPointers.push_back(&laneLink);
-        }
-        return laneLinkPointers;
-    }
+const std::vector<LaneLink *> &RoadLink::getLaneLinkPointers() {
+  if (laneLinkPointers.size() > 0)
+    return laneLinkPointers;
+  for (auto &laneLink : laneLinks) {
+    laneLinkPointers.push_back(&laneLink);
+  }
+  return laneLinkPointers;
+}
 
-    void Cross::notify(LaneLink *laneLink, Vehicle *vehicle, double notifyDistance) {
-        assert(laneLink == laneLinks[0] || laneLink == laneLinks[1]);
-        int i = (laneLink == laneLinks[0]) ? 0 : 1;
-        assert(notifyVehicles[i] == nullptr);
-        notifyVehicles[i] = vehicle;
-        notifyDistances[i] = notifyDistance;
-    }
+void Cross::notify(LaneLink *laneLink, Vehicle *vehicle,
+                   double notifyDistance) {
+  assert(laneLink == laneLinks[0] || laneLink == laneLinks[1]);
+  int i = (laneLink == laneLinks[0]) ? 0 : 1;
+  assert(notifyVehicles[i] == nullptr);
+  notifyVehicles[i] = vehicle;
+  notifyDistances[i] = notifyDistance;
+}
 
-    bool Cross::canPass(const Vehicle *vehicle, const LaneLink *laneLink, double distanceToLaneLinkStart) const {
-        // TODO: should be improved
-        assert(laneLink == laneLinks[0] || laneLink == laneLinks[1]);
-        int i = (laneLink == laneLinks[0]) ? 0 : 1;
-
-        Vehicle *foeVehicle = notifyVehicles[1 - i];
-        RoadLinkType t1 = laneLinks[i]->getRoadLinkType();
-        RoadLinkType t2 = laneLinks[1 - i]->getRoadLinkType();
-        double d1 = distanceOnLane[i] - distanceToLaneLinkStart, d2 = notifyDistances[1 - i];
-
-        if (foeVehicle == nullptr) return true;
-
-        if (!vehicle->canYield(d1)) return true;
-
-        int yield = 0;
-        if (!foeVehicle->canYield(d2)) yield = 1;
-
-        if (yield == 0) {
-            if (t1 > t2) {
-                yield = -1;
-            } else if (t1 < t2) {
-                if (d2 > 0) {
-                    // todo: can be improved, check if higher priority vehicle is blocked by other vehicles, hard!
-                    int foeVehicleReachSteps = foeVehicle->getReachStepsOnLaneLink(d2, laneLinks[1 - i]);
-                    int reachSteps = vehicle->getReachStepsOnLaneLink(d1, laneLinks[i]);
-                    if (foeVehicleReachSteps > reachSteps) {
-                        yield = -1;
-                    }
-                } else {
-                    if (d2 + foeVehicle->getLen() < 0) {
-                        yield = -1;
-                    }
-                }
-                if (yield == 0) yield = 1;
-            } else {
-                if (d2 > 0) {
-                    int foeVehicleReachSteps = foeVehicle->getReachStepsOnLaneLink(d2, laneLinks[1 - i]);
-                    int reachSteps = vehicle->getReachStepsOnLaneLink(d1, laneLinks[i]);
-                    if (foeVehicleReachSteps > reachSteps) {
-                        yield = -1;
-                    } else if (foeVehicleReachSteps < reachSteps) {
-                        yield = 1;
-                    } else {
-                        if (vehicle->getEnterLaneLinkTime() == foeVehicle->getEnterLaneLinkTime()) {
-                            if (d1 == d2) {
-                                yield = vehicle->getPriority() > foeVehicle->getPriority() ? -1 : 1;
-                            } else {
-                                yield = d1 < d2 ? -1 : 1;
-                            }
-                        } else {
-                            yield = vehicle->getEnterLaneLinkTime() < foeVehicle->getEnterLaneLinkTime() ? -1 : 1;
-                        }
-                    }
-                } else {
-                    yield = d2 + foeVehicle->getLen() < 0 ? -1 : 1;
-                }
-            }
+bool Cross::canPass(const Vehicle *vehicle, const LaneLink *laneLink,
+                    double distanceToLaneLinkStart) const {
+  // TODO: should be improved
+  assert(laneLink == laneLinks[0] || laneLink == laneLinks[1]);
+  int i = (laneLink == laneLinks[0]) ? 0 : 1;
+
+  Vehicle *foeVehicle = notifyVehicles[1 - i];
+  RoadLinkType t1 = laneLinks[i]->getRoadLinkType();
+  RoadLinkType t2 = laneLinks[1 - i]->getRoadLinkType();
+  double d1 = distanceOnLane[i] - distanceToLaneLinkStart,
+         d2 = notifyDistances[1 - i];
+
+  if (foeVehicle == nullptr)
+    return true;
+
+  if (!vehicle->canYield(d1))
+    return true;
+
+  int yield = 0;
+  if (!foeVehicle->canYield(d2))
+    yield = 1;
+
+  if (yield == 0) {
+    if (t1 > t2) {
+      yield = -1;
+    } else if (t1 < t2) {
+      if (d2 > 0) {
+        // todo: can be improved, check if higher priority vehicle is blocked by
+        // other vehicles, hard!
+        int foeVehicleReachSteps =
+            foeVehicle->getReachStepsOnLaneLink(d2, laneLinks[1 - i]);
+        int reachSteps = vehicle->getReachStepsOnLaneLink(d1, laneLinks[i]);
+        if (foeVehicleReachSteps > reachSteps) {
+          yield = -1;
+        }
+      } else {
+        if (d2 + foeVehicle->getLen() < 0) {
+          yield = -1;
         }
-        assert(yield != 0);
-        if (yield == 1) {
-            Vehicle *fastPointer = foeVehicle;
-            Vehicle *slowPointer = foeVehicle;
-            while (fastPointer != nullptr && fastPointer->getBlocker() != nullptr) {
-                slowPointer = slowPointer->getBlocker();
-                fastPointer = fastPointer->getBlocker()->getBlocker();
-                if (slowPointer == fastPointer) {
-                    // deadlock detected
-                    yield = -1;
-                    break;
-                }
+      }
+      if (yield == 0)
+        yield = 1;
+    } else {
+      if (d2 > 0) {
+        int foeVehicleReachSteps =
+            foeVehicle->getReachStepsOnLaneLink(d2, laneLinks[1 - i]);
+        int reachSteps = vehicle->getReachStepsOnLaneLink(d1, laneLinks[i]);
+        if (foeVehicleReachSteps > reachSteps) {
+          yield = -1;
+        } else if (foeVehicleReachSteps < reachSteps) {
+          yield = 1;
+        } else {
+          if (vehicle->getEnterLaneLinkTime() ==
+              foeVehicle->getEnterLaneLinkTime()) {
+            if (d1 == d2) {
+              yield =
+                  vehicle->getPriority() > foeVehicle->getPriority() ? -1 : 1;
+            } else {
+              yield = d1 < d2 ? -1 : 1;
             }
+          } else {
+            yield = vehicle->getEnterLaneLinkTime() <
+                            foeVehicle->getEnterLaneLinkTime()
+                        ? -1
+                        : 1;
+          }
         }
-        return yield == -1;
+      } else {
+        yield = d2 + foeVehicle->getLen() < 0 ? -1 : 1;
+      }
     }
-
-    void RoadNet::reset() {
-        for (auto &road : roads) road.reset();
-        for (auto &intersection : intersections) intersection.reset();
+  }
+  assert(yield != 0);
+  if (yield == 1) {
+    Vehicle *fastPointer = foeVehicle;
+    Vehicle *slowPointer = foeVehicle;
+    while (fastPointer != nullptr && fastPointer->getBlocker() != nullptr) {
+      slowPointer = slowPointer->getBlocker();
+      fastPointer = fastPointer->getBlocker()->getBlocker();
+      if (slowPointer == fastPointer) {
+        // deadlock detected
+        yield = -1;
+        break;
+      }
     }
+  }
+  return yield == -1;
+}
 
-    void Road::reset() {
-        for (auto &lane : lanes) lane.reset();
-    }
+void RoadNet::reset() {
+  for (auto &road : roads)
+    road.reset();
+  for (auto &intersection : intersections)
+    intersection.reset();
+}
 
-    void Road::buildSegmentationByInterval(double interval) {
-        size_t numSegs = std::max((size_t) ceil(getLengthOfPoints(this->points) / interval), (size_t) 1);
-        for (Lane &lane : lanes)
-            lane.buildSegmentation(numSegs);
-    }
+void Road::reset() {
+  for (auto &lane : lanes)
+    lane.reset();
+}
 
-    double Road::getWidth() const{
-        double width = 0;
-        for (const auto &lane : getLanes()){
-            width += lane.getWidth();
-        }
-        return width;
-    }
+void Road::buildSegmentationByInterval(double interval) {
+  size_t numSegs = std::max(
+      (size_t)ceil(getLengthOfPoints(this->points) / interval), (size_t)1);
+  for (Lane &lane : lanes)
+    lane.buildSegmentation(numSegs);
+}
 
-    double Road::getLength() const{
-        double length = 0;
-        for (const auto &lane : getLanes()){
-            length += lane.getLength();
-        }
-        return length;
-    }
+double Road::getWidth() const {
+  double width = 0;
+  for (const auto &lane : getLanes()) {
+    width += lane.getWidth();
+  }
+  return width;
+}
 
-    double Road::averageLength() const{
-        double sum = 0;
-        size_t laneNum = getLanes().size();
-        if (laneNum == 0) return 0;
-        for (const auto &lane : getLanes()){
-            sum += lane.getLength();
-        }
-        return sum / laneNum;
-    }
+double Road::getLength() const {
+  double length = 0;
+  for (const auto &lane : getLanes()) {
+    length += lane.getLength();
+  }
+  return length;
+}
 
-    double Road::getAverageSpeed() const{
-        int vehicleNum = 0;
-        double speedSum = 0;
-        for (const auto &lane : lanes) {
-            vehicleNum += lane.getHistoryVehicleNum();
-            speedSum += lane.getHistoryAverageSpeed() * lane.getHistoryVehicleNum();
-        }
-        return vehicleNum ? speedSum / vehicleNum : -1;
-        // If no vehicles in history, return -1
-    }
+double Road::averageLength() const {
+  double sum = 0;
+  size_t laneNum = getLanes().size();
+  if (laneNum == 0)
+    return 0;
+  for (const auto &lane : getLanes()) {
+    sum += lane.getLength();
+  }
+  return sum / laneNum;
+}
 
-    double Road::getAverageDuration() const{
-        double averageSpeed = getAverageSpeed();
-        if (averageSpeed < 0) return -1;
-        return averageLength() / averageSpeed;
-    }
+double Road::getAverageSpeed() const {
+  int vehicleNum = 0;
+  double speedSum = 0;
+  for (const auto &lane : lanes) {
+    vehicleNum += lane.getHistoryVehicleNum();
+    speedSum += lane.getHistoryAverageSpeed() * lane.getHistoryVehicleNum();
+  }
+  return vehicleNum ? speedSum / vehicleNum : -1;
+  // If no vehicles in history, return -1
+}
 
-    bool Road::connectedToRoad(const Road *road) const{
-        for (const auto &lane : getLanes()) {
-            if (lane.getLaneLinksToRoad(road).size())
-                return true;
-        }
-        return false;
-    }
+double Road::getAverageDuration() const {
+  double averageSpeed = getAverageSpeed();
+  if (averageSpeed < 0)
+    return -1;
+  return averageLength() / averageSpeed;
+}
 
-    void Intersection::reset() {
-        trafficLight.reset();
-        for (auto &roadLink : roadLinks) roadLink.reset();
-        for (auto &cross : crosses) cross.reset();
+bool Road::connectedToRoad(const Road *road) const {
+  for (const auto &lane : getLanes()) {
+    if (lane.getLaneLinksToRoad(road).size())
+      return true;
+  }
+  return false;
+}
+
+void Intersection::reset() {
+  trafficLight.reset();
+  for (auto &roadLink : roadLinks)
+    roadLink.reset();
+  for (auto &cross : crosses)
+    cross.reset();
+}
+
+std::vector<Point> Intersection::getOutline() {
+  // Calculate the convex hull as the outline of the intersection
+  std::vector<Point> points;
+  points.push_back(getPosition());
+  for (auto road : getRoads()) {
+    Vector roadDirect = road->getEndIntersection().getPosition() -
+                        road->getStartIntersection().getPosition();
+    roadDirect = roadDirect.unit();
+    Vector pDirect = roadDirect.normal();
+    if (&road->getStartIntersection() == this) {
+      roadDirect = -roadDirect;
     }
+    /*                          <deltaWidth>
+     *                   [pointB *]------[pointB1 *]--------
+     *                       |
+     *                       v
+     *                   [pDirect] <- roadDirect <- Road
+     *                       |
+     *                       v
+     * [intersection]----[pointA *]------[pointA1 *]--------
+     */
+    double roadWidth = road->getWidth();
+    double deltaWidth = 0.5 * min2double(width, roadWidth);
+    deltaWidth = max2double(deltaWidth, 5);
+
+    Point pointA = getPosition() - roadDirect * width;
+    Point pointB = pointA - pDirect * roadWidth;
+    points.push_back(pointA);
+    points.push_back(pointB);
+
+    if (deltaWidth < road->averageLength()) {
+      Point pointA1 = pointA - roadDirect * deltaWidth;
+      Point pointB1 = pointB - roadDirect * deltaWidth;
+      points.push_back(pointA1);
+      points.push_back(pointB1);
+    }
+  }
 
-    std::vector<Point> Intersection::getOutline() {
-        // Calculate the convex hull as the outline of the intersection
-        std::vector<Point> points;
-        points.push_back(getPosition());
-        for (auto road : getRoads()){
-            Vector roadDirect = road->getEndIntersection().getPosition() - road->getStartIntersection().getPosition();
-            roadDirect = roadDirect.unit();
-            Vector pDirect = roadDirect.normal();
-            if (&road->getStartIntersection() == this) {
-                roadDirect = -roadDirect;
-            }
-            /*                          <deltaWidth>
-             *                   [pointB *]------[pointB1 *]--------
-             *                       |
-             *                       v
-             *                   [pDirect] <- roadDirect <- Road
-             *                       |
-             *                       v
-             * [intersection]----[pointA *]------[pointA1 *]--------
-             */
-            double roadWidth = road->getWidth();
-            double deltaWidth = 0.5 * min2double(width, roadWidth);
-            deltaWidth = max2double(deltaWidth, 5);
-
-            Point pointA = getPosition() -  roadDirect * width;
-            Point pointB  = pointA - pDirect * roadWidth;
-            points.push_back(pointA);
-            points.push_back(pointB);
-
-            if (deltaWidth < road->averageLength()) {
-                Point pointA1 = pointA - roadDirect * deltaWidth;
-                Point pointB1 = pointB - roadDirect * deltaWidth;
-                points.push_back(pointA1);
-                points.push_back(pointB1);
-            }
-        }
+  auto minIter = std::min_element(
+      points.begin(), points.end(),
+      [](const Point &a, const Point &b) { return a.y < b.y; });
 
-        auto minIter = std::min_element(points.begin(), points.end(),
-                [](const Point &a, const Point &b){ return a.y < b.y; });
-
-        Point p0 = *minIter;
-        std::vector<Point> stack;
-        stack.push_back(p0);
-        points.erase(minIter);
-
-        std::sort(points.begin(), points.end(),
-                [&p0](const Point &a, const Point &b)
-                {return (a - p0).ang() < (b - p0).ang(); });
-
-        for (size_t i = 0 ; i < points.size(); ++i) {
-            Point &point = points[i];
-            Point p2 = stack[stack.size() - 1];
-            if (stack.size() < 2) {
-                if (point.x != p2.x || point.y != p2.y)
-                    stack.emplace_back(point);
-                continue;
-            }
-            Point p1 = stack[stack.size() - 2];
+  Point p0 = *minIter;
+  std::vector<Point> stack;
+  stack.push_back(p0);
+  points.erase(minIter);
 
-            while (stack.size() > 1 && crossMultiply(point - p2, p2 - p1) >= 0) {
-                p2 = p1;
-                stack.pop_back();
-                if (stack.size() > 1) p1 = stack[stack.size() - 2];
-            }
-            stack.emplace_back(point);
-        }
+  std::sort(points.begin(), points.end(),
+            [&p0](const Point &a, const Point &b) {
+              return (a - p0).ang() < (b - p0).ang();
+            });
 
-        return stack;
+  for (size_t i = 0; i < points.size(); ++i) {
+    Point &point = points[i];
+    Point p2 = stack[stack.size() - 1];
+    if (stack.size() < 2) {
+      if (point.x != p2.x || point.y != p2.y)
+        stack.emplace_back(point);
+      continue;
     }
+    Point p1 = stack[stack.size() - 2];
 
-    bool Intersection::isImplicitIntersection() {
-        return trafficLight.getPhases().size() <= 1;
+    while (stack.size() > 1 && crossMultiply(point - p2, p2 - p1) >= 0) {
+      p2 = p1;
+      stack.pop_back();
+      if (stack.size() > 1)
+        p1 = stack[stack.size() - 2];
     }
+    stack.emplace_back(point);
+  }
 
-    void RoadLink::reset() {
-        for (auto &laneLink : laneLinks) laneLink.reset();
-    }
+  return stack;
+}
 
-    void LaneLink::reset() {
-        vehicles.clear();
-    }
+bool Intersection::isImplicitIntersection() {
+  return trafficLight.getPhases().size() <= 1;
+}
 
-    void Lane::reset() {
-        waitingBuffer.clear();
-        vehicles.clear();
-    }
+std::pair<std::vector<int>, std::vector<int>>
+Intersection::get_inout_lanes() const {
+  std::vector<int> in, out;
+  for (auto *l : laneLinks) {
+    in.push_back(l->startLane->_index);
+    out.push_back(l->endLane->_index);
+  }
+  return {std::move(remove_duplicate(in)), std::move(remove_duplicate(out))};
+}
 
-    std::vector<Vehicle *> Lane::getVehiclesBeforeDistance(double dis, size_t segmentIndex, double deltaDis) {
-        std::vector<Vehicle *> ret;
-        for (int i = segmentIndex; i >=0 ;i--) {
-            Segment * segment = getSegment(i);
-            auto &vehicles = segment->getVehicles();
-            for(auto it = vehicles.begin(); it != vehicles.end(); ++it) {
-                Vehicle *vehicle = *(*it);
-                if (vehicle->getDistance() < dis - deltaDis) return ret;
-                if (vehicle->getDistance() < dis) ret.emplace_back(vehicle);
-            }
+std::vector<std::pair<std::vector<int>, std::vector<int>>>
+Intersection::get_phase_lanes() const {
+  std::vector<std::pair<std::vector<int>, std::vector<int>>> outs;
+  for (auto &p : trafficLight.getPhases()) {
+    std::vector<int> in, out;
+    for (int i = 0, j = p.roadLinkAvailable.size(); i < j; ++i) {
+      if (p.roadLinkAvailable[i]) {
+        for (auto &l : roadLinks[i].getLaneLinks()) {
+          in.push_back(l.startLane->_index);
+          out.push_back(l.endLane->_index);
         }
-        return ret;
+      }
     }
+    outs.emplace_back(std::move(remove_duplicate(in)),
+                      std::move(remove_duplicate(out)));
+  }
+  return outs;
+}
 
+void RoadLink::reset() {
+  for (auto &laneLink : laneLinks)
+    laneLink.reset();
+}
 
-    void Lane::buildSegmentation(size_t numSegs) {
-        this->segments.resize((unsigned) numSegs);
-        for (size_t i = 0; i < numSegs; i++) {
-            segments[i].index = i;
-            segments[i].vehicles.clear();
-            segments[i].belongLane = this;
-            segments[i].startPos = i * this->length / numSegs;
-            segments[i].endPos = (i + 1) * this->length / numSegs;
-        }
-    }
+void LaneLink::reset() { vehicles.clear(); }
 
-    void Lane::initSegments() {
-        auto iter = this->vehicles.begin();
-        auto end = this->vehicles.end();
-        for (int i = (int) segments.size() - 1; i >= 0; i--) {
-            Segment &seg = segments[i];
-            seg.vehicles.clear();
-            while (iter != end && (*iter)->getDistance() >= seg.getStartPos()) {
-                seg.vehicles.push_back(iter);
-                (*iter)->setSegmentIndex(seg.index);
-                ++iter;
-            }
-        }
+void Lane::reset() {
+  waitingBuffer.clear();
+  vehicles.clear();
+}
+
+std::vector<Vehicle *> Lane::getVehiclesBeforeDistance(double dis,
+                                                       size_t segmentIndex,
+                                                       double deltaDis) {
+  std::vector<Vehicle *> ret;
+  for (int i = segmentIndex; i >= 0; i--) {
+    Segment *segment = getSegment(i);
+    auto &vehicles = segment->getVehicles();
+    for (auto it = vehicles.begin(); it != vehicles.end(); ++it) {
+      Vehicle *vehicle = *(*it);
+      if (vehicle->getDistance() < dis - deltaDis)
+        return ret;
+      if (vehicle->getDistance() < dis)
+        ret.emplace_back(vehicle);
     }
+  }
+  return ret;
+}
 
-    Vehicle *Lane::getVehicleBeforeDistance(double dis, size_t segmentIndex) const{
-        for (int i = segmentIndex ; i >= 0 ; --i){
-            auto vehs = getSegment(i)->getVehicles();
-            for (auto itr = vehs.begin() ; itr != vehs.end(); ++itr){
-                auto &vehicle = **itr;
-                if (vehicle->getDistance() < dis) return **itr;
-            }
-        }
+void Lane::buildSegmentation(size_t numSegs) {
+  this->segments.resize((unsigned)numSegs);
+  for (size_t i = 0; i < numSegs; i++) {
+    segments[i].index = i;
+    segments[i].vehicles.clear();
+    segments[i].belongLane = this;
+    segments[i].startPos = i * this->length / numSegs;
+    segments[i].endPos = (i + 1) * this->length / numSegs;
+  }
+}
 
-        return nullptr;
+void Lane::initSegments() {
+  auto iter = this->vehicles.begin();
+  auto end = this->vehicles.end();
+  for (int i = (int)segments.size() - 1; i >= 0; i--) {
+    Segment &seg = segments[i];
+    seg.vehicles.clear();
+    while (iter != end && (*iter)->getDistance() >= seg.getStartPos()) {
+      seg.vehicles.push_back(iter);
+      (*iter)->setSegmentIndex(seg.index);
+      ++iter;
     }
+  }
+}
 
-    Vehicle *Lane::getVehicleAfterDistance(double dis, size_t segmentIndex) const{
-        for (size_t i = segmentIndex ; i < getSegmentNum() ; ++i){
-            auto vehs = getSegment(i)->getVehicles();
-            for (auto itr = vehs.rbegin() ; itr != vehs.rend(); ++itr){
-                auto &vehicle = **itr;
-                if (vehicle->getDistance() >= dis) return **itr;
-            }
-        }
-        return nullptr;
+Vehicle *Lane::getVehicleBeforeDistance(double dis, size_t segmentIndex) const {
+  for (int i = segmentIndex; i >= 0; --i) {
+    auto vehs = getSegment(i)->getVehicles();
+    for (auto itr = vehs.begin(); itr != vehs.end(); ++itr) {
+      auto &vehicle = **itr;
+      if (vehicle->getDistance() < dis)
+        return **itr;
     }
+  }
 
-    void Lane::updateHistory() {
-        double speedSum = historyVehicleNum * historyAverageSpeed;
-        while (history.size() > historyLen){
-            historyVehicleNum -= history.front().vehicleNum;
-            speedSum -= history.front().vehicleNum * history.front().averageSpeed;
-            history.pop_front();
-        }
-        double curSpeedSum = 0;
-        int vehicleNum = getVehicles().size();
-        historyVehicleNum += vehicleNum;
-        for (auto vehicle : getVehicles())
-            curSpeedSum += vehicle->getSpeed();
-        speedSum += curSpeedSum;
-        history.emplace_back(vehicleNum, vehicleNum ? curSpeedSum / vehicleNum : 0);
-        historyAverageSpeed = historyVehicleNum ? speedSum / historyVehicleNum : 0;
-    }
+  return nullptr;
+}
 
-    int Lane::getHistoryVehicleNum() const{
-        return historyVehicleNum;
+Vehicle *Lane::getVehicleAfterDistance(double dis, size_t segmentIndex) const {
+  for (size_t i = segmentIndex; i < getSegmentNum(); ++i) {
+    auto vehs = getSegment(i)->getVehicles();
+    for (auto itr = vehs.rbegin(); itr != vehs.rend(); ++itr) {
+      auto &vehicle = **itr;
+      if (vehicle->getDistance() >= dis)
+        return **itr;
     }
+  }
+  return nullptr;
+}
 
-    double Lane::getHistoryAverageSpeed() const{
-        return historyAverageSpeed;
-    }
+void Lane::updateHistory() {
+  double speedSum = historyVehicleNum * historyAverageSpeed;
+  while (history.size() > historyLen) {
+    historyVehicleNum -= history.front().vehicleNum;
+    speedSum -= history.front().vehicleNum * history.front().averageSpeed;
+    history.pop_front();
+  }
+  double curSpeedSum = 0;
+  int vehicleNum = getVehicles().size();
+  historyVehicleNum += vehicleNum;
+  for (auto vehicle : getVehicles())
+    curSpeedSum += vehicle->getSpeed();
+  speedSum += curSpeedSum;
+  history.emplace_back(vehicleNum, vehicleNum ? curSpeedSum / vehicleNum : 0);
+  historyAverageSpeed = historyVehicleNum ? speedSum / historyVehicleNum : 0;
+}
 
-    void Cross::reset() { }
+int Lane::getHistoryVehicleNum() const { return historyVehicleNum; }
 
-    std::list<Vehicle *>::iterator Segment::findVehicle(Vehicle *vehicle) {
-        for (auto itr = vehicles.begin() ; itr != vehicles.end() ; ++itr)
-            if (**itr == vehicle) {
-                return *itr;
-            }
-        return belongLane->getVehicles().end();
-    }
+double Lane::getHistoryAverageSpeed() const { return historyAverageSpeed; }
 
-    void Segment::removeVehicle(Vehicle *vehicle) {
-        for (auto itr = vehicles.begin() ; itr != vehicles.end() ; ++itr)
-            if (**itr == vehicle) {
-                vehicles.erase(itr);
-                return;
-            }
+void Cross::reset() {}
+
+std::list<Vehicle *>::iterator Segment::findVehicle(Vehicle *vehicle) {
+  for (auto itr = vehicles.begin(); itr != vehicles.end(); ++itr)
+    if (**itr == vehicle) {
+      return *itr;
     }
+  return belongLane->getVehicles().end();
+}
 
-    void Segment::insertVehicle(std::list<Vehicle *>::iterator &vehicle) {
-        auto itr = vehicles.begin();
-        for (; itr != vehicles.end() && (**itr)->getDistance() > (*vehicle)->getDistance() ; ++itr);
-        vehicles.insert(itr, vehicle);
+void Segment::removeVehicle(Vehicle *vehicle) {
+  for (auto itr = vehicles.begin(); itr != vehicles.end(); ++itr)
+    if (**itr == vehicle) {
+      vehicles.erase(itr);
+      return;
     }
+}
 
+void Segment::insertVehicle(std::list<Vehicle *>::iterator &vehicle) {
+  auto itr = vehicles.begin();
+  for (; itr != vehicles.end() &&
+         (**itr)->getDistance() > (*vehicle)->getDistance();
+       ++itr)
+    ;
+  vehicles.insert(itr, vehicle);
 }
 
+} // namespace CityFlow
diff --git a/src/roadnet/roadnet.h b/src/roadnet/roadnet.h
index 5bff2e7..8895e29 100644
--- a/src/roadnet/roadnet.h
+++ b/src/roadnet/roadnet.h
@@ -4,536 +4,547 @@
 #include "roadnet/trafficlight.h"
 #include "utility/utility.h"
 
+#include <iostream>
 #include <list>
 #include <map>
 #include <queue>
-#include <iostream>
 
 namespace CityFlow {
-    class RoadNet;
-
-    class Intersection;
+class RoadNet;
 
-    class Road;
+class Intersection;
 
-    class Lane;
+class Road;
 
-    class LaneLink;
+class Lane;
 
-    class Vehicle;
+class LaneLink;
 
-    class Cross;
+class Vehicle;
 
-    class Segment {
-        friend Lane;
-    public:
-        //Vehicle * tryChange = nullptr;
+class Cross;
 
-        Segment() = default;
+class Segment {
+  friend Lane;
 
-        Segment(size_t index, Lane *belongLane, double startPos, double endPos) : index(index), belongLane(belongLane),
-                                                                                  startPos(startPos), endPos(endPos) { }
+public:
+  // Vehicle * tryChange = nullptr;
 
-        double getStartPos() const { return this->startPos; }
+  Segment() = default;
 
-        double getEndPos() const { return this->endPos; }
+  Segment(size_t index, Lane *belongLane, double startPos, double endPos)
+      : index(index), belongLane(belongLane), startPos(startPos),
+        endPos(endPos) {}
 
-        size_t getIndex() const { return this->index; }
+  double getStartPos() const { return this->startPos; }
 
-        const std::list<std::list<Vehicle *>::iterator> &getVehicles() const { return this->vehicles; }
+  double getEndPos() const { return this->endPos; }
 
-        std::list<std::list<Vehicle *>::iterator> &getVehicles() { return this->vehicles; }
+  size_t getIndex() const { return this->index; }
 
-//        std::list<Vehicle *>::iterator getPrevVehicleIter() const { return this->prev_vehicle_iter; }
+  const std::list<std::list<Vehicle *>::iterator> &getVehicles() const {
+    return this->vehicles;
+  }
 
-        std::list<Vehicle *>::iterator findVehicle(Vehicle * vehicle);
+  std::list<std::list<Vehicle *>::iterator> &getVehicles() {
+    return this->vehicles;
+  }
 
-        void removeVehicle(Vehicle * vehicle);
+  //        std::list<Vehicle *>::iterator getPrevVehicleIter() const { return
+  //        this->prev_vehicle_iter; }
 
-        void insertVehicle(std::list<Vehicle *> ::iterator &vehicle);
+  std::list<Vehicle *>::iterator findVehicle(Vehicle *vehicle);
 
-    private:
-        size_t index = 0;
-        Lane *belongLane = nullptr;
-        double startPos = 0;
-        double endPos = 0;
-        std::list<std::list<Vehicle *>::iterator> vehicles;
-        std::list<Vehicle *>::iterator prev_vehicle_iter;
-    };
+  void removeVehicle(Vehicle *vehicle);
 
-    class Intersection {
-        friend class RoadNet;
+  void insertVehicle(std::list<Vehicle *>::iterator &vehicle);
 
-        friend class RoadLink;
+private:
+  size_t index = 0;
+  Lane *belongLane = nullptr;
+  double startPos = 0;
+  double endPos = 0;
+  std::list<std::list<Vehicle *>::iterator> vehicles;
+  std::list<Vehicle *>::iterator prev_vehicle_iter;
+};
 
-        friend class Road;
+class Intersection {
+  friend class RoadNet;
 
-        friend class TrafficLight;
+  friend class RoadLink;
 
-    private:
-        std::string id;
-        bool isVirtual;
-        double width = 0.0;
-        Point point;
-        TrafficLight trafficLight;
-        std::vector<Road *> roads;
-        std::vector<RoadLink> roadLinks;
-        std::vector<Cross> crosses;
-        std::vector<LaneLink *> laneLinks;
+  friend class Road;
 
-        void initCrosses();
+  friend class TrafficLight;
 
-    public:
-        std::string getId() const { return this->id; }
+private:
+  std::string id;
+  bool isVirtual;
+  double width = 0.0;
+  Point point;
+  TrafficLight trafficLight;
+  std::vector<Road *> roads;
+  std::vector<RoadLink> roadLinks;
+  std::vector<Cross> crosses;
+  std::vector<LaneLink *> laneLinks;
 
-        const TrafficLight &getTrafficLight() const { return trafficLight; }
+  void initCrosses();
 
-        TrafficLight &getTrafficLight() { return trafficLight; }
+public:
+  int _index;
+  std::string getId() const { return this->id; }
 
-        const std::vector<Road *> &getRoads() const { return this->roads; }
+  const TrafficLight &getTrafficLight() const { return trafficLight; }
 
-        std::vector<Road *> &getRoads() { return this->roads; }
+  TrafficLight &getTrafficLight() { return trafficLight; }
 
-        const std::vector<RoadLink> &getRoadLinks() const { return this->roadLinks; }
+  const std::vector<Road *> &getRoads() const { return this->roads; }
 
-        std::vector<RoadLink> &getRoadLinks() { return this->roadLinks; }
+  std::vector<Road *> &getRoads() { return this->roads; }
 
-        std::vector<Cross> &getCrosses() { return crosses; }
+  const std::vector<RoadLink> &getRoadLinks() const { return this->roadLinks; }
 
-        bool isVirtualIntersection() const { return this->isVirtual; }
+  std::vector<RoadLink> &getRoadLinks() { return this->roadLinks; }
 
-        const std::vector<LaneLink *> &getLaneLinks();
+  std::vector<Cross> &getCrosses() { return crosses; }
 
-        void reset();
+  bool isVirtualIntersection() const { return this->isVirtual; }
 
-        std::vector<Point> getOutline();
+  const std::vector<LaneLink *> &getLaneLinks();
 
-        bool isImplicitIntersection();
+  void reset();
 
-        const Point &getPosition() const { return point; }
-    };
+  std::vector<Point> getOutline();
 
-    class Cross {
-        friend class RoadNet;
+  bool isImplicitIntersection();
 
-        friend class Intersection;
+  const Point &getPosition() const { return point; }
 
-    private:
-        LaneLink *laneLinks[2];
-        Vehicle *notifyVehicles[2];
-        double notifyDistances[2];
-        double distanceOnLane[2];
-        double leaveDistance = 0, arriveDistance = 30; // TODO
-        double ang;
-        double safeDistances[2];
+  std::pair<std::vector<int>, std::vector<int>> get_inout_lanes() const;
 
-    public:
-        double getLeaveDistance() const { return leaveDistance; }
+  std::vector<std::pair<std::vector<int>, std::vector<int>>>
+  get_phase_lanes() const;
+};
 
-        double getArriveDistance() const { return arriveDistance; }
+class Cross {
+  friend class RoadNet;
 
-        void notify(LaneLink *laneLink, Vehicle *vehicle, double notifyDistance);
+  friend class Intersection;
 
-        bool canPass(const Vehicle *vehicle, const LaneLink *laneLink,
-                     double distanceToLaneLinkStart) const; // XXX: change to LaneLink based?
+private:
+  LaneLink *laneLinks[2];
+  Vehicle *notifyVehicles[2];
+  double notifyDistances[2];
+  double distanceOnLane[2];
+  double leaveDistance = 0, arriveDistance = 30; // TODO
+  double ang;
+  double safeDistances[2];
 
-        void clearNotify() { notifyVehicles[0] = notifyVehicles[1] = nullptr; }
+public:
+  double getLeaveDistance() const { return leaveDistance; }
 
-        Vehicle *getFoeVehicle(const LaneLink *laneLink) const {
-            assert(laneLink == laneLinks[0] || laneLink == laneLinks[1]);
-            return laneLink == laneLinks[0] ? notifyVehicles[1] : notifyVehicles[0];
-        }
+  double getArriveDistance() const { return arriveDistance; }
 
-        double getDistanceByLane(const LaneLink *laneLink) const {
-            // XXX: lanelink not in cross?
-            assert(laneLink == laneLinks[0] || laneLink == laneLinks[1]);
-            return laneLink == laneLinks[0] ? distanceOnLane[0] : distanceOnLane[1];
-        }
+  void notify(LaneLink *laneLink, Vehicle *vehicle, double notifyDistance);
 
-        double getNotifyDistanceByLane(LaneLink *laneLink) const {
-            // XXX: lanelink not in cross?
-            assert(laneLink == laneLinks[0] || laneLink == laneLinks[1]);
-            return laneLink == laneLinks[0] ? notifyDistances[0] : notifyDistances[1];
-        }
+  bool canPass(
+      const Vehicle *vehicle, const LaneLink *laneLink,
+      double distanceToLaneLinkStart) const; // XXX: change to LaneLink based?
 
-        double getSafeDistanceByLane(LaneLink *laneLink) {
-            assert(laneLink == laneLinks[0] || laneLink == laneLinks[1]);
-            return laneLink == laneLinks[0] ? safeDistances[0] : safeDistances[1];
-        }
+  void clearNotify() { notifyVehicles[0] = notifyVehicles[1] = nullptr; }
 
-        double getAng() const {
-            return ang;
-        }
+  Vehicle *getFoeVehicle(const LaneLink *laneLink) const {
+    assert(laneLink == laneLinks[0] || laneLink == laneLinks[1]);
+    return laneLink == laneLinks[0] ? notifyVehicles[1] : notifyVehicles[0];
+  }
 
-        LaneLink *getLaneLink(int i) const { return laneLinks[i]; }
+  double getDistanceByLane(const LaneLink *laneLink) const {
+    // XXX: lanelink not in cross?
+    assert(laneLink == laneLinks[0] || laneLink == laneLinks[1]);
+    return laneLink == laneLinks[0] ? distanceOnLane[0] : distanceOnLane[1];
+  }
 
-        void reset();
-    };
+  double getNotifyDistanceByLane(LaneLink *laneLink) const {
+    // XXX: lanelink not in cross?
+    assert(laneLink == laneLinks[0] || laneLink == laneLinks[1]);
+    return laneLink == laneLinks[0] ? notifyDistances[0] : notifyDistances[1];
+  }
 
-    class Road {
-        friend class RoadNet;
+  double getSafeDistanceByLane(LaneLink *laneLink) {
+    assert(laneLink == laneLinks[0] || laneLink == laneLinks[1]);
+    return laneLink == laneLinks[0] ? safeDistances[0] : safeDistances[1];
+  }
 
-        friend class Lane;
+  double getAng() const { return ang; }
 
-    private:
-        std::string id;
-        Intersection *startIntersection = nullptr;
-        Intersection *endIntersection = nullptr;
-        std::vector<Lane> lanes;
-        std::vector<Point> points;
+  LaneLink *getLaneLink(int i) const { return laneLinks[i]; }
 
-        std::vector<Lane *> lanePointers;
+  void reset();
+};
 
-        std::vector<Vehicle *> planRouteBuffer;
+class Road {
+  friend class RoadNet;
 
-        void initLanesPoints();
+  friend class Lane;
 
-    public:
-        std::string getId() const { return id; }
+private:
+  std::string id;
+  Intersection *startIntersection = nullptr;
+  Intersection *endIntersection = nullptr;
+  std::vector<Lane> lanes;
+  std::vector<Point> points;
 
-        const Intersection &getStartIntersection() const { return *(this->startIntersection); }
+  std::vector<Lane *> lanePointers;
 
-        const Intersection &getEndIntersection() const { return *(this->endIntersection); }
+  std::vector<Vehicle *> planRouteBuffer;
 
-        const std::vector<Lane> &getLanes() const { return lanes; }
+  void initLanesPoints();
 
-        std::vector<Lane> &getLanes() { return lanes; }
+public:
+  std::string getId() const { return id; }
 
-        const std::vector<Lane *> &getLanePointers();
+  const Intersection &getStartIntersection() const {
+    return *(this->startIntersection);
+  }
 
-        void buildSegmentationByInterval(double interval);
+  const Intersection &getEndIntersection() const {
+    return *(this->endIntersection);
+  }
 
-        bool connectedToRoad(const Road * road) const;
+  const std::vector<Lane> &getLanes() const { return lanes; }
 
-        void reset();
+  std::vector<Lane> &getLanes() { return lanes; }
 
-        double getWidth() const;
+  const std::vector<Lane *> &getLanePointers();
 
-        double getLength() const;
+  void buildSegmentationByInterval(double interval);
 
-        double averageLength() const;
+  bool connectedToRoad(const Road *road) const;
 
-        double getAverageSpeed() const;
+  void reset();
 
-        double getAverageDuration() const;
+  double getWidth() const;
 
-        const std::vector<Vehicle *> &getPlanRouteBuffer() const {
-            return planRouteBuffer;
-        }
+  double getLength() const;
 
-        void addPlanRouteVehicle(Vehicle *vehicle) {
-            planRouteBuffer.emplace_back(vehicle);
-        }
+  double averageLength() const;
 
-        void clearPlanRouteBuffer() {
-            planRouteBuffer.clear();
-        }
-    };
+  double getAverageSpeed() const;
 
-    class Drivable {
-        friend class RoadNet;
-        friend class Archive;
-    public:
-        enum DrivableType {
-            LANE = 0, LANELINK = 1
-        };
+  double getAverageDuration() const;
 
-    protected:
-        double length;
-        double width;
-        double maxSpeed;
-        std::list<Vehicle *> vehicles;
-        std::vector<Point> points;
-        DrivableType drivableType;
+  const std::vector<Vehicle *> &getPlanRouteBuffer() const {
+    return planRouteBuffer;
+  }
 
-    public:
-        virtual ~Drivable() = default;
+  void addPlanRouteVehicle(Vehicle *vehicle) {
+    planRouteBuffer.emplace_back(vehicle);
+  }
 
-        const std::list<Vehicle *> &getVehicles() const { return vehicles; }
+  void clearPlanRouteBuffer() { planRouteBuffer.clear(); }
+};
 
-        std::list<Vehicle *> &getVehicles() { return vehicles; }
+class Drivable {
+  friend class RoadNet;
+  friend class Archive;
 
-        double getLength() const { return length; }
+public:
+  enum DrivableType { LANE = 0, LANELINK = 1 };
 
-        double getWidth() const { return width; }
+protected:
+  double length;
+  double width;
+  double maxSpeed;
+  std::list<Vehicle *> vehicles;
+  std::vector<Point> points;
+  DrivableType drivableType;
 
-        double getMaxSpeed() const { return maxSpeed; }
+public:
+  virtual ~Drivable() = default;
 
-        size_t getVehicleCount() const { return vehicles.size(); }
+  const std::list<Vehicle *> &getVehicles() const { return vehicles; }
 
-        DrivableType getDrivableType() const { return drivableType; }
+  std::list<Vehicle *> &getVehicles() { return vehicles; }
 
-        bool isLane() const { return drivableType == LANE; }
+  double getLength() const { return length; }
 
-        bool isLaneLink() const { return drivableType == LANELINK; }
+  double getWidth() const { return width; }
 
-        Vehicle *getFirstVehicle() const {
-            if (!vehicles.empty()) return vehicles.front();
-            return nullptr;
-        }
+  double getMaxSpeed() const { return maxSpeed; }
 
-        Vehicle *getLastVehicle() const {
-            if (!vehicles.empty()) return vehicles.back();
-            return nullptr;
-        }
+  size_t getVehicleCount() const { return vehicles.size(); }
 
-        Point getPointByDistance(double dis) const;
+  DrivableType getDrivableType() const { return drivableType; }
 
-        Point getDirectionByDistance(double dis) const;
+  bool isLane() const { return drivableType == LANE; }
 
-        void pushVehicle(Vehicle *vehicle) {
-            vehicles.push_back(vehicle);
-        }
+  bool isLaneLink() const { return drivableType == LANELINK; }
 
-        void popVehicle() { vehicles.pop_front(); }
+  Vehicle *getFirstVehicle() const {
+    if (!vehicles.empty())
+      return vehicles.front();
+    return nullptr;
+  }
 
-        virtual std::string getId() const = 0;
-    };
+  Vehicle *getLastVehicle() const {
+    if (!vehicles.empty())
+      return vehicles.back();
+    return nullptr;
+  }
 
-    class Lane : public Drivable {
+  Point getPointByDistance(double dis) const;
 
-        friend class RoadNet;
-        friend class Road;
-        friend class Archive;
+  Point getDirectionByDistance(double dis) const;
 
-    private:
-        int laneIndex;
-        std::vector<Segment> segments;
-        std::vector<LaneLink *> laneLinks;
-        Road *belongRoad = nullptr;
-        std::deque<Vehicle *> waitingBuffer;
+  void pushVehicle(Vehicle *vehicle) { vehicles.push_back(vehicle); }
 
-        struct HistoryRecord {
-            int vehicleNum;
-            double averageSpeed;
-            HistoryRecord(int vehicleNum, double averageSpeed) : vehicleNum(vehicleNum), averageSpeed(averageSpeed) {}
-        };
-        std::list<HistoryRecord> history;
+  void popVehicle() { vehicles.pop_front(); }
 
-        int    historyVehicleNum = 0;
-        double historyAverageSpeed = 0;
+  virtual std::string getId() const = 0;
+};
 
-        static constexpr int historyLen = 240;
+class Lane : public Drivable {
 
-    public:
-        Lane();
+  friend class RoadNet;
+  friend class Road;
+  friend class Archive;
 
-        Lane(double width, double maxSpeed, int laneIndex, Road *belongRoad);
+private:
+  int laneIndex;
+  std::vector<Segment> segments;
+  std::vector<LaneLink *> laneLinks;
+  Road *belongRoad = nullptr;
+  std::deque<Vehicle *> waitingBuffer;
 
-        std::string getId() const override{
-            return belongRoad->getId() + '_' + std::to_string(getLaneIndex());
-        }
+  struct HistoryRecord {
+    int vehicleNum;
+    double averageSpeed;
+    HistoryRecord(int vehicleNum, double averageSpeed)
+        : vehicleNum(vehicleNum), averageSpeed(averageSpeed) {}
+  };
+  std::list<HistoryRecord> history;
 
-        Road *getBelongRoad() const { return this->belongRoad; }
+  int historyVehicleNum = 0;
+  double historyAverageSpeed = 0;
 
-        bool available(const Vehicle *vehicle) const;
+  static constexpr int historyLen = 240;
 
-        bool canEnter(const Vehicle *vehicle) const;
+public:
+  int _index;
+  Lane();
 
-        size_t getLaneIndex() const { return this->laneIndex; }
+  Lane(double width, double maxSpeed, int laneIndex, Road *belongRoad);
 
-        Lane *getInnerLane() const {
-            return laneIndex > 0 ? &(belongRoad->lanes[laneIndex - 1]) : nullptr;
-        }
+  std::string getId() const override {
+    return belongRoad->getId() + '_' + std::to_string(getLaneIndex());
+  }
 
-        Lane *getOuterLane() const {
-            int lane_num = belongRoad->lanes.size();
-            return laneIndex < lane_num - 1? &(belongRoad->lanes[laneIndex + 1]) : nullptr;
-        }
+  Road *getBelongRoad() const { return this->belongRoad; }
 
-        const std::vector<LaneLink *> &getLaneLinks() const { return this->laneLinks; }
+  bool available(const Vehicle *vehicle) const;
 
-        std::vector<LaneLink *> &getLaneLinks() { return this->laneLinks; }
+  bool canEnter(const Vehicle *vehicle) const;
 
-        Intersection *getStartIntersection() const {
-            return belongRoad->startIntersection;
-        }
+  size_t getLaneIndex() const { return this->laneIndex; }
 
-        Intersection *getEndIntersection() const {
-            return belongRoad->endIntersection;
-        }
+  Lane *getInnerLane() const {
+    return laneIndex > 0 ? &(belongRoad->lanes[laneIndex - 1]) : nullptr;
+  }
 
-        std::vector<LaneLink *> getLaneLinksToRoad(const Road *road) const;
+  Lane *getOuterLane() const {
+    int lane_num = belongRoad->lanes.size();
+    return laneIndex < lane_num - 1 ? &(belongRoad->lanes[laneIndex + 1])
+                                    : nullptr;
+  }
 
-        void reset();
+  const std::vector<LaneLink *> &getLaneLinks() const {
+    return this->laneLinks;
+  }
 
-        /* waiting buffer */
-        const std::deque<Vehicle *> &getWaitingBuffer() const { return waitingBuffer; }
+  std::vector<LaneLink *> &getLaneLinks() { return this->laneLinks; }
 
-        std::deque<Vehicle *> &getWaitingBuffer() { return waitingBuffer; }
+  Intersection *getStartIntersection() const {
+    return belongRoad->startIntersection;
+  }
 
-        void pushWaitingVehicle(Vehicle *vehicle) {
-            waitingBuffer.emplace_back(vehicle);
-        }
+  Intersection *getEndIntersection() const {
+    return belongRoad->endIntersection;
+  }
 
-        /* segmentation */
-        void buildSegmentation(size_t numSegs);
+  std::vector<LaneLink *> getLaneLinksToRoad(const Road *road) const;
 
-        void initSegments();
+  void reset();
 
-        const Segment *getSegment(size_t index) const { return &segments[index]; }
+  /* waiting buffer */
+  const std::deque<Vehicle *> &getWaitingBuffer() const {
+    return waitingBuffer;
+  }
 
-        Segment *getSegment(size_t index) { return &segments[index]; }
+  std::deque<Vehicle *> &getWaitingBuffer() { return waitingBuffer; }
 
-        const std::vector<Segment> &getSegments() const { return segments; }
+  void pushWaitingVehicle(Vehicle *vehicle) {
+    waitingBuffer.emplace_back(vehicle);
+  }
 
-        std::vector<Segment> &getSegments() { return segments; }
+  /* segmentation */
+  void buildSegmentation(size_t numSegs);
 
-        size_t getSegmentNum() const{ return segments.size(); }
+  void initSegments();
 
-        std::vector<Vehicle*> getVehiclesBeforeDistance(double dis, size_t segmentIndex, double deltaDis = 50);
+  const Segment *getSegment(size_t index) const { return &segments[index]; }
 
-        /* history */
-        void updateHistory();
+  Segment *getSegment(size_t index) { return &segments[index]; }
 
-        int getHistoryVehicleNum() const;
+  const std::vector<Segment> &getSegments() const { return segments; }
 
-        double getHistoryAverageSpeed() const;
+  std::vector<Segment> &getSegments() { return segments; }
 
+  size_t getSegmentNum() const { return segments.size(); }
 
-        Vehicle* getVehicleBeforeDistance(double dis, size_t segmentIndex) const; //TODO: set a limit, not too far way
+  std::vector<Vehicle *> getVehiclesBeforeDistance(double dis,
+                                                   size_t segmentIndex,
+                                                   double deltaDis = 50);
 
-        Vehicle* getVehicleAfterDistance(double dis, size_t segmentIndex) const;
+  /* history */
+  void updateHistory();
 
-    };
+  int getHistoryVehicleNum() const;
 
+  double getHistoryAverageSpeed() const;
 
-    enum RoadLinkType {
-        go_straight = 3, turn_left = 2, turn_right = 1
-    };
+  Vehicle *getVehicleBeforeDistance(double dis, size_t segmentIndex)
+      const; // TODO: set a limit, not too far way
 
-    class RoadLink {
-        friend class RoadNet;
+  Vehicle *getVehicleAfterDistance(double dis, size_t segmentIndex) const;
+};
 
-        friend class LaneLink;
+enum RoadLinkType { go_straight = 3, turn_left = 2, turn_right = 1 };
 
-    private:
-        Intersection *intersection = nullptr;
-        Road *startRoad = nullptr;
-        Road *endRoad = nullptr;
-        RoadLinkType type;
-        std::vector<LaneLink> laneLinks;
-        std::vector<LaneLink *> laneLinkPointers;
-        int index;
-    public:
-        const std::vector<LaneLink> &getLaneLinks() const { return this->laneLinks; }
+class RoadLink {
+  friend class RoadNet;
 
-        std::vector<LaneLink> &getLaneLinks() { return this->laneLinks; }
+  friend class LaneLink;
 
-        const std::vector<LaneLink *> &getLaneLinkPointers();
+private:
+  Intersection *intersection = nullptr;
+  Road *startRoad = nullptr;
+  Road *endRoad = nullptr;
+  RoadLinkType type;
+  std::vector<LaneLink> laneLinks;
+  std::vector<LaneLink *> laneLinkPointers;
+  int index;
 
-        Road *getStartRoad() const { return this->startRoad; }
+public:
+  const std::vector<LaneLink> &getLaneLinks() const { return this->laneLinks; }
 
-        Road *getEndRoad() const { return this->endRoad; }
+  std::vector<LaneLink> &getLaneLinks() { return this->laneLinks; }
 
-        bool isAvailable() const {
-            return this->intersection->trafficLight.getCurrentPhase().roadLinkAvailable[this->index];
-        }
+  const std::vector<LaneLink *> &getLaneLinkPointers();
 
-        bool isTurn() const {
-            return type == turn_left || type == turn_right;
-        }
+  Road *getStartRoad() const { return this->startRoad; }
 
-        void reset();
+  Road *getEndRoad() const { return this->endRoad; }
 
-    };
+  bool isAvailable() const {
+    return this->intersection->trafficLight.getCurrentPhase()
+        .roadLinkAvailable[this->index];
+  }
 
-    class LaneLink : public Drivable {
+  bool isTurn() const { return type == turn_left || type == turn_right; }
 
-        friend class RoadNet;
+  void reset();
+};
 
-        friend class Intersection;
+class LaneLink : public Drivable {
 
-    private:
-        RoadLink *roadLink = nullptr;
-        Lane *startLane = nullptr;
-        Lane *endLane = nullptr;
-        std::vector<Cross *> crosses;
+  friend class RoadNet;
 
-    public:
-        LaneLink() {
-            width = 4;
-            maxSpeed = 10000; //TODO
-            drivableType = LANELINK;
-        }
+  friend class Intersection;
 
-        RoadLink *getRoadLink() const { return this->roadLink; }
+private:
+  RoadLink *roadLink = nullptr;
+  Lane *startLane = nullptr;
+  Lane *endLane = nullptr;
+  std::vector<Cross *> crosses;
 
-        RoadLinkType getRoadLinkType() const { return this->roadLink->type; }
+public:
+  LaneLink() {
+    width = 4;
+    maxSpeed = 10000; // TODO
+    drivableType = LANELINK;
+  }
 
-        const std::vector<Cross *> &getCrosses() const { return this->crosses; }
+  RoadLink *getRoadLink() const { return this->roadLink; }
 
-        std::vector<Cross *> &getCrosses() { return this->crosses; }
+  RoadLinkType getRoadLinkType() const { return this->roadLink->type; }
 
-        Lane *getStartLane() const { return startLane; }
+  const std::vector<Cross *> &getCrosses() const { return this->crosses; }
 
-        Lane *getEndLane() const { return endLane; }
+  std::vector<Cross *> &getCrosses() { return this->crosses; }
 
-        bool isAvailable() const { return roadLink->isAvailable(); }
+  Lane *getStartLane() const { return startLane; }
 
-        bool isTurn() const { return roadLink->isTurn(); }
+  Lane *getEndLane() const { return endLane; }
 
-        void reset();
+  bool isAvailable() const { return roadLink->isAvailable(); }
 
-        std::string getId() const override {
-            return (startLane ? startLane->getId() : "") + "_TO_" + (endLane ? endLane->getId() : "");
-        }
-    };
+  bool isTurn() const { return roadLink->isTurn(); }
 
+  void reset();
 
-    class RoadNet {
-    private:
-        std::vector<Road> roads;
-        std::vector<Intersection> intersections;
-        std::map<std::string, Road *> roadMap;
-        std::map<std::string, Intersection *> interMap;
-        std::map<std::string, Drivable *> drivableMap;
+  std::string getId() const override {
+    return (startLane ? startLane->getId() : "") + "_TO_" +
+           (endLane ? endLane->getId() : "");
+  }
+};
 
-        std::vector<Lane *> lanes;
-        std::vector<LaneLink *> laneLinks;
-        std::vector<Drivable *> drivables;
-        Point getPoint(const Point &p1, const Point &p2, double a);
+class RoadNet {
+public:
+  std::vector<Road> roads;
+  std::vector<Intersection> intersections;
+  std::map<std::string, Road *> roadMap;
+  std::map<std::string, Intersection *> interMap;
+  std::map<std::string, Drivable *> drivableMap;
 
-    public:
-        bool loadFromJson(std::string jsonFileName);
+  std::vector<Lane *> lanes;
+  std::vector<LaneLink *> laneLinks;
+  std::vector<Drivable *> drivables;
+  Point getPoint(const Point &p1, const Point &p2, double a);
 
-        rapidjson::Value convertToJson(rapidjson::Document::AllocatorType &allocator);
+  bool loadFromJson(std::string jsonFileName);
 
-        const std::vector<Road> &getRoads() const { return this->roads; }
+  rapidjson::Value convertToJson(rapidjson::Document::AllocatorType &allocator);
 
-        std::vector<Road> &getRoads() { return this->roads; }
+  const std::vector<Road> &getRoads() const { return this->roads; }
 
-        const std::vector<Intersection> &getIntersections() const { return this->intersections; }
+  std::vector<Road> &getRoads() { return this->roads; }
 
-        std::vector<Intersection> &getIntersections() { return this->intersections; }
+  const std::vector<Intersection> &getIntersections() const {
+    return this->intersections;
+  }
 
-        Road *getRoadById(const std::string &id) const {
-            return roadMap.count(id) > 0 ? roadMap.at(id) : nullptr;
-        }
+  std::vector<Intersection> &getIntersections() { return this->intersections; }
 
-        Intersection *getIntersectionById(const std::string &id) const {
-            return interMap.count(id) > 0 ? interMap.at(id) : nullptr;
-        }
+  Road *getRoadById(const std::string &id) const {
+    return roadMap.count(id) > 0 ? roadMap.at(id) : nullptr;
+  }
 
-        Drivable *getDrivableById(const std::string &id) const {
-            return drivableMap.count(id) > 0 ? drivableMap.at(id) : nullptr;
-        }
+  Intersection *getIntersectionById(const std::string &id) const {
+    return interMap.count(id) > 0 ? interMap.at(id) : nullptr;
+  }
 
-        const std::vector<Lane *> &getLanes() const {
-            return lanes;
-        }
+  Drivable *getDrivableById(const std::string &id) const {
+    return drivableMap.count(id) > 0 ? drivableMap.at(id) : nullptr;
+  }
 
-        const std::vector<LaneLink *> &getLaneLinks() const {
-            return laneLinks;
-        }
+  const std::vector<Lane *> &getLanes() const { return lanes; }
 
-        const std::vector<Drivable *> &getDrivables() const {
-            return drivables;
-        }
+  const std::vector<LaneLink *> &getLaneLinks() const { return laneLinks; }
 
-        void reset();
-    };
-}
+  const std::vector<Drivable *> &getDrivables() const { return drivables; }
 
+  void reset();
+};
+} // namespace CityFlow
 
-#endif //CITYFLOW_ROADNET_H
+#endif // CITYFLOW_ROADNET_H
diff --git a/src/roadnet/trafficlight.cpp b/src/roadnet/trafficlight.cpp
index df8006d..1cc96e9 100644
--- a/src/roadnet/trafficlight.cpp
+++ b/src/roadnet/trafficlight.cpp
@@ -3,45 +3,40 @@
 
 namespace CityFlow {
 
-    void TrafficLight::init(int initPhaseIndex) {
-        if (intersection->isVirtual)
-            return;
-        this->curPhaseIndex = initPhaseIndex;
-        this->remainDuration = phases[initPhaseIndex].time;
-    }
-
-    int TrafficLight::getCurrentPhaseIndex() {
-        return this->curPhaseIndex;
-    }
-
-    LightPhase &TrafficLight::getCurrentPhase() {
-        return this->phases.at(this->curPhaseIndex);
-    }
-
-    Intersection &TrafficLight::getIntersection() {
-        return *this->intersection;
-    }
-
-    std::vector<LightPhase> &TrafficLight::getPhases() {
-        return phases;
-    }
-
-    void TrafficLight::passTime(double seconds) {
-        if(intersection->isVirtual)
-            return;
-        remainDuration -= seconds;
-        while (remainDuration <= 0.0) {
-            curPhaseIndex = (curPhaseIndex + 1) % (int) phases.size();
-            remainDuration += phases[curPhaseIndex].time;
-        }
-    }
-
-    void TrafficLight::setPhase(int phaseIndex) {
-        curPhaseIndex = phaseIndex;
-    }
-
-    void TrafficLight::reset() {
-        init(0);
-    }
+void TrafficLight::init(int initPhaseIndex) {
+  if (intersection->isVirtual)
+    return;
+  this->curPhaseIndex = initPhaseIndex;
+  this->remainDuration = phases[initPhaseIndex].time;
+}
+
+const LightPhase &TrafficLight::getCurrentPhase() const {
+  return this->phases.at(this->curPhaseIndex);
+}
 
+const Intersection &TrafficLight::getIntersection() const {
+  return *this->intersection;
 }
+
+const std::vector<LightPhase> &TrafficLight::getPhases() const {
+  return phases;
+}
+
+void TrafficLight::passTime(double seconds) {
+  if (intersection->isVirtual)
+    return;
+  remainDuration -= seconds;
+  while (remainDuration <= 0.0) {
+    curPhaseIndex = (curPhaseIndex + 1) % (int)phases.size();
+    remainDuration += phases[curPhaseIndex].time;
+  }
+}
+
+void TrafficLight::setPhase(int phaseIndex) {
+  assert(phaseIndex < phases.size());
+  curPhaseIndex = phaseIndex;
+}
+
+void TrafficLight::reset() { init(0); }
+
+} // namespace CityFlow
diff --git a/src/roadnet/trafficlight.h b/src/roadnet/trafficlight.h
index 4308bcb..8533b7f 100644
--- a/src/roadnet/trafficlight.h
+++ b/src/roadnet/trafficlight.h
@@ -4,50 +4,53 @@
 #include <vector>
 
 namespace CityFlow {
-    class Intersection;
+class Intersection;
 
-    class RoadLink;
+class RoadLink;
 
-    class RoadNet;
+class RoadNet;
 
-    class TrafficLight;
+class TrafficLight;
 
-    class LightPhase {
-        friend class RoadNet;
-        friend class RoadLink;
-        friend class TrafficLight;
-    private:
-        unsigned int phase = 0;
-        double time = 0.0;
-        std::vector<bool> roadLinkAvailable;
-    };
+class LightPhase {
+  friend class RoadNet;
+  friend class RoadLink;
+  friend class TrafficLight;
 
-    class TrafficLight {
-        friend class RoadNet;
-        friend class Archive;
-    private:
-        Intersection *intersection = nullptr;
-        std::vector<LightPhase> phases;
-        std::vector<int> roadLinkIndices;
-        double remainDuration = 0.0;
-        int curPhaseIndex = 0;
-    public:
-        void init(int initPhaseIndex);
+private:
+  unsigned int phase = 0;
+  double time = 0.0;
 
-        int getCurrentPhaseIndex();
+public:
+  std::vector<bool> roadLinkAvailable;
+};
 
-        LightPhase &getCurrentPhase();
+class TrafficLight {
+  friend class RoadNet;
+  friend class Archive;
 
-        Intersection &getIntersection();
+private:
+  Intersection *intersection = nullptr;
+  std::vector<LightPhase> phases;
+  std::vector<int> roadLinkIndices;
+  double remainDuration = 0.0;
+  int curPhaseIndex = 0;
 
-        std::vector<LightPhase> &getPhases();
+public:
+  void init(int initPhaseIndex);
 
-        void passTime(double seconds);
+  const LightPhase &getCurrentPhase() const;
 
-        void setPhase(int phaseIndex);
+  const Intersection &getIntersection() const;
 
-        void reset();
-    };
-}
+  const std::vector<LightPhase> &getPhases() const;
 
-#endif //CITYFLOW_TRAFFICLIGHT_H
\ No newline at end of file
+  void passTime(double seconds);
+
+  void setPhase(int phaseIndex);
+
+  void reset();
+};
+} // namespace CityFlow
+
+#endif // CITYFLOW_TRAFFICLIGHT_H
\ No newline at end of file
diff --git a/src/utility/barrier.cpp b/src/utility/barrier.cpp
index 290fe74..b3adf06 100644
--- a/src/utility/barrier.cpp
+++ b/src/utility/barrier.cpp
@@ -1,16 +1,17 @@
 #include "barrier.h"
 
 namespace CityFlow {
-    void Barrier::wait() {
-        std::unique_lock<std::mutex> lock(m_mutex);
-        assert(0u != *currCounter);
-        if (!--*currCounter) {
-            currCounter += currCounter == counter ? 1 : -1;
-            *currCounter = m_threads;
-            m_condition.notify_all();
-        } else {
-            size_t *currCounter_local = currCounter;
-            m_condition.wait(lock, [currCounter_local] { return *currCounter_local == 0; });
-        }
-    }
-}
\ No newline at end of file
+void Barrier::wait() {
+  std::unique_lock<std::mutex> lock(m_mutex);
+  assert(0u != *currCounter);
+  if (!--*currCounter) {
+    currCounter += currCounter == counter ? 1 : -1;
+    *currCounter = m_threads;
+    m_condition.notify_all();
+  } else {
+    size_t *currCounter_local = currCounter;
+    m_condition.wait(lock,
+                     [currCounter_local] { return *currCounter_local == 0; });
+  }
+}
+} // namespace CityFlow
\ No newline at end of file
diff --git a/src/utility/barrier.h b/src/utility/barrier.h
index edf2b04..9b3a7ff 100644
--- a/src/utility/barrier.h
+++ b/src/utility/barrier.h
@@ -7,32 +7,31 @@
 #include <thread>
 
 namespace CityFlow {
-    class Barrier {
-    public:
-        Barrier(std::size_t nb_threads) : m_threads(nb_threads), currCounter(&counter[0]) {
-            assert(0u != m_threads);
-            counter[0] = m_threads;
-            counter[1] = 0;
-        }
+class Barrier {
+public:
+  Barrier(std::size_t nb_threads)
+      : m_threads(nb_threads), currCounter(&counter[0]) {
+    assert(0u != m_threads);
+    counter[0] = m_threads;
+    counter[1] = 0;
+  }
 
-        Barrier(const Barrier& barrier) = delete;
+  Barrier(const Barrier &barrier) = delete;
 
-        Barrier(Barrier&& barrier) = delete;
+  Barrier(Barrier &&barrier) = delete;
 
-        Barrier& operator=(const Barrier& barrier) = delete;
+  Barrier &operator=(const Barrier &barrier) = delete;
 
-        Barrier& operator=(Barrier&& barrier) = delete;
+  Barrier &operator=(Barrier &&barrier) = delete;
 
-        void wait();
+  void wait();
 
-    private:
-        std::mutex m_mutex;
-        std::condition_variable m_condition;
-        const size_t m_threads;
-        size_t counter[2], * currCounter;
-    };
-}
+private:
+  std::mutex m_mutex;
+  std::condition_variable m_condition;
+  const size_t m_threads;
+  size_t counter[2], *currCounter;
+};
+} // namespace CityFlow
 
-
-
-#endif //CITYFLOW_BARRIER_H
+#endif // CITYFLOW_BARRIER_H
diff --git a/src/utility/config.h b/src/utility/config.h
index f7b514c..82f1674 100644
--- a/src/utility/config.h
+++ b/src/utility/config.h
@@ -2,7 +2,7 @@
 #define CITYFLOW_CONFIG_H
 
 namespace CityFlow {
-    const int MAX_NUM_CARS_ON_SEGMENT = 10;
+const int MAX_NUM_CARS_ON_SEGMENT = 10;
 }
 
-#endif //CITYFLOW_CONFIG_H
+#endif // CITYFLOW_CONFIG_H
diff --git a/src/utility/optionparser.h b/src/utility/optionparser.h
index 666e809..ace5ec7 100644
--- a/src/utility/optionparser.h
+++ b/src/utility/optionparser.h
@@ -7,12 +7,12 @@
 #ifndef OPTIONPARSER_H_
 #define OPTIONPARSER_H_
 
-#include <stdlib.h>
 #include <algorithm>
 #include <iomanip>
 #include <iostream>
 #include <map>
 #include <stdexcept>
+#include <stdlib.h>
 #include <string>
 #include <unordered_set>
 #include <vector>
@@ -21,542 +21,536 @@ const std::string ARGS_END = "- ";
 
 namespace optionparser {
 
-    enum StorageMode { STORE_TRUE, STORE_VALUE, STORE_MULT_VALUES };
-
-    enum OptionType { LONG_OPT = 0, SHORT_OPT, POSITIONAL_OPT, EMPTY_OPT };
-
-    struct DictionaryEntry {
-        unsigned int pos;
-        std::string name;
-    };
-
-    struct Option {
-        Option() {}
-        void help_doc() {
-            std::string h = "    ";
-            if (m_long_flag != "") {
-                h += m_long_flag;
-                if (m_short_flag != "") {
-                    h += ", ";
-                }
-            }
-            if (m_short_flag != "") {
-                h += m_short_flag;
-            }
-
-            printf("%-25s%s\n", h.c_str(), m_help.c_str());
-        }
-
-        bool &found() { return m_found; }
-
-        Option &required(bool req) {
-            m_required = req;
-            return *this;
-        }
-        bool &required() { return m_required; }
-
-        std::string &short_flag() { return m_short_flag; }
+enum StorageMode { STORE_TRUE, STORE_VALUE, STORE_MULT_VALUES };
 
-        std::string &long_flag() { return m_long_flag; }
-        std::string &pos_flag() { return m_pos_flag; }
-        std::string m_short_flag = "", m_long_flag = "", m_pos_flag = "";
-
-        StorageMode &mode() { return m_mode; }
-
-        Option &mode(const StorageMode &mode) {
-            m_mode = mode;
-            return *this;
-        }
-
-        std::string &help() { return m_help; }
-
-        Option &help(const std::string &help) {
-            m_help = help;
-            return *this;
-        }
+enum OptionType { LONG_OPT = 0, SHORT_OPT, POSITIONAL_OPT, EMPTY_OPT };
 
-        std::string &dest() { return m_dest; }
+struct DictionaryEntry {
+  unsigned int pos;
+  std::string name;
+};
 
-        Option &dest(const std::string &dest) {
-            m_dest = dest;
-            return *this;
-        }
-
-        std::string &default_value() { return m_default_value; }
-
-        Option &default_value(const std::string &default_value) {
-            m_default_value = default_value;
-            return *this;
-        }
-
-        Option &default_value(const char *default_value) {
-            m_default_value = std::string(default_value);
-            return *this;
-        }
+struct Option {
+  Option() {}
+  void help_doc() {
+    std::string h = "    ";
+    if (m_long_flag != "") {
+      h += m_long_flag;
+      if (m_short_flag != "") {
+        h += ", ";
+      }
+    }
+    if (m_short_flag != "") {
+      h += m_short_flag;
+    }
 
-        template <typename T>
-        Option &default_value(const T &default_value) {
-            m_default_value = std::to_string(default_value);
-            return *this;
-        }
+    printf("%-25s%s\n", h.c_str(), m_help.c_str());
+  }
 
-        bool m_found = false;
-        bool m_required = false;
-        StorageMode m_mode = STORE_TRUE;
-        std::string m_help = "";
-        std::string m_dest = "";
-        std::string m_default_value = "";
-
-        static OptionType get_type(std::string opt);
-        static std::string get_destination(std::string opt1, std::string opt2,
-                                           OptionType ft, OptionType st);
-    };
-//----------------------------------------------------------------------------
-    std::string remove_character(std::string str, const char c) {
-        // dummy way to remove -- and - from args
-        auto pos = str.find("--");
+  bool &found() { return m_found; }
 
-        if (pos == 0) {
-            str.erase(0, 2);
-        }
+  Option &required(bool req) {
+    m_required = req;
+    return *this;
+  }
+  bool &required() { return m_required; }
 
-        pos = str.find('-');
-        if (pos == 0) {
-            str.erase(0, 1);
-        }
+  std::string &short_flag() { return m_short_flag; }
 
-        return str;
-    }
+  std::string &long_flag() { return m_long_flag; }
+  std::string &pos_flag() { return m_pos_flag; }
+  std::string m_short_flag = "", m_long_flag = "", m_pos_flag = "";
 
-    typedef std::map<std::string, std::vector<std::string>> Archive;
-    typedef std::map<std::string, DictionaryEntry> Dictionary;
+  StorageMode &mode() { return m_mode; }
 
-    OptionType Option::get_type(std::string opt) {
-        if (opt == "") {
-            return OptionType::EMPTY_OPT;
-        }
+  Option &mode(const StorageMode &mode) {
+    m_mode = mode;
+    return *this;
+  }
 
-        if (opt[0] == '-') {
-            if (opt.size() == 2) {
-                return OptionType::SHORT_OPT;
-            }
+  std::string &help() { return m_help; }
 
-            else {
-                return OptionType::LONG_OPT;
-            }
-        }
-        return OptionType::POSITIONAL_OPT;
-    }
-    std::string Option::get_destination(std::string first_option,
-                                        std::string second_option,
-                                        OptionType first_opt_type,
-                                        OptionType second_opt_type) {
-        std::string dest;
-
-        if (first_opt_type == OptionType::LONG_OPT) {
-            dest = remove_character(first_option, '-');
-        } else if (second_opt_type == OptionType::LONG_OPT) {
-            dest = remove_character(second_option, '-');
-        } else {
-            if (first_opt_type == OptionType::SHORT_OPT) {
-                dest = remove_character(first_option, '-') + "_option";
-            } else if (second_opt_type == OptionType::SHORT_OPT) {
-                dest = remove_character(second_option, '-') + "_option";
-            } else {
-                if (first_opt_type == OptionType::POSITIONAL_OPT) {
-                    dest = first_option;
-                } else if (second_opt_type == OptionType::POSITIONAL_OPT) {
-                    dest = second_option;
-                }
-            }
-        }
+  Option &help(const std::string &help) {
+    m_help = help;
+    return *this;
+  }
 
-        return dest;
-    }
-//-----------------------------------------------------------------------------
-//  OptionParser Class
-//-----------------------------------------------------------------------------
-    class OptionParser {
-    public:
-        OptionParser(std::string description = "", bool create_help = true)
-                : m_options(0), m_description(description) {
-            if (create_help) {
-                add_option("--help", "-h").help("Display this help message and exit.");
-            }
-        }
+  std::string &dest() { return m_dest; }
 
-        ~OptionParser() = default;
+  Option &dest(const std::string &dest) {
+    m_dest = dest;
+    return *this;
+  }
 
-        void eat_arguments(unsigned int argc, char const *argv[]);
+  std::string &default_value() { return m_default_value; }
 
-        Option &add_option(std::string first_option, std::string second_option = "");
+  Option &default_value(const std::string &default_value) {
+    m_default_value = default_value;
+    return *this;
+  }
 
-        template <class T = bool>
-        T get_value(std::string key);
+  Option &default_value(const char *default_value) {
+    m_default_value = std::string(default_value);
+    return *this;
+  }
 
-        void help();
+  template <typename T> Option &default_value(const T &default_value) {
+    m_default_value = std::to_string(default_value);
+    return *this;
+  }
 
-    private:
-        Option &add_option_internal(std::string longoption, std::string shortoption);
+  bool m_found = false;
+  bool m_required = false;
+  StorageMode m_mode = STORE_TRUE;
+  std::string m_help = "";
+  std::string m_dest = "";
+  std::string m_default_value = "";
 
-        void error(const std::string &e);
+  static OptionType get_type(std::string opt);
+  static std::string get_destination(std::string opt1, std::string opt2,
+                                     OptionType ft, OptionType st);
+};
+//----------------------------------------------------------------------------
+std::string remove_character(std::string str, const char c) {
+  // dummy way to remove -- and - from args
+  auto pos = str.find("--");
 
-        Archive m_values;
-        std::vector<Option> m_options;
-        std::string m_prog_name, m_description;
+  if (pos == 0) {
+    str.erase(0, 2);
+  }
 
-        std::map<std::string, unsigned int> idx;
+  pos = str.find('-');
+  if (pos == 0) {
+    str.erase(0, 1);
+  }
 
-        bool get_value_arg(std::vector<std::string> &arguments, unsigned int &arg,
-                           Option &opt, std::string &flag);
+  return str;
+}
 
-        bool try_to_get_opt(std::vector<std::string> &arguments, unsigned int &arg,
-                            Option &option, std::string &flag);
+typedef std::map<std::string, std::vector<std::string>> Archive;
+typedef std::map<std::string, DictionaryEntry> Dictionary;
 
-        void check_for_missing_args();
-    };
+OptionType Option::get_type(std::string opt) {
+  if (opt == "") {
+    return OptionType::EMPTY_OPT;
+  }
 
-    Option &OptionParser::add_option(std::string first_option,
-                                     std::string second_option) {
-        return add_option_internal(first_option, second_option);
+  if (opt[0] == '-') {
+    if (opt.size() == 2) {
+      return OptionType::SHORT_OPT;
     }
 
-    Option &OptionParser::add_option_internal(std::string first_option,
-                                              std::string second_option) {
-        m_options.resize(m_options.size() + 1);
-        Option &opt = m_options.back();
-        OptionType first_option_type = Option::get_type(first_option);
-        OptionType second_option_type = Option::get_type(second_option);
-
-        opt.m_dest = Option::get_destination(first_option, second_option,
-                                             first_option_type, second_option_type);
-
-        if (first_option_type == OptionType::LONG_OPT) {
-            opt.long_flag() = first_option;
-        } else if (second_option_type == OptionType::LONG_OPT) {
-            opt.long_flag() = second_option;
-        }
-
-        if (first_option_type == OptionType::SHORT_OPT) {
-            opt.short_flag() = first_option;
-        } else if (second_option_type == OptionType::SHORT_OPT) {
-            opt.short_flag() = second_option;
-        }
-        if (first_option_type == OptionType::POSITIONAL_OPT) {
-            opt.pos_flag() = first_option;
-        } else if (second_option_type == OptionType::POSITIONAL_OPT) {
-            opt.pos_flag() = second_option;
-        }
-        return opt;
+    else {
+      return OptionType::LONG_OPT;
     }
-
-    std::vector<std::string> split_str(std::string s, std::string delimiter = " ") {
-        size_t pos = 0;
-        std::string token;
-        std::vector<std::string> vals;
-        while ((pos = s.find(delimiter)) != std::string::npos) {
-            token = s.substr(0, pos);
-            vals.push_back(token);
-            s.erase(0, pos + delimiter.length());
-        }
-        vals.push_back(s);
-        return vals;
+  }
+  return OptionType::POSITIONAL_OPT;
+}
+std::string Option::get_destination(std::string first_option,
+                                    std::string second_option,
+                                    OptionType first_opt_type,
+                                    OptionType second_opt_type) {
+  std::string dest;
+
+  if (first_opt_type == OptionType::LONG_OPT) {
+    dest = remove_character(first_option, '-');
+  } else if (second_opt_type == OptionType::LONG_OPT) {
+    dest = remove_character(second_option, '-');
+  } else {
+    if (first_opt_type == OptionType::SHORT_OPT) {
+      dest = remove_character(first_option, '-') + "_option";
+    } else if (second_opt_type == OptionType::SHORT_OPT) {
+      dest = remove_character(second_option, '-') + "_option";
+    } else {
+      if (first_opt_type == OptionType::POSITIONAL_OPT) {
+        dest = first_option;
+      } else if (second_opt_type == OptionType::POSITIONAL_OPT) {
+        dest = second_option;
+      }
     }
+  }
 
-    bool OptionParser::get_value_arg(std::vector<std::string> &arguments,
-                                     unsigned int &arg, Option &opt,
-                                     std::string &flag) {
-        std::string val = "";
-        m_values[opt.dest()].clear();
-        if (arguments[arg].size() > flag.size()) {
-            auto search_pt = arguments[arg].find_first_of('=');
-
-            if (search_pt == std::string::npos) {
-                search_pt = arguments[arg].find_first_of(' ');
-
-                if (search_pt == std::string::npos) {
-                    error("Error, long options (" + flag +
-                          ") require a '=' or space before a value.");
-                    return false;
-                }
-                auto vals = split_str(arguments[arg].substr(search_pt + 1));
-                for (auto v : vals) m_values[opt.dest()].push_back(v);
-            }
-        }
-
-        else {
-            if (arg + 1 >= arguments.size()) {
-                if (opt.default_value() == "") {
-                    error("error, flag '" + flag + "' requires an argument.");
-                    return false;
-                }
-                if (m_values[opt.dest()].size() == 0) {
-                    val = opt.default_value();
-                }
-            } else {
-                if (arguments[arg + 1][0] == '-') {
-                    if (opt.default_value() == "") {
-                        error("error, flag '" + flag + "' requires an argument.");
-                        return false;
-                    }
-                    if (m_values[opt.dest()].size() == 0) {
-                        val = opt.default_value();
-                    }
-                }
-            }
-        }
-
-        if (val != "") {
-            m_values[opt.dest()].push_back(val);
-            return true;
-        }
-
-        while (arguments[arg + 1][0] != '-') {
-            arg++;
-            m_values[opt.dest()].push_back(arguments[arg]);
-            if (arg + 1 >= arguments.size()) {
-                break;
-            }
-        }
-
-        return true;
+  return dest;
+}
+//-----------------------------------------------------------------------------
+//  OptionParser Class
+//-----------------------------------------------------------------------------
+class OptionParser {
+public:
+  OptionParser(std::string description = "", bool create_help = true)
+      : m_options(0), m_description(description) {
+    if (create_help) {
+      add_option("--help", "-h").help("Display this help message and exit.");
     }
-
-    bool OptionParser::try_to_get_opt(std::vector<std::string> &arguments,
-                                      unsigned int &arg, Option &option,
-                                      std::string &flag) {
-        if (flag == "") {
-            return false;
-        }
-
-        if (arguments[arg].find(flag) != 0) {
-            return false;
-        }
-
-        if (option.mode() == STORE_TRUE) {
-            option.found() = true;
-            return true;
-        }
-
-        if (((option.mode() == STORE_VALUE) ||
-             (option.mode() == STORE_MULT_VALUES)) &&
-            (option.found() == false)) {
-            if (get_value_arg(arguments, arg, option, flag)) {
-                option.found() = true;
-                return true;
-            }
-        }
-
+  }
+
+  ~OptionParser() = default;
+
+  void eat_arguments(unsigned int argc, char const *argv[]);
+
+  Option &add_option(std::string first_option, std::string second_option = "");
+
+  template <class T = bool> T get_value(std::string key);
+
+  void help();
+
+private:
+  Option &add_option_internal(std::string longoption, std::string shortoption);
+
+  void error(const std::string &e);
+
+  Archive m_values;
+  std::vector<Option> m_options;
+  std::string m_prog_name, m_description;
+
+  std::map<std::string, unsigned int> idx;
+
+  bool get_value_arg(std::vector<std::string> &arguments, unsigned int &arg,
+                     Option &opt, std::string &flag);
+
+  bool try_to_get_opt(std::vector<std::string> &arguments, unsigned int &arg,
+                      Option &option, std::string &flag);
+
+  void check_for_missing_args();
+};
+
+Option &OptionParser::add_option(std::string first_option,
+                                 std::string second_option) {
+  return add_option_internal(first_option, second_option);
+}
+
+Option &OptionParser::add_option_internal(std::string first_option,
+                                          std::string second_option) {
+  m_options.resize(m_options.size() + 1);
+  Option &opt = m_options.back();
+  OptionType first_option_type = Option::get_type(first_option);
+  OptionType second_option_type = Option::get_type(second_option);
+
+  opt.m_dest = Option::get_destination(first_option, second_option,
+                                       first_option_type, second_option_type);
+
+  if (first_option_type == OptionType::LONG_OPT) {
+    opt.long_flag() = first_option;
+  } else if (second_option_type == OptionType::LONG_OPT) {
+    opt.long_flag() = second_option;
+  }
+
+  if (first_option_type == OptionType::SHORT_OPT) {
+    opt.short_flag() = first_option;
+  } else if (second_option_type == OptionType::SHORT_OPT) {
+    opt.short_flag() = second_option;
+  }
+  if (first_option_type == OptionType::POSITIONAL_OPT) {
+    opt.pos_flag() = first_option;
+  } else if (second_option_type == OptionType::POSITIONAL_OPT) {
+    opt.pos_flag() = second_option;
+  }
+  return opt;
+}
+
+std::vector<std::string> split_str(std::string s, std::string delimiter = " ") {
+  size_t pos = 0;
+  std::string token;
+  std::vector<std::string> vals;
+  while ((pos = s.find(delimiter)) != std::string::npos) {
+    token = s.substr(0, pos);
+    vals.push_back(token);
+    s.erase(0, pos + delimiter.length());
+  }
+  vals.push_back(s);
+  return vals;
+}
+
+bool OptionParser::get_value_arg(std::vector<std::string> &arguments,
+                                 unsigned int &arg, Option &opt,
+                                 std::string &flag) {
+  std::string val = "";
+  m_values[opt.dest()].clear();
+  if (arguments[arg].size() > flag.size()) {
+    auto search_pt = arguments[arg].find_first_of('=');
+
+    if (search_pt == std::string::npos) {
+      search_pt = arguments[arg].find_first_of(' ');
+
+      if (search_pt == std::string::npos) {
+        error("Error, long options (" + flag +
+              ") require a '=' or space before a value.");
         return false;
+      }
+      auto vals = split_str(arguments[arg].substr(search_pt + 1));
+      for (auto v : vals)
+        m_values[opt.dest()].push_back(v);
     }
+  }
 
-    void OptionParser::check_for_missing_args() {
-        std::vector<std::string> missing;
-        for (auto &opt : m_options) {
-            if ((opt.required()) && (!opt.found())) {
-                missing.push_back(opt.dest());
-            } else if ((opt.default_value() != "") && (!opt.found())) {
-                m_values[opt.dest()].push_back(opt.default_value());
-                opt.found() = true;
-            }
-        }
-        if (missing.size() > 0) {
-            std::string e = "Missing required flags: " + missing.at(0);
-            for (unsigned int i = 1; i < missing.size(); ++i) {
-                e += ", " + missing.at(i);
-            }
-            error(e + ".");
-        }
+  else {
+    if (arg + 1 >= arguments.size()) {
+      if (opt.default_value() == "") {
+        error("error, flag '" + flag + "' requires an argument.");
+        return false;
+      }
+      if (m_values[opt.dest()].size() == 0) {
+        val = opt.default_value();
+      }
+    } else {
+      if (arguments[arg + 1][0] == '-') {
+        if (opt.default_value() == "") {
+          error("error, flag '" + flag + "' requires an argument.");
+          return false;
+        }
+        if (m_values[opt.dest()].size() == 0) {
+          val = opt.default_value();
+        }
+      }
     }
-
-    void OptionParser::eat_arguments(unsigned int argc, char const *argv[]) {
-        unsigned int idx_ctr = 0;
-        for (auto &opt : m_options) {
-            idx[opt.m_dest] = idx_ctr;
-            idx_ctr++;
-        }
-
-        m_prog_name = argv[0];
-        std::vector<std::string> arguments;
-        for (unsigned int i = 1; i < argc; ++i) {
-            arguments.push_back(argv[i]);
-        }
-        arguments.push_back(ARGS_END);  // dummy way to solve problem with last arg of
-        // type "arg val1 val2"
-
-        // for each argument cluster
-        for (unsigned int arg = 0; arg < arguments.size(); ++arg) {
-            bool match_found = false;
-            // for each option sets
-            for (auto &option : m_options) {
-                match_found = try_to_get_opt(arguments, arg, option, option.long_flag());
-                if (match_found) {
-                    break;
-                }
-
-                match_found = try_to_get_opt(arguments, arg, option, option.short_flag());
-                if (match_found) {
-                    break;
-                }
-
-                match_found = try_to_get_opt(arguments, arg, option, option.pos_flag());
-                if (match_found) {
-                    break;
-                }
-            }
-
-            if (!match_found) {
-                if (arguments[arg] != ARGS_END) {
-                    error("Unrecognized flag/option '" + arguments[arg] + "'");
-                }
-            }
-        }
-
-        if (get_value("help")) {
-            help();
-        }
-        check_for_missing_args();
+  }
+
+  if (val != "") {
+    m_values[opt.dest()].push_back(val);
+    return true;
+  }
+
+  while (arguments[arg + 1][0] != '-') {
+    arg++;
+    m_values[opt.dest()].push_back(arguments[arg]);
+    if (arg + 1 >= arguments.size()) {
+      break;
     }
-//----------------------------------------------------------------------------
-    void OptionParser::error(const std::string &e) {
-        std::cerr << "In excecutable \'";
-        std::cerr << m_prog_name << "\':\n" << e << std::endl;
-        exit(1);
+  }
+
+  return true;
+}
+
+bool OptionParser::try_to_get_opt(std::vector<std::string> &arguments,
+                                  unsigned int &arg, Option &option,
+                                  std::string &flag) {
+  if (flag == "") {
+    return false;
+  }
+
+  if (arguments[arg].find(flag) != 0) {
+    return false;
+  }
+
+  if (option.mode() == STORE_TRUE) {
+    option.found() = true;
+    return true;
+  }
+
+  if (((option.mode() == STORE_VALUE) ||
+       (option.mode() == STORE_MULT_VALUES)) &&
+      (option.found() == false)) {
+    if (get_value_arg(arguments, arg, option, flag)) {
+      option.found() = true;
+      return true;
+    }
+  }
+
+  return false;
+}
+
+void OptionParser::check_for_missing_args() {
+  std::vector<std::string> missing;
+  for (auto &opt : m_options) {
+    if ((opt.required()) && (!opt.found())) {
+      missing.push_back(opt.dest());
+    } else if ((opt.default_value() != "") && (!opt.found())) {
+      m_values[opt.dest()].push_back(opt.default_value());
+      opt.found() = true;
+    }
+  }
+  if (missing.size() > 0) {
+    std::string e = "Missing required flags: " + missing.at(0);
+    for (unsigned int i = 1; i < missing.size(); ++i) {
+      e += ", " + missing.at(i);
+    }
+    error(e + ".");
+  }
+}
+
+void OptionParser::eat_arguments(unsigned int argc, char const *argv[]) {
+  unsigned int idx_ctr = 0;
+  for (auto &opt : m_options) {
+    idx[opt.m_dest] = idx_ctr;
+    idx_ctr++;
+  }
+
+  m_prog_name = argv[0];
+  std::vector<std::string> arguments;
+  for (unsigned int i = 1; i < argc; ++i) {
+    arguments.push_back(argv[i]);
+  }
+  arguments.push_back(ARGS_END); // dummy way to solve problem with last arg of
+  // type "arg val1 val2"
+
+  // for each argument cluster
+  for (unsigned int arg = 0; arg < arguments.size(); ++arg) {
+    bool match_found = false;
+    // for each option sets
+    for (auto &option : m_options) {
+      match_found = try_to_get_opt(arguments, arg, option, option.long_flag());
+      if (match_found) {
+        break;
+      }
+
+      match_found = try_to_get_opt(arguments, arg, option, option.short_flag());
+      if (match_found) {
+        break;
+      }
+
+      match_found = try_to_get_opt(arguments, arg, option, option.pos_flag());
+      if (match_found) {
+        break;
+      }
     }
 
-    void OptionParser::help() {
-        auto split = m_prog_name.find_last_of('/');
-        std::string stripped_name = m_prog_name.substr(split + 1);
-        std::cout << "usage: " << stripped_name << " [-h] ";
-        for (auto &option : m_options) {
-            if (option.required()) {
-                if (option.short_flag() != "") {
-                    std::cout << option.short_flag();
-                } else {
-                    std::cout << option.long_flag();
-                }
-
-                if (option.mode() == STORE_VALUE) {
-                    std::cout << " ARG ";
-                }
-                if (option.mode() == STORE_MULT_VALUES) {
-                    std::cout << " ARG1 [ARG2 ...] ";
-                }
-            }
-        }
-        std::cout << "[options]\n";
-
-        if (m_description != "") {
-            std::cout << "\n" << m_description << "\n" << std::endl;
-        }
-        for (auto &option : m_options) {
-            option.help_doc();
-        }
-        exit(0);
+    if (!match_found) {
+      if (arguments[arg] != ARGS_END) {
+        error("Unrecognized flag/option '" + arguments[arg] + "'");
+      }
     }
+  }
 
+  if (get_value("help")) {
+    help();
+  }
+  check_for_missing_args();
+}
 //----------------------------------------------------------------------------
-    template <class T>
-    T OptionParser::get_value(std::string key) {
-        try {
-            return m_options[idx.at(key)].found();
-        } catch (std::out_of_range &err) {
-            std::string e("Tried to access value for field '");
-            e += key;
-            e += "' which is not a valid field.";
-            throw std::out_of_range(e);
-        }
+void OptionParser::error(const std::string &e) {
+  std::cerr << "In excecutable \'";
+  std::cerr << m_prog_name << "\':\n" << e << std::endl;
+  exit(1);
+}
+
+void OptionParser::help() {
+  auto split = m_prog_name.find_last_of('/');
+  std::string stripped_name = m_prog_name.substr(split + 1);
+  std::cout << "usage: " << stripped_name << " [-h] ";
+  for (auto &option : m_options) {
+    if (option.required()) {
+      if (option.short_flag() != "") {
+        std::cout << option.short_flag();
+      } else {
+        std::cout << option.long_flag();
+      }
+
+      if (option.mode() == STORE_VALUE) {
+        std::cout << " ARG ";
+      }
+      if (option.mode() == STORE_MULT_VALUES) {
+        std::cout << " ARG1 [ARG2 ...] ";
+      }
     }
+  }
+  std::cout << "[options]\n";
+
+  if (m_description != "") {
+    std::cout << "\n" << m_description << "\n" << std::endl;
+  }
+  for (auto &option : m_options) {
+    option.help_doc();
+  }
+  exit(0);
+}
+
 //----------------------------------------------------------------------------
-    template <>
-    std::string OptionParser::get_value<std::string>(std::string key) {
-        try {
-            return m_values[key][0];
-        } catch (std::out_of_range &err) {
-            std::string e("Tried to access value for field '");
-            e += key;
-            e += "' which is not a valid field.";
-            throw std::out_of_range(e);
-        }
-    }
+template <class T> T OptionParser::get_value(std::string key) {
+  try {
+    return m_options[idx.at(key)].found();
+  } catch (std::out_of_range &err) {
+    std::string e("Tried to access value for field '");
+    e += key;
+    e += "' which is not a valid field.";
+    throw std::out_of_range(e);
+  }
+}
 //----------------------------------------------------------------------------
-    template <>
-    double OptionParser::get_value<double>(std::string key) {
-        try {
-            return std::stod(m_values[key][0]);
-        } catch (std::out_of_range &err) {
-            std::string e("Tried to access value for field '");
-            e += key;
-            e += "' which is not a valid field.";
-            throw std::out_of_range(e);
-        }
-    }
+template <> std::string OptionParser::get_value<std::string>(std::string key) {
+  try {
+    return m_values[key][0];
+  } catch (std::out_of_range &err) {
+    std::string e("Tried to access value for field '");
+    e += key;
+    e += "' which is not a valid field.";
+    throw std::out_of_range(e);
+  }
+}
 //----------------------------------------------------------------------------
-    template <>
-    float OptionParser::get_value<float>(std::string key) {
-        try {
-            return std::stof(m_values[key][0]);
-        } catch (std::out_of_range &err) {
-            std::string e("Tried to access value for field '");
-            e += key;
-            e += "' which is not a valid field.";
-            throw std::out_of_range(e);
-        }
-    }
+template <> double OptionParser::get_value<double>(std::string key) {
+  try {
+    return std::stod(m_values[key][0]);
+  } catch (std::out_of_range &err) {
+    std::string e("Tried to access value for field '");
+    e += key;
+    e += "' which is not a valid field.";
+    throw std::out_of_range(e);
+  }
+}
 //----------------------------------------------------------------------------
-    template <>
-    int OptionParser::get_value<int>(std::string key) {
-        try {
-            return std::stoi(m_values[key][0]);
-        } catch (std::out_of_range &err) {
-            std::string e("Tried to access value for field '");
-            e += key;
-            e += "' which is not a valid field.";
-            throw std::out_of_range(e);
-        }
-    }
+template <> float OptionParser::get_value<float>(std::string key) {
+  try {
+    return std::stof(m_values[key][0]);
+  } catch (std::out_of_range &err) {
+    std::string e("Tried to access value for field '");
+    e += key;
+    e += "' which is not a valid field.";
+    throw std::out_of_range(e);
+  }
+}
 //----------------------------------------------------------------------------
-    template <>
-    unsigned int OptionParser::get_value<unsigned int>(std::string key) {
-        try {
-            return std::stoul(m_values[key][0]);
-        } catch (std::out_of_range &err) {
-            std::string e("Tried to access value for field '");
-            e += key;
-            e += "' which is not a valid field.";
-            throw std::out_of_range(e);
-        }
-    }
+template <> int OptionParser::get_value<int>(std::string key) {
+  try {
+    return std::stoi(m_values[key][0]);
+  } catch (std::out_of_range &err) {
+    std::string e("Tried to access value for field '");
+    e += key;
+    e += "' which is not a valid field.";
+    throw std::out_of_range(e);
+  }
+}
 //----------------------------------------------------------------------------
-    template <>
-    std::vector<std::string> OptionParser::get_value<std::vector<std::string>>(
-            std::string key) {
-        try {
-            return m_values[key];
-        } catch (std::out_of_range &err) {
-            std::string e("Tried to access value for field '");
-            e += key;
-            e += "' which is not a valid field.";
-            throw std::out_of_range(e);
-        }
-    }
+template <>
+unsigned int OptionParser::get_value<unsigned int>(std::string key) {
+  try {
+    return std::stoul(m_values[key][0]);
+  } catch (std::out_of_range &err) {
+    std::string e("Tried to access value for field '");
+    e += key;
+    e += "' which is not a valid field.";
+    throw std::out_of_range(e);
+  }
+}
 //----------------------------------------------------------------------------
-    template <>
-    std::vector<int> OptionParser::get_value<std::vector<int>>(std::string key) {
-        try {
-            std::vector<int> v;
-            for (auto &entry : m_values[key]) {
-                v.push_back(std::stoi(entry));
-            }
-            return v;
-        } catch (std::out_of_range &err) {
-            std::string e("Tried to access value for field '");
-            e += key;
-            e += "' which is not a valid field.";
-            throw std::out_of_range(e);
-        }
+template <>
+std::vector<std::string>
+OptionParser::get_value<std::vector<std::string>>(std::string key) {
+  try {
+    return m_values[key];
+  } catch (std::out_of_range &err) {
+    std::string e("Tried to access value for field '");
+    e += key;
+    e += "' which is not a valid field.";
+    throw std::out_of_range(e);
+  }
+}
+//----------------------------------------------------------------------------
+template <>
+std::vector<int> OptionParser::get_value<std::vector<int>>(std::string key) {
+  try {
+    std::vector<int> v;
+    for (auto &entry : m_values[key]) {
+      v.push_back(std::stoi(entry));
     }
-
-}  // namespace optionparser
+    return v;
+  } catch (std::out_of_range &err) {
+    std::string e("Tried to access value for field '");
+    e += key;
+    e += "' which is not a valid field.";
+    throw std::out_of_range(e);
+  }
+}
+
+} // namespace optionparser
 
 #endif
\ No newline at end of file
diff --git a/src/utility/utility.cpp b/src/utility/utility.cpp
index 8e3ccab..4102367 100644
--- a/src/utility/utility.cpp
+++ b/src/utility/utility.cpp
@@ -1,160 +1,151 @@
 #include "utility/utility.h"
-#include <cmath>
 #include <algorithm>
+#include <cmath>
 #include <iostream>
 
-#include "rapidjson/filereadstream.h"
-#include "rapidjson/filewritestream.h"
 #include "rapidjson/cursorstreamwrapper.h"
-#include "rapidjson/writer.h"
 #include "rapidjson/document.h"
 #include "rapidjson/error/en.h"
+#include "rapidjson/filereadstream.h"
+#include "rapidjson/filewritestream.h"
+#include "rapidjson/writer.h"
 
 namespace CityFlow {
 
-    Point operator*(const Point &A, double k) {
-        return {A.x * k, A.y * k};
-    }
-
-    Point operator-(const Point &A, const Point &B) {
-        return {A.x - B.x, A.y - B.y};
-    }
-
-    Point operator+(const Point &A, const Point &B) {
-        return {A.x + B.x, A.y + B.y};
-    }
-    Point operator-(const Point &A) {
-        return {-A.x, -A.y};
-    }
-
-    Point calcIntersectPoint(Point A, Point B, Point C, Point D) {
-        Point P = A;
-        Point Q = C;
-        Vector u = B - A;
-        Vector v = D - C;
-        return P + u * (crossMultiply(Q - P, v) / crossMultiply(u, v));
-    }
-
-
-    double crossMultiply(const Point &A, const Point &B) {
-        return A.x * B.y - A.y * B.x;
-    }
-
-    double dotMultiply(const Point &A, const Point &B) {
-        return A.x * B.x + A.y * B.y;
-    }
-
-    double calcAng(Point A, Point B) {
-        double ang = A.ang() - B.ang();
-        double pi = acos(-1);
-        while(ang >= pi / 2)
-            ang -= pi / 2;
-        while(ang < 0)
-            ang += pi / 2;
-        return std::min(ang, pi - ang);
-    }
-
-    bool onSegment(Point A, Point B, Point P) {
-        double v1 = crossMultiply(B-A, P-A);
-        double v2 = dotMultiply(P-A, P-B);
-        return Point::sign(v1) == 0 && Point::sign(v2) <= 0;
-    }
-
-    Point Point::unit() {
-        double l = len();
-        return {x / l, y / l};
-    }
-
-    Point Point::normal() {
-        return {-y, x};
-    }
-
-    Point::Point(double x, double y):x(x),y(y) { }
-
-    double Point::len() {
-        return sqrt(x * x + y * y);
-    }
-
-    double Point::ang() {
-        return atan2(y, x);
-    }
-
-    int Point::sign(double x) {
-        return (x + Point::eps > 0) - (x < Point::eps);
-    }
-
-    std::vector<int> generateRandomIndices(size_t n, std::mt19937 *rnd) {
-        std::vector<int> randoms;
-        randoms.reserve(n);
-        for (size_t i = 0; i < n; ++i) {
-            randoms.emplace_back(i);
-        }
-        std::shuffle(randoms.begin(), randoms.end(), *rnd);
-        return randoms;
-    }
-
-    bool readJsonFromFile(const std::string &filename, rapidjson::Document &document) {
-        FILE *fp = fopen(filename.c_str(), "r");
-        if (!fp) {
-            return false;
-        }
-        char readBuffer[JSON_BUFFER_SIZE];
-        rapidjson::FileReadStream is(fp, readBuffer, sizeof(readBuffer));
-        rapidjson::CursorStreamWrapper<rapidjson::FileReadStream> csw(is);
-        document.ParseStream(csw);
-        if (document.HasParseError()) {
-            std::cerr << "Json parsing error at line " << csw.GetLine() << std::endl;
-            std::cerr << rapidjson::GetParseError_En(document.GetParseError());
-            std::cerr << std::endl;
-            throw JsonFormatError("Json parsing error");
-            return false;
-        }
-        fclose(fp);
-        return true;
-    }
-
-    bool writeJsonToFile(const std::string &filename, const rapidjson::Document &document) {
-        FILE *fp = fopen(filename.c_str(), "w");
-        if (!fp) {
-            return false;
-        }
-        char writeBuffer[JSON_BUFFER_SIZE];
-        rapidjson::FileWriteStream os(fp, writeBuffer, sizeof(writeBuffer));
-        rapidjson::Writer<rapidjson::FileWriteStream> writer(os);
-        document.Accept(writer);
-        fclose(fp);
-        return true;
-    }
-
-    const rapidjson::Value &getJsonMemberValue(const std::string &name, const rapidjson::Value &object) {
-        assert(object.IsObject());
-        auto iter = object.FindMember(name.c_str());
-        if (iter == object.MemberEnd())
-            throw JsonMemberMiss(name);
-        return iter->value;
-    }
-
-
-    const rapidjson::Value &
-    getJsonMemberObject(const std::string &name, const rapidjson::Value &object) {
-        const auto &value = getJsonMemberValue(name, object);
-        if (!value.IsObject())
-            throw JsonTypeError(name, "object");
-        return value;
-    }
-
-    const rapidjson::Value &
-    getJsonMemberArray(const std::string &name, const rapidjson::Value &object) {
-        const auto &value = getJsonMemberValue(name, object);
-        if (!value.IsArray())
-            throw JsonTypeError(name, "array");
-        return value;
-    }
-
-    template<>
-    bool jsonConvertableTo<double>(const rapidjson::Value &value) {
-        //We do not differentiate 123.0 and 123
-        return value.IsNumber();
-    }
-
-}
\ No newline at end of file
+Point operator*(const Point &A, double k) { return {A.x * k, A.y * k}; }
+
+Point operator-(const Point &A, const Point &B) {
+  return {A.x - B.x, A.y - B.y};
+}
+
+Point operator+(const Point &A, const Point &B) {
+  return {A.x + B.x, A.y + B.y};
+}
+Point operator-(const Point &A) { return {-A.x, -A.y}; }
+
+Point calcIntersectPoint(Point A, Point B, Point C, Point D) {
+  Point P = A;
+  Point Q = C;
+  Vector u = B - A;
+  Vector v = D - C;
+  return P + u * (crossMultiply(Q - P, v) / crossMultiply(u, v));
+}
+
+double crossMultiply(const Point &A, const Point &B) {
+  return A.x * B.y - A.y * B.x;
+}
+
+double dotMultiply(const Point &A, const Point &B) {
+  return A.x * B.x + A.y * B.y;
+}
+
+double calcAng(Point A, Point B) {
+  double ang = A.ang() - B.ang();
+  double pi = acos(-1);
+  while (ang >= pi / 2)
+    ang -= pi / 2;
+  while (ang < 0)
+    ang += pi / 2;
+  return std::min(ang, pi - ang);
+}
+
+bool onSegment(Point A, Point B, Point P) {
+  double v1 = crossMultiply(B - A, P - A);
+  double v2 = dotMultiply(P - A, P - B);
+  return Point::sign(v1) == 0 && Point::sign(v2) <= 0;
+}
+
+Point Point::unit() {
+  double l = len();
+  if (l == 0) {
+    return {0, 0};
+  }
+  return {x / l, y / l};
+}
+
+Point Point::normal() { return {-y, x}; }
+
+Point::Point(double x, double y) : x(x), y(y) {}
+
+double Point::len() { return sqrt(x * x + y * y); }
+
+double Point::ang() { return atan2(y, x); }
+
+int Point::sign(double x) { return (x + Point::eps > 0) - (x < Point::eps); }
+
+std::vector<int> generateRandomIndices(size_t n, std::mt19937 *rnd) {
+  std::vector<int> randoms;
+  randoms.reserve(n);
+  for (size_t i = 0; i < n; ++i) {
+    randoms.emplace_back(i);
+  }
+  std::shuffle(randoms.begin(), randoms.end(), *rnd);
+  return randoms;
+}
+
+bool readJsonFromFile(const std::string &filename,
+                      rapidjson::Document &document) {
+  FILE *fp = fopen(filename.c_str(), "r");
+  if (!fp) {
+    return false;
+  }
+  char readBuffer[JSON_BUFFER_SIZE];
+  rapidjson::FileReadStream is(fp, readBuffer, sizeof(readBuffer));
+  rapidjson::CursorStreamWrapper<rapidjson::FileReadStream> csw(is);
+  document.ParseStream(csw);
+  if (document.HasParseError()) {
+    std::cerr << "Json parsing error at line " << csw.GetLine() << std::endl;
+    std::cerr << rapidjson::GetParseError_En(document.GetParseError());
+    std::cerr << std::endl;
+    throw JsonFormatError("Json parsing error");
+    return false;
+  }
+  fclose(fp);
+  return true;
+}
+
+bool writeJsonToFile(const std::string &filename,
+                     const rapidjson::Document &document) {
+  FILE *fp = fopen(filename.c_str(), "w");
+  if (!fp) {
+    return false;
+  }
+  char writeBuffer[JSON_BUFFER_SIZE];
+  rapidjson::FileWriteStream os(fp, writeBuffer, sizeof(writeBuffer));
+  rapidjson::Writer<rapidjson::FileWriteStream> writer(os);
+  document.Accept(writer);
+  fclose(fp);
+  return true;
+}
+
+const rapidjson::Value &getJsonMemberValue(const std::string &name,
+                                           const rapidjson::Value &object) {
+  assert(object.IsObject());
+  auto iter = object.FindMember(name.c_str());
+  if (iter == object.MemberEnd())
+    throw JsonMemberMiss(name);
+  return iter->value;
+}
+
+const rapidjson::Value &getJsonMemberObject(const std::string &name,
+                                            const rapidjson::Value &object) {
+  const auto &value = getJsonMemberValue(name, object);
+  if (!value.IsObject())
+    throw JsonTypeError(name, "object");
+  return value;
+}
+
+const rapidjson::Value &getJsonMemberArray(const std::string &name,
+                                           const rapidjson::Value &object) {
+  const auto &value = getJsonMemberValue(name, object);
+  if (!value.IsArray())
+    throw JsonTypeError(name, "array");
+  return value;
+}
+
+template <> bool jsonConvertableTo<double>(const rapidjson::Value &value) {
+  // We do not differentiate 123.0 and 123
+  return value.IsNumber();
+}
+
+} // namespace CityFlow
\ No newline at end of file
diff --git a/src/utility/utility.h b/src/utility/utility.h
index 98647c7..54dc5df 100644
--- a/src/utility/utility.h
+++ b/src/utility/utility.h
@@ -1,145 +1,147 @@
 #ifndef CITYFLOW_TYPEDEF_H
 #define CITYFLOW_TYPEDEF_H
 
-#include "rapidjson/document.h"
 #include "dtoa_milo.h"
+#include "rapidjson/document.h"
 
-#include <vector>
 #include <cmath>
 #include <random>
-#include <typeinfo>
 #include <stdexcept>
+#include <typeinfo>
+#include <vector>
 
 namespace CityFlow {
 
-    constexpr double eps = 1e-8;
-    constexpr size_t JSON_BUFFER_SIZE = 65536;
-
-    class Road;
-    class Lane;
-    class Point {
-    public:
-        double x = 0.0;
-        double y = 0.0;
-
-        static constexpr double eps = 1e-8;
-        static int sign(double x);
-
-        Point() = default;
-        Point(double x, double y);
-        double len();
-        Point normal();
-        Point unit();
-        double ang();
-    };
-    typedef Point Vector;
-
-    Point operator*(const Point &A, double k);
-    Point operator-(const Point &A, const Point &B);
-    Point operator+(const Point &A, const Point &B);
-    Point operator-(const Point &A);
-    double crossMultiply(const Point &A, const Point &B);
-    double dotMultiply(const Point &A, const Point &B);
-    double calcAng(Point A, Point B);
-
-    Point calcIntersectPoint(Point A, Point B, Point C, Point D);
-    bool onSegment(Point A, Point B, Point P);
-
-    struct ControlInfo {
-        double speed = 0.0;
-        double changingSpeed = 0.0;
-        Lane * nextLane = nullptr;
-        bool waitingForChangingLane = false;
-        bool collision = false;
-    };
-
-    struct LaneInfo {
-        Road *road;
-        int LaneNumber;
-        double pos;
-    };
-
-    struct FinalInfo {
-        //TODO
-    };
-
-    inline double max2double(double x, double y) {
-        return x > y ? x : y;
-    }
-
-    inline double min2double(double x, double y) {
-        return x < y ? x : y;
-    }
-    
-    inline std::string double2string(double x) {
-        char ret[30];
-        dtoa_milo(x, ret);
-        std::string str(ret);
-        return str;
-    }
-
-    std::vector<int> generateRandomIndices(size_t n, std::mt19937 *rnd); // size_t compile error
-
-    bool readJsonFromFile(const std::string &filename, rapidjson::Document &document);
-    bool writeJsonToFile(const std::string &filename, const rapidjson::Document &document);
-
-    class JsonFormatError: public std::runtime_error {
-    public:
-        explicit JsonFormatError(const std::string &info) : std::runtime_error(info){}
-    };
-
-    class JsonMemberMiss: public JsonFormatError  {
-    private:
-        std::string info;
-    public:
-        explicit JsonMemberMiss(const std::string &name) :
-                JsonFormatError(name + " is required but missing in json file"){}
-    };
-
-    class JsonTypeError: public JsonFormatError  {
-    private:
-        std::string info;
-    public:
-        JsonTypeError(const std::string &name, const char* type) :
-                JsonFormatError(name + ": expected type " + type){}
-
-        JsonTypeError(const std::string &name, const std::string &type) :
-                JsonTypeError(name, type.c_str()){}
-    };
-
-    const rapidjson::Value &getJsonMemberValue(const std::string &name, const rapidjson::Value &object);
-
-    template<typename T>
-    bool jsonConvertableTo(const rapidjson::Value &value) {
-        return value.Is<T>();
-    };
-
-    template<>
-    bool jsonConvertableTo<double>(const rapidjson::Value &value);
-
-    template<typename T>
-    T getJsonMember(const std::string &name, const rapidjson::Value &object) {
-        assert(object.IsObject());
-        const auto &value = getJsonMemberValue(name, object);
-        if (!jsonConvertableTo<T>(value))
-            throw JsonTypeError(name, typeid(T).name());
-        return value.Get<T>();
-    }
-
-    template<typename T>
-    T getJsonMember(const std::string &name, const rapidjson::Value &object, const T &default_value) {
-        assert(object.IsObject());
-        auto iter = object.FindMember(name.c_str());
-        if (iter == object.MemberEnd() || !jsonConvertableTo<T>(iter->value))
-            return default_value;
-        return iter->value.Get<T>();
-    }
-
-    const rapidjson::Value &
-    getJsonMemberObject(const std::string &name, const rapidjson::Value &object);
-
-    const rapidjson::Value &
-    getJsonMemberArray(const std::string &name, const rapidjson::Value &object);
+constexpr double eps = 1e-8;
+constexpr size_t JSON_BUFFER_SIZE = 65536;
+
+class Road;
+class Lane;
+class Point {
+public:
+  double x = 0.0;
+  double y = 0.0;
+
+  static constexpr double eps = 1e-8;
+  static int sign(double x);
+
+  Point() = default;
+  Point(double x, double y);
+  double len();
+  Point normal();
+  Point unit();
+  double ang();
+};
+typedef Point Vector;
+
+Point operator*(const Point &A, double k);
+Point operator-(const Point &A, const Point &B);
+Point operator+(const Point &A, const Point &B);
+Point operator-(const Point &A);
+double crossMultiply(const Point &A, const Point &B);
+double dotMultiply(const Point &A, const Point &B);
+double calcAng(Point A, Point B);
+
+Point calcIntersectPoint(Point A, Point B, Point C, Point D);
+bool onSegment(Point A, Point B, Point P);
+
+struct ControlInfo {
+  double speed = 0.0;
+  double changingSpeed = 0.0;
+  Lane *nextLane = nullptr;
+  bool waitingForChangingLane = false;
+  bool collision = false;
+};
+
+struct LaneInfo {
+  Road *road;
+  int LaneNumber;
+  double pos;
+};
+
+struct FinalInfo {
+  // TODO
+};
+
+inline double max2double(double x, double y) { return x > y ? x : y; }
+
+inline double min2double(double x, double y) { return x < y ? x : y; }
+
+inline std::string double2string(double x) {
+  char ret[30];
+  dtoa_milo(x, ret);
+  std::string str(ret);
+  return str;
 }
 
-#endif //CITYFLOW_TYPEDEF_H
+std::vector<int>
+generateRandomIndices(size_t n, std::mt19937 *rnd); // size_t compile error
+
+bool readJsonFromFile(const std::string &filename,
+                      rapidjson::Document &document);
+bool writeJsonToFile(const std::string &filename,
+                     const rapidjson::Document &document);
+
+class JsonFormatError : public std::runtime_error {
+public:
+  explicit JsonFormatError(const std::string &info)
+      : std::runtime_error(info) {}
+};
+
+class JsonMemberMiss : public JsonFormatError {
+private:
+  std::string info;
+
+public:
+  explicit JsonMemberMiss(const std::string &name)
+      : JsonFormatError(name + " is required but missing in json file") {}
+};
+
+class JsonTypeError : public JsonFormatError {
+private:
+  std::string info;
+
+public:
+  JsonTypeError(const std::string &name, const char *type)
+      : JsonFormatError(name + ": expected type " + type) {}
+
+  JsonTypeError(const std::string &name, const std::string &type)
+      : JsonTypeError(name, type.c_str()) {}
+};
+
+const rapidjson::Value &getJsonMemberValue(const std::string &name,
+                                           const rapidjson::Value &object);
+
+template <typename T> bool jsonConvertableTo(const rapidjson::Value &value) {
+  return value.Is<T>();
+};
+
+template <> bool jsonConvertableTo<double>(const rapidjson::Value &value);
+
+template <typename T>
+T getJsonMember(const std::string &name, const rapidjson::Value &object) {
+  assert(object.IsObject());
+  const auto &value = getJsonMemberValue(name, object);
+  if (!jsonConvertableTo<T>(value))
+    throw JsonTypeError(name, typeid(T).name());
+  return value.Get<T>();
+}
+
+template <typename T>
+T getJsonMember(const std::string &name, const rapidjson::Value &object,
+                const T &default_value) {
+  assert(object.IsObject());
+  auto iter = object.FindMember(name.c_str());
+  if (iter == object.MemberEnd() || !jsonConvertableTo<T>(iter->value))
+    return default_value;
+  return iter->value.Get<T>();
+}
+
+const rapidjson::Value &getJsonMemberObject(const std::string &name,
+                                            const rapidjson::Value &object);
+
+const rapidjson::Value &getJsonMemberArray(const std::string &name,
+                                           const rapidjson::Value &object);
+} // namespace CityFlow
+
+#endif // CITYFLOW_TYPEDEF_H
diff --git a/src/vehicle/lanechange.cpp b/src/vehicle/lanechange.cpp
index ab34ec2..e6a9c9f 100644
--- a/src/vehicle/lanechange.cpp
+++ b/src/vehicle/lanechange.cpp
@@ -3,226 +3,250 @@
 
 #include <iostream>
 
-namespace CityFlow{
-    LaneChange::LaneChange(Vehicle * vehicle, const LaneChange &other)
-        : lastDir(other.lastDir), signalRecv(other.signalRecv),
-          vehicle(vehicle), targetLeader(other.targetLeader), targetFollower(other.targetFollower), // useless in archive
-          leaderGap(other.leaderGap), followerGap(other.followerGap), waitingTime(other.waitingTime),
-          changing(other.changing), lastChangeTime(other.lastChangeTime) {
-        if (other.signalSend) {
-            signalSend = std::make_shared<Signal>(*other.signalSend);
-            signalSend->source = vehicle;
+namespace CityFlow {
+LaneChange::LaneChange(Vehicle *vehicle, const LaneChange &other)
+    : lastDir(other.lastDir), signalRecv(other.signalRecv), vehicle(vehicle),
+      targetLeader(other.targetLeader),
+      targetFollower(other.targetFollower), // useless in archive
+      leaderGap(other.leaderGap), followerGap(other.followerGap),
+      waitingTime(other.waitingTime), changing(other.changing),
+      lastChangeTime(other.lastChangeTime) {
+  if (other.signalSend) {
+    signalSend = std::make_shared<Signal>(*other.signalSend);
+    signalSend->source = vehicle;
+  }
+}
+
+Lane *LaneChange::getTarget() const {
+  assert(vehicle->getCurDrivable()->isLane());
+  return signalSend ? signalSend->target : (Lane *)vehicle->getCurDrivable();
+}
+
+bool LaneChange::planChange() const {
+  return (signalSend && signalSend->target &&
+          signalSend->target != vehicle->getCurDrivable()) ||
+         changing;
+}
+
+void LaneChange::updateLeaderAndFollower() {
+  targetLeader = targetFollower = nullptr;
+  Lane *target = signalSend->target;
+  targetLeader = target->getVehicleAfterDistance(vehicle->getDistance(),
+                                                 vehicle->getSegmentIndex());
+  Lane *curLane = dynamic_cast<Lane *>(vehicle->getCurDrivable());
+  leaderGap = followerGap = std::numeric_limits<double>::max();
+  if (!targetLeader) {
+    // Find target leader in following lanelinks
+    double rest = curLane->getLength() - vehicle->getDistance();
+    leaderGap = rest;
+    double gap = std::numeric_limits<double>::max();
+    for (auto lanelink : signalSend->target->getLaneLinks()) {
+      Vehicle *leader = lanelink->getLastVehicle();
+      if (leader && leader->getDistance() + rest < gap) {
+        gap = leader->getDistance() + rest;
+        if (gap < leader->getLen()) {
+          targetLeader = leader;
+          leaderGap = rest - (leader->getLen() - gap);
         }
-    }
-
-    Lane *LaneChange::getTarget() const {
-        assert(vehicle->getCurDrivable()->isLane());
-        return signalSend ? signalSend->target : (Lane *)vehicle->getCurDrivable();
-    }
-
-    bool LaneChange::planChange() const {
-        return (signalSend && signalSend->target && signalSend->target != vehicle->getCurDrivable()) || changing;
-    }
-
-    void LaneChange::updateLeaderAndFollower() {
-        targetLeader = targetFollower = nullptr;
-        Lane *target  = signalSend->target;
-        targetLeader   = target->getVehicleAfterDistance(vehicle->getDistance(), vehicle->getSegmentIndex());
-        Lane *curLane = dynamic_cast<Lane *>(vehicle->getCurDrivable());
-        leaderGap = followerGap = std::numeric_limits<double>::max();
-        if (!targetLeader){
-            // Find target leader in following lanelinks
-            double rest = curLane->getLength() - vehicle->getDistance();
-            leaderGap = rest;
-            double gap = std::numeric_limits<double>::max();
-            for (auto lanelink: signalSend->target->getLaneLinks()){
-                Vehicle *leader = lanelink->getLastVehicle();
-                if (leader && leader->getDistance() + rest < gap ){
-                    gap = leader->getDistance() + rest;
-                    if (gap < leader->getLen()) {
-                        targetLeader = leader;
-                        leaderGap = rest - (leader->getLen() - gap);
-                    }
-                }
-            }
-        }else{
-            leaderGap = targetLeader->getDistance() - vehicle->getDistance() - targetLeader->getLen();
-        }
-
-        targetFollower = target->getVehicleBeforeDistance(vehicle->getDistance(), vehicle->getSegmentIndex());
-
-        //TODO : potential bug here: a vehicle entering the lane is too close.
-
-        if (targetFollower)
-            followerGap = vehicle->getDistance() - targetFollower->getDistance() - vehicle->getLen();
-        else
-            followerGap = std::numeric_limits<double>::max();
-    }
-
-    double LaneChange::gapBefore() const {
-        return followerGap;
-    }
-
-
-    double LaneChange::gapAfter() const {
-        return leaderGap;
-    }
-
-    void LaneChange::insertShadow(Vehicle *shadow) {
-
-        assert(!changing);
-        assert(vehicle->getOffset() == 0);
-        changing = true;
-        waitingTime = 0;
-
-        assert(vehicle->getCurDrivable()->isLane());
-        Lane *targetLane = signalSend->target;
-        int  segId = vehicle->getSegmentIndex();
-        auto targetSeg = targetLane->getSegment(segId);
-        auto followerItr = (vehicle->getListIterator());
-        followerItr++;
-
-        shadow->setParent(vehicle);
-        vehicle->setShadow(shadow);
-        shadow->controllerInfo.blocker = nullptr;
-        shadow->controllerInfo.drivable = targetLane;
-        shadow->controllerInfo.router.update();
-
-        auto targetFollowerItr = targetFollower ?  targetFollower->getListIterator() : targetLane->getVehicles().end();
-
-        auto newItr = targetLane->getVehicles().insert(targetFollowerItr, shadow);
-
-        targetSeg->insertVehicle(newItr);
-
-        shadow->updateLeaderAndGap(targetLeader);
-        if (targetFollower)
-            targetFollower->updateLeaderAndGap(shadow);
-
-
-    }
-
-    int LaneChange::getDirection() {
-        if (!vehicle->getCurDrivable()->isLane()) return 0;
-        Lane *curLane  = dynamic_cast<Lane *>(vehicle->getCurDrivable());
-        if (!signalSend) return 0;
-        if (!signalSend->target) return 0;
-        if (signalSend->target == curLane->getOuterLane()) return 1;
-        if (signalSend->target == curLane->getInnerLane()) return -1;
-        return 0;
-
-    }
-
-    void LaneChange::finishChanging() {
-        changing = false;
-        finished = true;
-        lastChangeTime = vehicle->engine->getCurrentTime();
-        Vehicle *partner = vehicle->getPartner();
-        if (!partner->isReal())
-            partner->setId(vehicle->getId());
-        partner->laneChangeInfo.partnerType = 0;
-        partner->laneChangeInfo.offset = 0;
-        partner->laneChangeInfo.partner = nullptr;
-        vehicle->laneChangeInfo.partner = nullptr;
-        clearSignal();
-    }
-
-    void LaneChange::clearSignal() {
-        targetLeader = nullptr;
-        targetFollower = nullptr;
-        if (signalSend)
-            lastDir = signalSend->direction;
-        else
-            lastDir = 0;
-        if (changing) return;
-        signalSend = nullptr;
-        signalRecv = nullptr;
-    }
-
-    void LaneChange::abortChanging() {
-        Vehicle *partner = vehicle->getPartner();
-        partner->laneChange->changing = false;
-        partner->laneChangeInfo.partnerType = 0;
-        partner->laneChangeInfo.offset = 0;
-        partner->laneChangeInfo.partner = nullptr;
-        clearSignal();
-    }
-
-
-    void SimpleLaneChange::makeSignal(double interval) {
-        if (changing) return;
-        if (vehicle->engine->getCurrentTime() - lastChangeTime < coolingTime) return;
-        signalSend = std::make_shared<Signal>();
-        signalSend->source = vehicle;
-        if (vehicle->getCurDrivable()->isLane()) {
-            Lane *curLane = (Lane *)vehicle->getCurDrivable();
-
-            if (curLane->getLength() - vehicle->getDistance() < 30) return;
-            double curEst = vehicle->getGap();
-            double outerEst = 0;
-            double expectedGap = 2 * vehicle->getLen() + 4 * interval * vehicle->getMaxSpeed();
-            if (vehicle->getGap() > expectedGap || vehicle->getGap() < 1.5 * vehicle->getLen()) return;
-
-            Router &router = vehicle->controllerInfo.router;
-            if (curLane->getLaneIndex() < curLane->getBelongRoad()->getLanes().size() - 1){
-                if (router.onLastRoad() || router.getNextDrivable(curLane->getOuterLane())) {
-                    outerEst = estimateGap(curLane->getOuterLane());
-                    if (outerEst > curEst + vehicle->getLen())
-                        signalSend->target = curLane->getOuterLane();
-                }
-            }
-
-            if (curLane->getLaneIndex() > 0){
-                if (router.onLastRoad() || router.getNextDrivable(curLane->getInnerLane())) {
-                    double innerEst = estimateGap(curLane->getInnerLane());
-                    if (innerEst > curEst + vehicle->getLen() && innerEst > outerEst)
-                        signalSend->target = curLane->getInnerLane();
-                }
-            }
-            signalSend->urgency = 1;
-        }
-        LaneChange::makeSignal(interval);
-    }
-
-    double SimpleLaneChange::yieldSpeed(double interval) {
-        if (planChange()) waitingTime += interval;
-        if (signalRecv) {
-            if (vehicle == signalRecv->source->getTargetLeader()) {
-                return 100;
-            } else {
-                Vehicle *source = signalRecv->source;
-                double srcSpeed = source->getSpeed();
-                double gap = source->laneChange->gapBefore() - source->laneChange->safeGapBefore();
-
-                double v = vehicle->getNoCollisionSpeed(srcSpeed, source->getMaxNegAcc(), vehicle->getSpeed(),
-                                                        vehicle->getMaxNegAcc(), gap, interval, 0);
-
-                if (v < 0) v = 100;
-                // If the follower is too fast, let it go.
-
-                return v;
-            }
-        }
-        return 100;
-    }
-
-    void SimpleLaneChange::sendSignal() {
-        if (targetLeader) targetLeader->receiveSignal(vehicle);
-        if (targetFollower) targetFollower->receiveSignal(vehicle);
-    }
-
-    double SimpleLaneChange::safeGapBefore() const {
-        return targetFollower ? targetFollower->getMinBrakeDistance() : 0;
-    }
-
-    double SimpleLaneChange::safeGapAfter() const {
-        return vehicle->getMinBrakeDistance();
-    }
-
-    double SimpleLaneChange::estimateGap(const Lane *lane) const {
-        int curSegIndex = vehicle->getSegmentIndex();
-        Vehicle *leader = lane->getVehicleAfterDistance(vehicle->getDistance(), curSegIndex);
-        if (!leader) return lane->getLength()-vehicle->getDistance();
-        else return leader->getDistance() - vehicle->getDistance() - leader->getLen();
-    }
-
-}
\ No newline at end of file
+      }
+    }
+  } else {
+    leaderGap = targetLeader->getDistance() - vehicle->getDistance() -
+                targetLeader->getLen();
+  }
+
+  targetFollower = target->getVehicleBeforeDistance(vehicle->getDistance(),
+                                                    vehicle->getSegmentIndex());
+
+  // TODO : potential bug here: a vehicle entering the lane is too close.
+
+  if (targetFollower)
+    followerGap = vehicle->getDistance() - targetFollower->getDistance() -
+                  vehicle->getLen();
+  else
+    followerGap = std::numeric_limits<double>::max();
+}
+
+double LaneChange::gapBefore() const { return followerGap; }
+
+double LaneChange::gapAfter() const { return leaderGap; }
+
+void LaneChange::insertShadow(Vehicle *shadow) {
+
+  assert(!changing);
+  assert(vehicle->getOffset() == 0);
+  changing = true;
+  waitingTime = 0;
+
+  assert(vehicle->getCurDrivable()->isLane());
+  Lane *targetLane = signalSend->target;
+  int segId = vehicle->getSegmentIndex();
+  auto targetSeg = targetLane->getSegment(segId);
+  auto followerItr = (vehicle->getListIterator());
+  followerItr++;
+
+  shadow->setParent(vehicle);
+  vehicle->setShadow(shadow);
+  shadow->controllerInfo.blocker = nullptr;
+  shadow->controllerInfo.drivable = targetLane;
+  shadow->controllerInfo.router.update();
+
+  auto targetFollowerItr = targetFollower ? targetFollower->getListIterator()
+                                          : targetLane->getVehicles().end();
+
+  auto newItr = targetLane->getVehicles().insert(targetFollowerItr, shadow);
+
+  targetSeg->insertVehicle(newItr);
+
+  shadow->updateLeaderAndGap(targetLeader);
+  if (targetFollower)
+    targetFollower->updateLeaderAndGap(shadow);
+}
+
+int LaneChange::getDirection() {
+  if (!vehicle->getCurDrivable()->isLane())
+    return 0;
+  Lane *curLane = dynamic_cast<Lane *>(vehicle->getCurDrivable());
+  if (!signalSend)
+    return 0;
+  if (!signalSend->target)
+    return 0;
+  if (signalSend->target == curLane->getOuterLane())
+    return 1;
+  if (signalSend->target == curLane->getInnerLane())
+    return -1;
+  return 0;
+}
+
+void LaneChange::finishChanging() {
+  changing = false;
+  finished = true;
+  lastChangeTime = vehicle->engine->getCurrentTime();
+  Vehicle *partner = vehicle->getPartner();
+  if (!partner->isReal())
+    partner->setId(vehicle->getId());
+  partner->laneChangeInfo.partnerType = 0;
+  partner->laneChangeInfo.offset = 0;
+  partner->laneChangeInfo.partner = nullptr;
+  vehicle->laneChangeInfo.partner = nullptr;
+  clearSignal();
+}
+
+void LaneChange::clearSignal() {
+  targetLeader = nullptr;
+  targetFollower = nullptr;
+  if (signalSend)
+    lastDir = signalSend->direction;
+  else
+    lastDir = 0;
+  if (changing)
+    return;
+  signalSend = nullptr;
+  signalRecv = nullptr;
+}
+
+void LaneChange::abortChanging() {
+  Vehicle *partner = vehicle->getPartner();
+  partner->laneChange->changing = false;
+  partner->laneChangeInfo.partnerType = 0;
+  partner->laneChangeInfo.offset = 0;
+  partner->laneChangeInfo.partner = nullptr;
+  clearSignal();
+}
+
+void SimpleLaneChange::makeSignal(double interval) {
+  if (changing)
+    return;
+  if (vehicle->engine->getCurrentTime() - lastChangeTime < coolingTime)
+    return;
+  signalSend = std::make_shared<Signal>();
+  signalSend->source = vehicle;
+  if (vehicle->getCurDrivable()->isLane()) {
+    Lane *curLane = (Lane *)vehicle->getCurDrivable();
+
+    if (curLane->getLength() - vehicle->getDistance() < 30)
+      return;
+    double curEst = vehicle->getGap();
+    double outerEst = 0;
+    double expectedGap =
+        2 * vehicle->getLen() + 4 * interval * vehicle->getMaxSpeed();
+    if (vehicle->getGap() > expectedGap ||
+        vehicle->getGap() < 1.5 * vehicle->getLen())
+      return;
+
+    Router &router = vehicle->controllerInfo.router;
+    if (curLane->getLaneIndex() <
+        curLane->getBelongRoad()->getLanes().size() - 1) {
+      if (router.onLastRoad() ||
+          router.getNextDrivable(curLane->getOuterLane())) {
+        outerEst = estimateGap(curLane->getOuterLane());
+        if (outerEst > curEst + vehicle->getLen())
+          signalSend->target = curLane->getOuterLane();
+      }
+    }
+
+    if (curLane->getLaneIndex() > 0) {
+      if (router.onLastRoad() ||
+          router.getNextDrivable(curLane->getInnerLane())) {
+        double innerEst = estimateGap(curLane->getInnerLane());
+        if (innerEst > curEst + vehicle->getLen() && innerEst > outerEst)
+          signalSend->target = curLane->getInnerLane();
+      }
+    }
+    signalSend->urgency = 1;
+  }
+  LaneChange::makeSignal(interval);
+}
+
+double SimpleLaneChange::yieldSpeed(double interval) {
+  if (planChange())
+    waitingTime += interval;
+  if (signalRecv) {
+    if (vehicle == signalRecv->source->getTargetLeader()) {
+      return 100;
+    } else {
+      Vehicle *source = signalRecv->source;
+      double srcSpeed = source->getSpeed();
+      double gap =
+          source->laneChange->gapBefore() - source->laneChange->safeGapBefore();
+
+      double v = vehicle->getNoCollisionSpeed(
+          srcSpeed, source->getMaxNegAcc(), vehicle->getSpeed(),
+          vehicle->getMaxNegAcc(), gap, interval, 0);
+
+      if (v < 0)
+        v = 100;
+      // If the follower is too fast, let it go.
+
+      return v;
+    }
+  }
+  return 100;
+}
+
+void SimpleLaneChange::sendSignal() {
+  if (targetLeader)
+    targetLeader->receiveSignal(vehicle);
+  if (targetFollower)
+    targetFollower->receiveSignal(vehicle);
+}
+
+double SimpleLaneChange::safeGapBefore() const {
+  return targetFollower ? targetFollower->getMinBrakeDistance() : 0;
+}
+
+double SimpleLaneChange::safeGapAfter() const {
+  return vehicle->getMinBrakeDistance();
+}
+
+double SimpleLaneChange::estimateGap(const Lane *lane) const {
+  int curSegIndex = vehicle->getSegmentIndex();
+  Vehicle *leader =
+      lane->getVehicleAfterDistance(vehicle->getDistance(), curSegIndex);
+  if (!leader)
+    return lane->getLength() - vehicle->getDistance();
+  else
+    return leader->getDistance() - vehicle->getDistance() - leader->getLen();
+}
+
+} // namespace CityFlow
\ No newline at end of file
diff --git a/src/vehicle/lanechange.h b/src/vehicle/lanechange.h
index b78c590..f94c31e 100644
--- a/src/vehicle/lanechange.h
+++ b/src/vehicle/lanechange.h
@@ -7,111 +7,112 @@
 
 namespace CityFlow {
 
-    class Vehicle;
-    class Lane;
+class Vehicle;
+class Lane;
 
-    class LaneChange {
-        friend class Vehicle;
-        friend class Archive;
-    //The interface of lane changing
-     protected:
-        struct Signal{
-            int urgency;
-            int direction; // -1 for left , 1 for right, 0 for unchanged
-            Lane * target;
-            Vehicle * source;
-            int response = 0;
-            double extraSpace = 0;
-        };
+class LaneChange {
+  friend class Vehicle;
+  friend class Archive;
+  // The interface of lane changing
+protected:
+  struct Signal {
+    int urgency;
+    int direction; // -1 for left , 1 for right, 0 for unchanged
+    Lane *target;
+    Vehicle *source;
+    int response = 0;
+    double extraSpace = 0;
+  };
 
-        int lastDir;
+  int lastDir;
 
-        std::shared_ptr<Signal> signalRecv;
-        std::shared_ptr<Signal> signalSend;
+  std::shared_ptr<Signal> signalRecv;
+  std::shared_ptr<Signal> signalSend;
 
-        Vehicle * vehicle;
-        Vehicle * targetLeader = nullptr;
-        Vehicle * targetFollower = nullptr;
+  Vehicle *vehicle;
+  Vehicle *targetLeader = nullptr;
+  Vehicle *targetFollower = nullptr;
 
-        double leaderGap;
-        double followerGap;
-        double waitingTime = 0;
+  double leaderGap;
+  double followerGap;
+  double waitingTime = 0;
 
-        bool changing = false;
-        bool finished = false;
-        double lastChangeTime = 0;
+  bool changing = false;
+  bool finished = false;
+  double lastChangeTime = 0;
 
-        static constexpr double coolingTime = 3;
+  static constexpr double coolingTime = 3;
 
-    public:
-        LaneChange(Vehicle * vehicle, const LaneChange &other);
+public:
+  LaneChange(Vehicle *vehicle, const LaneChange &other);
 
-        explicit LaneChange(Vehicle * vehicle) : vehicle(vehicle) {};
+  explicit LaneChange(Vehicle *vehicle) : vehicle(vehicle){};
 
-        virtual ~LaneChange() = default;
+  virtual ~LaneChange() = default;
 
-        void updateLeaderAndFollower();
+  void updateLeaderAndFollower();
 
-        Lane *getTarget() const;
+  Lane *getTarget() const;
 
-        Vehicle *getTargetLeader() const {
-            return targetLeader;
-        }
+  Vehicle *getTargetLeader() const { return targetLeader; }
 
-        Vehicle *getTargetFollower() const {
-            return targetFollower;
-        }
+  Vehicle *getTargetFollower() const { return targetFollower; }
 
-        double gapBefore() const ;
+  double gapBefore() const;
 
-        double gapAfter() const ;
+  double gapAfter() const;
 
-        void insertShadow(Vehicle *shadow) ;
+  void insertShadow(Vehicle *shadow);
 
-        virtual double safeGapBefore() const = 0;
-        virtual double safeGapAfter() const = 0;
+  virtual double safeGapBefore() const = 0;
+  virtual double safeGapAfter() const = 0;
 
-        virtual void makeSignal(double interval) { if (signalSend) signalSend->direction = getDirection(); };
+  virtual void makeSignal(double interval) {
+    if (signalSend)
+      signalSend->direction = getDirection();
+  };
 
-        bool planChange() const;
+  bool planChange() const;
 
-        bool canChange() const { return signalSend && !signalRecv; }
+  bool canChange() const { return signalSend && !signalRecv; }
 
-        bool isGapValid() const { return gapAfter() >= safeGapAfter() && gapBefore() >= safeGapBefore(); }
+  bool isGapValid() const {
+    return gapAfter() >= safeGapAfter() && gapBefore() >= safeGapBefore();
+  }
 
-        void finishChanging();
+  void finishChanging();
 
-        void abortChanging();
+  void abortChanging();
 
-        virtual double yieldSpeed(double interval) = 0;
+  virtual double yieldSpeed(double interval) = 0;
 
-        virtual void sendSignal() = 0;
+  virtual void sendSignal() = 0;
 
-        int getDirection();
+  int getDirection();
 
-        void clearSignal();
+  void clearSignal();
 
-        bool hasFinished() const { return this->finished; }
+  bool hasFinished() const { return this->finished; }
+};
 
-    };
+class SimpleLaneChange : public LaneChange {
+private:
+  double estimateGap(const Lane *lane) const;
 
-    class SimpleLaneChange : public LaneChange {
-    private:
-        double estimateGap(const Lane *lane) const;
-    public:
-        explicit SimpleLaneChange(Vehicle * vehicle) : LaneChange(vehicle) {};
-        explicit SimpleLaneChange(Vehicle * vehicle, const LaneChange &other) : LaneChange(vehicle, other) {};
+public:
+  explicit SimpleLaneChange(Vehicle *vehicle) : LaneChange(vehicle){};
+  explicit SimpleLaneChange(Vehicle *vehicle, const LaneChange &other)
+      : LaneChange(vehicle, other){};
 
-        void makeSignal(double interval) override;
-        void sendSignal() override;
+  void makeSignal(double interval) override;
+  void sendSignal() override;
 
-        double yieldSpeed(double interval) override;
+  double yieldSpeed(double interval) override;
 
-        double safeGapBefore() const override;
+  double safeGapBefore() const override;
 
-        double safeGapAfter() const override;
+  double safeGapAfter() const override;
+};
+} // namespace CityFlow
 
-    };
-}
-
-#endif //CITYFLOW_LANECHANGE_H
+#endif // CITYFLOW_LANECHANGE_H
diff --git a/src/vehicle/router.cpp b/src/vehicle/router.cpp
index f75ea0e..1844382 100644
--- a/src/vehicle/router.cpp
+++ b/src/vehicle/router.cpp
@@ -1,272 +1,309 @@
 #include "vehicle/router.h"
-#include "vehicle/vehicle.h"
+#include "flow/flow.h"
 #include "flow/route.h"
 #include "roadnet/roadnet.h"
+#include "vehicle/vehicle.h"
 
 #include <limits>
 #include <queue>
 #include <set>
 
 namespace CityFlow {
-    Router::Router(const Router &other) : vehicle(other.vehicle), route(other.route), anchorPoints(other.anchorPoints),
-                                          rnd(other.rnd) {
-        iCurRoad = this->route.begin();
-    }
+Router::Router(const Router &other)
+    : vehicle(other.vehicle), route(other.route),
+      anchorPoints(other.anchorPoints), rnd(other.rnd) {
+  iCurRoad = this->route.begin();
+}
 
-    Router::Router(Vehicle *vehicle, std::shared_ptr<const Route> route, std::mt19937 *rnd)
-        : vehicle(vehicle), anchorPoints(route->getRoute()), rnd(rnd) {
-        assert(this->anchorPoints.size() > 0);
-        this->route = route->getRoute();
-        iCurRoad = this->route.begin();
-    }
+Router::Router(Vehicle *vehicle, std::shared_ptr<const Route> route,
+               std::mt19937 *rnd)
+    : vehicle(vehicle), anchorPoints(route->getRoute()), rnd(rnd) {
+  assert(this->anchorPoints.size() > 0);
+  this->route = route->getRoute();
+  iCurRoad = this->route.begin();
+}
 
-    Drivable *Router::getFirstDrivable() const {
-        const std::vector<Lane *> &lanes = route[0]->getLanePointers();
-        if (route.size() == 1) {
-            return selectLane(nullptr, lanes);
-        } else {
-            std::vector<Lane *> candidateLanes;
-            for (auto lane : lanes) {
-                if (lane->getLaneLinksToRoad(route[1]).size() > 0) {
-                    candidateLanes.push_back(lane);
-                }
-            }
-            assert(candidateLanes.size() > 0);
-            return selectLane(nullptr, candidateLanes);
-        }
+Drivable *Router::getFirstDrivable() const {
+  const std::vector<Lane *> &lanes = route[0]->getLanePointers();
+  if (route.size() == 1) {
+    return selectLane(nullptr, lanes);
+  } else {
+    std::vector<Lane *> candidateLanes;
+    for (auto lane : lanes) {
+      if (lane->getLaneLinksToRoad(route[1]).size() > 0) {
+        candidateLanes.push_back(lane);
+      }
     }
+    assert(candidateLanes.size() > 0);
+    return selectLane(nullptr, candidateLanes);
+  }
+}
 
-    Drivable *Router::getNextDrivable(size_t i) const {
-        if (i < planned.size()) {
-            return planned[i];
-        } else {
-            Drivable *ret = getNextDrivable(planned.size() ? planned.back() : vehicle->getCurDrivable());
-            planned.push_back(ret);
-            return ret;
-        }
+Drivable *Router::getNextDrivable(size_t i) const {
+  if (i < planned.size()) {
+    assert(planned[i]);
+    return planned[i];
+  } else {
+    Drivable *ret = getNextDrivable(planned.size() ? planned.back()
+                                                   : vehicle->getCurDrivable());
+    if (ret) {
+      planned.push_back(ret);
     }
+    return ret;
+  }
+}
 
-    Drivable *Router::getNextDrivable(const Drivable *curDrivable) const {
-        if (curDrivable->isLaneLink()) {
-            return static_cast<const LaneLink*>(curDrivable)->getEndLane();
-        } else {
-            const Lane *curLane = static_cast<const Lane *>(curDrivable);
-            auto tmpCurRoad = iCurRoad;
-            while ((*tmpCurRoad) != curLane->getBelongRoad() && tmpCurRoad != route.end()) {
-                tmpCurRoad++;
-            }
-            assert(tmpCurRoad != route.end() && curLane->getBelongRoad() == (*tmpCurRoad));
-            if (tmpCurRoad == route.end() - 1) {
-                return nullptr;
-            } else if (tmpCurRoad == route.end() - 2) {
-                std::vector<LaneLink *> laneLinks = curLane->getLaneLinksToRoad(*(tmpCurRoad+1));
-                return selectLaneLink(curLane, laneLinks);
-            } else {
-                std::vector<LaneLink *> laneLinks = curLane->getLaneLinksToRoad(*(tmpCurRoad+1));
-                std::vector<LaneLink *> candidateLaneLinks;
-                for (auto laneLink : laneLinks) {
-                    Lane *nextLane = laneLink->getEndLane();
-                    if (nextLane->getLaneLinksToRoad(*(tmpCurRoad+2)).size()) {
-                        candidateLaneLinks.push_back(laneLink);
-                    }
-                }
-                return selectLaneLink(curLane, candidateLaneLinks);
-            }
-        }
+Drivable *Router::getNextDrivable(const Drivable *curDrivable) const {
+  if (curDrivable->isLaneLink()) {
+    // 
+    auto *curLane = static_cast<const LaneLink *>(curDrivable)->getEndLane();
+    auto tmpCurRoad = iCurRoad;
+    while ((*tmpCurRoad) != curLane->getBelongRoad() &&
+           tmpCurRoad != route.end()) {
+      tmpCurRoad++;
     }
-
-    void Router::update() {
-        const Drivable *curDrivable = vehicle->getCurDrivable();
-        if (curDrivable->isLane()) {
-            while (iCurRoad < route.end() && static_cast<const Lane*>(curDrivable)->getBelongRoad() != (*iCurRoad)) {
-                iCurRoad++;
-            }
-            assert(iCurRoad < route.end());
-        }
-        for (auto it = planned.begin(); it != planned.end();) {
-            if ((*it) != curDrivable) {
-                it = planned.erase(it);
-            } else {
-                it = planned.erase(it);
-                break;
-            }
+    assert(tmpCurRoad != route.end() &&
+           curLane->getBelongRoad() == (*tmpCurRoad));
+    if (tmpCurRoad == route.end() - 1) {
+      return curLane;
+    } else {
+      std::vector<LaneLink *> laneLinks =
+          curLane->getLaneLinksToRoad(*(tmpCurRoad + 1));
+      if (laneLinks.size()) {
+        return curLane;
+      }
+      std::vector<Lane *> ls;
+      for (auto &l : curLane->getBelongRoad()->getLanes()) {
+        if (l.getLaneLinksToRoad(*(tmpCurRoad + 1)).size()) {
+          ls.push_back(&l);
         }
+      }
+      assert(ls.size());
+      return selectLane(curLane, ls);
     }
-
-    int Router::selectLaneIndex(const Lane *curLane, const std::vector<Lane *> &lanes) const {
-        assert(lanes.size() > 0);
-        if (curLane == nullptr) {
-            return (*rnd)() % lanes.size();
-        }
-        int laneDiff = std::numeric_limits<int>::max();
-        int selected = -1;
-        for (size_t i = 0 ; i < lanes.size() ; ++i) {
-            int curLaneDiff = lanes[i]->getLaneIndex() - curLane->getLaneIndex();
-            if (abs(curLaneDiff) < laneDiff) {
-                laneDiff = abs(curLaneDiff);
-                selected = i;
-            }
-        }
-        return selected;
+  } else {
+    const Lane *curLane = static_cast<const Lane *>(curDrivable);
+    auto tmpCurRoad = iCurRoad;
+    while ((*tmpCurRoad) != curLane->getBelongRoad() &&
+           tmpCurRoad != route.end()) {
+      tmpCurRoad++;
     }
-
-    Lane *Router::selectLane(const Lane *curLane, const std::vector<Lane *> &lanes) const {
-        if (lanes.size() == 0) {
-            return nullptr;
-        }
-        return lanes[selectLaneIndex(curLane, lanes)];
+    assert(tmpCurRoad != route.end());
+    assert(curLane->getBelongRoad() == (*tmpCurRoad));
+    if (tmpCurRoad == route.end() - 1) {
+      return nullptr;
+    } else {
+      std::vector<LaneLink *> laneLinks =
+          curLane->getLaneLinksToRoad(*(tmpCurRoad + 1));
+      assert(laneLinks.size());
+      return selectLaneLink(curLane, laneLinks);
     }
+  }
+}
 
-    LaneLink *Router::selectLaneLink(const Lane *curLane, const std::vector<LaneLink*> &laneLinks) const {
-        if (laneLinks.size() == 0) {
-            return nullptr;
-        }
-        std::vector<Lane *> lanes;
-        for (auto laneLink : laneLinks) {
-            lanes.push_back(laneLink->getEndLane());
-        }
-        return laneLinks[selectLaneIndex(curLane, lanes)];
+void Router::update() {
+  const Drivable *curDrivable = vehicle->getCurDrivable();
+  if (curDrivable->isLane()) {
+    while (iCurRoad < route.end() &&
+           static_cast<const Lane *>(curDrivable)->getBelongRoad() !=
+               (*iCurRoad)) {
+      iCurRoad++;
     }
-
-    bool Router::isLastRoad(const Drivable *drivable) const {
-        if (drivable->isLaneLink()) return false;
-        return static_cast<const Lane*>(drivable)->getBelongRoad() == route.back();
+    assert(iCurRoad < route.end());
+  }
+  for (auto it = planned.begin(); it != planned.end();) {
+    if ((*it) != curDrivable) {
+      it = planned.erase(it);
+    } else {
+      it = planned.erase(it);
+      break;
     }
+  }
+}
 
-    bool Router::onLastRoad() const {
-        return isLastRoad(vehicle->getCurDrivable());
+int Router::selectLaneIndex(const Lane *curLane,
+                            const std::vector<Lane *> &lanes) const {
+  assert(lanes.size() > 0);
+  if (curLane == nullptr) {
+    return (*rnd)() % lanes.size();
+  }
+  int laneDiff = std::numeric_limits<int>::max();
+  int selected = -1;
+  for (size_t i = 0; i < lanes.size(); ++i) {
+    int curLaneDiff = lanes[i]->getLaneIndex() - curLane->getLaneIndex();
+    if (abs(curLaneDiff) < laneDiff) {
+      laneDiff = abs(curLaneDiff);
+      selected = i;
     }
+  }
+  return selected;
+}
 
-    Lane *Router::getValidLane(const Lane *curLane)  const {
-        if (isLastRoad(curLane)) return nullptr;
-        auto nextRoad = iCurRoad;
-        nextRoad++;
+Lane *Router::selectLane(const Lane *curLane,
+                         const std::vector<Lane *> &lanes) const {
+  if (lanes.size() == 0) {
+    return nullptr;
+  }
+  return lanes[selectLaneIndex(curLane, lanes)];
+}
 
-        int min_diff = curLane->getBelongRoad()->getLanes().size();
-        Lane * chosen = nullptr;
-        for (auto lane : curLane->getBelongRoad()->getLanePointers()){
-            int curLaneDiff = lane->getLaneIndex() - curLane->getLaneIndex();
-            if (lane->getLaneLinksToRoad(*nextRoad).size() > 0 &&
-            abs(curLaneDiff) < min_diff){
-                min_diff = abs(curLaneDiff);
-                chosen = lane;
-            }
-        }
-        assert(chosen->getBelongRoad() == curLane->getBelongRoad());
-        return chosen;
-    }
+LaneLink *
+Router::selectLaneLink(const Lane *curLane,
+                       const std::vector<LaneLink *> &laneLinks) const {
+  if (laneLinks.size() == 0) {
+    return nullptr;
+  }
+  std::vector<Lane *> lanes;
+  for (auto laneLink : laneLinks) {
+    lanes.push_back(laneLink->getEndLane());
+  }
+  return laneLinks[selectLaneIndex(curLane, lanes)];
+}
 
+bool Router::isLastRoad(const Drivable *drivable) const {
+  if (drivable->isLaneLink())
+    return false;
+  return static_cast<const Lane *>(drivable)->getBelongRoad() == route.back();
+}
 
-    bool Router::dijkstra(Road *start, Road *end, std::vector<Road *> &buffer) {
-        std::map<Road *, double> dis;
-        std::map<Road *, Road *> from;
-        std::set<Road *>         visited;
-        bool success = false;
-        using pair = std::pair<Road *, double>;
+bool Router::onLastRoad() const {
+  return isLastRoad(vehicle->getCurDrivable());
+}
 
-        auto cmp = [](const pair &a, const pair &b){ return a.second > b.second; };
+Lane *Router::getValidLane(const Lane *curLane) const {
+  if (isLastRoad(curLane))
+    return nullptr;
+  auto nextRoad = iCurRoad;
+  nextRoad++;
 
-        std::priority_queue<pair, std::vector<pair>,decltype(cmp) > queue(cmp);
+  int min_diff = curLane->getBelongRoad()->getLanes().size();
+  Lane *chosen = nullptr;
+  for (auto lane : curLane->getBelongRoad()->getLanePointers()) {
+    int curLaneDiff = lane->getLaneIndex() - curLane->getLaneIndex();
+    if (lane->getLaneLinksToRoad(*nextRoad).size() > 0 &&
+        abs(curLaneDiff) < min_diff) {
+      min_diff = abs(curLaneDiff);
+      chosen = lane;
+    }
+  }
+  assert(chosen->getBelongRoad() == curLane->getBelongRoad());
+  return chosen;
+}
 
-        dis[start] = 0;
-        queue.push(std::make_pair(start, 0));
-        while (!queue.empty()) {
-            auto curRoad = queue.top().first;
-            if (curRoad == end) {
-                success = true;
-                break;
-            }
-            queue.pop();
-            if (visited.count(curRoad)) continue;
-            visited.insert(curRoad);
-            double curDis = dis.find(curRoad)->second;
-            dis[curRoad] = curDis;
-            for (const auto &adjRoad : curRoad->getEndIntersection().getRoads()) {
-                if (!curRoad->connectedToRoad(adjRoad)) continue;
-                auto iter = dis.find(adjRoad);
-                double newDis;
+bool Router::dijkstra(Road *start, Road *end, std::vector<Road *> &buffer) {
+  std::map<Road *, double> dis;
+  std::map<Road *, Road *> from;
+  std::set<Road *> visited;
+  bool success = false;
+  using pair = std::pair<Road *, double>;
 
-                switch (type) {
-                    case RouterType::LENGTH:
-                        newDis = curDis + adjRoad->averageLength();
-                        break;
-                    case RouterType::DURATION: {
-                        double avgDur;
-                        avgDur = adjRoad->getAverageDuration();
-                        if (avgDur < 0) {
-                            avgDur = adjRoad->getLength() / vehicle->getMaxSpeed();
-                        }
-                        newDis = curDis + avgDur;
-                    }
-                        break;
-                    default:
-                        assert(false); // under construction
-                        break;
-                }
+  auto cmp = [](const pair &a, const pair &b) { return a.second > b.second; };
 
-                if (iter == dis.end() || newDis < iter->second) {
-                    from[adjRoad] = curRoad;
-                    dis[adjRoad]  = newDis;
-                    queue.emplace(std::make_pair(adjRoad, newDis));
-                }
-            }
-        }
+  std::priority_queue<pair, std::vector<pair>, decltype(cmp)> queue(cmp);
 
-        std::vector<Road *> path;
-        path.push_back(end);
+  dis[start] = 0;
+  queue.push(std::make_pair(start, 0));
+  while (!queue.empty()) {
+    auto curRoad = queue.top().first;
+    if (curRoad == end) {
+      success = true;
+      break;
+    }
+    queue.pop();
+    if (visited.count(curRoad))
+      continue;
+    visited.insert(curRoad);
+    double curDis = dis.find(curRoad)->second;
+    dis[curRoad] = curDis;
+    for (const auto &adjRoad : curRoad->getEndIntersection().getRoads()) {
+      if (!curRoad->connectedToRoad(adjRoad))
+        continue;
+      auto iter = dis.find(adjRoad);
+      double newDis;
 
-        auto iter = from.find(end);
-        while (iter != from.end() && iter->second != start) {
-            path.emplace_back(iter->second);
-            iter = from.find(iter->second);
+      switch (type) {
+      case RouterType::LENGTH:
+        newDis = curDis + adjRoad->averageLength();
+        break;
+      case RouterType::DURATION: {
+        double avgDur;
+        avgDur = adjRoad->getAverageDuration();
+        if (avgDur < 0) {
+          avgDur = adjRoad->getLength() / vehicle->getMaxSpeed();
         }
+        newDis = curDis + avgDur;
+      } break;
+      default:
+        assert(false); // under construction
+        break;
+      }
 
-        buffer.insert(buffer.end(), path.rbegin(), path.rend());
-        return success;
+      if (iter == dis.end() || newDis < iter->second) {
+        from[adjRoad] = curRoad;
+        dis[adjRoad] = newDis;
+        queue.emplace(std::make_pair(adjRoad, newDis));
+      }
     }
+  }
 
-    bool Router::updateShortestPath() {
-        //Dijkstra
-        planned.clear();
-        route.clear();
-        route.push_back(anchorPoints[0]);
-        for (size_t i = 1 ; i < anchorPoints.size() ; ++i){
-            if (anchorPoints[i - 1] == anchorPoints[i])
-                continue;
-            if (!dijkstra(anchorPoints[i - 1], anchorPoints[i], route))
-                return false;
-        }
-        if (route.size() <= 1)
-            return false;
-        iCurRoad = this->route.begin();
-        return true;
-    }
+  std::vector<Road *> path;
+  path.push_back(end);
 
-    bool Router::setRoute(const std::vector<Road *> &anchor) {
-        if (vehicle->getCurDrivable()->isLaneLink()) return false;
-        Road *cur_road = *iCurRoad;
-        auto backup = std::move(anchorPoints);
-        auto backup_route = std::move(route);
-        anchorPoints.clear();
-        anchorPoints.emplace_back(cur_road);
-        anchorPoints.insert(anchorPoints.end(), anchor.begin(), anchor.end());
-        bool result = updateShortestPath();
-        if (result && onValidLane()) {
-            return true;
-        } else {
-            anchorPoints = std::move(backup);
-            route = std::move(backup_route);
-            planned.clear();
-            iCurRoad = route.begin();
-            for (iCurRoad = route.begin(); *iCurRoad != cur_road && iCurRoad != route.end(); ++iCurRoad);
-            return false;
-        }
-    }
+  auto iter = from.find(end);
+  while (iter != from.end() && iter->second != start) {
+    path.emplace_back(iter->second);
+    iter = from.find(iter->second);
+  }
 
-    std::vector<Road *> Router::getFollowingRoads() const {
-        std::vector<Road *> ret;
-        ret.insert(ret.end(), iCurRoad, route.end());
-        return ret;
-    }
+  buffer.insert(buffer.end(), path.rbegin(), path.rend());
+  return success;
+}
 
+bool Router::updateShortestPath() {
+  // Dijkstra
+  planned.clear();
+  route.clear();
+  route.push_back(anchorPoints[0]);
+  for (size_t i = 1; i < anchorPoints.size(); ++i) {
+    if (anchorPoints[i - 1] == anchorPoints[i])
+      continue;
+    if (!dijkstra(anchorPoints[i - 1], anchorPoints[i], route))
+      return false;
+  }
+  // if (route.size() <= 1)
+  //     return false;
+  iCurRoad = this->route.begin();
+  return true;
 }
+
+bool Router::setRoute(const std::vector<Road *> &anchor) {
+  if (vehicle->getCurDrivable()->isLaneLink())
+    return false;
+  Road *cur_road = *iCurRoad;
+  auto backup = std::move(anchorPoints);
+  auto backup_route = std::move(route);
+  anchorPoints.clear();
+  anchorPoints.emplace_back(cur_road);
+  anchorPoints.insert(anchorPoints.end(), anchor.begin(), anchor.end());
+  bool result = updateShortestPath();
+  if (result && onValidLane()) {
+    return true;
+  } else {
+    anchorPoints = std::move(backup);
+    route = std::move(backup_route);
+    planned.clear();
+    iCurRoad = route.begin();
+    for (iCurRoad = route.begin();
+         *iCurRoad != cur_road && iCurRoad != route.end(); ++iCurRoad)
+      ;
+    return false;
+  }
+}
+
+std::vector<Road *> Router::getFollowingRoads() const {
+  std::vector<Road *> ret;
+  ret.insert(ret.end(), iCurRoad, route.end());
+  return ret;
+}
+
+} // namespace CityFlow
diff --git a/src/vehicle/router.h b/src/vehicle/router.h
index b425f75..ea57876 100644
--- a/src/vehicle/router.h
+++ b/src/vehicle/router.h
@@ -3,84 +3,82 @@
 
 #include "engine/archive.h"
 
-#include <vector>
-#include <random>
 #include <memory>
+#include <random>
+#include <vector>
 
 namespace CityFlow {
-    class Road;
-    class Drivable;
-    class Route;
-    class Lane;
-    class LaneLink;
-    class Vehicle;
+class Road;
+class Drivable;
+class Route;
+class Lane;
+class LaneLink;
+class Vehicle;
+
+class Router {
+  friend Archive;
 
-    class Router {
-    friend Archive;
-    private:
-        
-        Vehicle* vehicle = nullptr;
-        std::vector<Road *> route;
-        std::vector<Road *> anchorPoints;
-        std::vector<Road *>::const_iterator iCurRoad;
-        std::mt19937 *rnd = nullptr;
+private:
+  Vehicle *vehicle = nullptr;
+  std::vector<Road *> anchorPoints;
+  std::mt19937 *rnd = nullptr;
 
-        mutable std::deque<Drivable *> planned;
-        
-        int selectLaneIndex(const Lane *curLane, const std::vector<Lane *> &lanes) const;
+  mutable std::deque<Drivable *> planned;
 
-        LaneLink *selectLaneLink(const Lane *curLane, const std::vector<LaneLink*> &laneLinks) const;
+  int selectLaneIndex(const Lane *curLane,
+                      const std::vector<Lane *> &lanes) const;
 
-        Lane *selectLane(const Lane *curLane, const std::vector<Lane *> &lanes) const;
+  LaneLink *selectLaneLink(const Lane *curLane,
+                           const std::vector<LaneLink *> &laneLinks) const;
 
-        enum class RouterType{
-            LENGTH,
-            DURATION,
-            DYNAMIC // TODO: dynamic routing
-        };
+  Lane *selectLane(const Lane *curLane, const std::vector<Lane *> &lanes) const;
 
-        RouterType type = RouterType::LENGTH;
+  enum class RouterType {
+    LENGTH,
+    DURATION,
+    DYNAMIC // TODO: dynamic routing
+  };
 
-    public:
+  RouterType type = RouterType::LENGTH;
 
-        Router(const Router &other);
+public:
+  std::vector<Road *> route;
+  std::vector<Road *>::const_iterator iCurRoad;
+  Router(const Router &other);
 
-        Router(Vehicle *vehicle, std::shared_ptr<const Route> route, std::mt19937 *rnd);
+  Router(Vehicle *vehicle, std::shared_ptr<const Route> route,
+         std::mt19937 *rnd);
 
-        Road *getFirstRoad() {
-            return anchorPoints[0];
-        }
+  Road *getFirstRoad() { return anchorPoints[0]; }
 
-        Drivable *getFirstDrivable() const;
+  Drivable *getFirstDrivable() const;
 
-        Drivable *getNextDrivable(size_t i = 0) const;
+  Drivable *getNextDrivable(size_t i = 0) const;
 
-        Drivable *getNextDrivable(const Drivable *curDrivable) const;
+  Drivable *getNextDrivable(const Drivable *curDrivable) const;
 
-        void update();
+  void update();
 
-        bool isLastRoad(const Drivable *drivable) const;
+  bool isLastRoad(const Drivable *drivable) const;
 
-        bool onLastRoad() const;
+  bool onLastRoad() const;
 
-        bool onValidLane()  const{
-            return !(getNextDrivable() == nullptr && !onLastRoad());
-        }
+  bool onValidLane() const {
+    return !(getNextDrivable() == nullptr && !onLastRoad());
+  }
 
-        Lane * getValidLane(const Lane *curLane) const;
+  Lane *getValidLane(const Lane *curLane) const;
 
-        void setVehicle(Vehicle *vehicle) {
-            this->vehicle = vehicle;
-        }
+  void setVehicle(Vehicle *vehicle) { this->vehicle = vehicle; }
 
-        bool dijkstra(Road *start, Road *end, std::vector<Road *> &buffer);
+  bool dijkstra(Road *start, Road *end, std::vector<Road *> &buffer);
 
-        bool updateShortestPath();
+  bool updateShortestPath();
 
-        bool setRoute(const std::vector<Road *> &anchor);
+  bool setRoute(const std::vector<Road *> &anchor);
 
-        std::vector<Road *> getFollowingRoads() const;
-    };
-}
+  std::vector<Road *> getFollowingRoads() const;
+};
+} // namespace CityFlow
 
 #endif
\ No newline at end of file
diff --git a/src/vehicle/vehicle.cpp b/src/vehicle/vehicle.cpp
index a63391d..e3210a8 100644
--- a/src/vehicle/vehicle.cpp
+++ b/src/vehicle/vehicle.cpp
@@ -7,452 +7,502 @@
 
 namespace CityFlow {
 
-    Vehicle::ControllerInfo::ControllerInfo(Vehicle *vehicle, std::shared_ptr<const Route> route, std::mt19937 *rnd)
-        : router(vehicle, route, rnd) {
-        enterLaneLinkTime = std::numeric_limits<int>::max();
-    }
-
-    Vehicle::ControllerInfo::ControllerInfo(Vehicle *vehicle, const Vehicle::ControllerInfo &other): ControllerInfo(other) {
-        router.setVehicle(vehicle);
-    }
+Vehicle::ControllerInfo::ControllerInfo(Vehicle *vehicle,
+                                        std::shared_ptr<const Route> route,
+                                        std::mt19937 *rnd)
+    : router(vehicle, route, rnd) {
+  enterLaneLinkTime = std::numeric_limits<int>::max();
+}
 
-    Vehicle::Vehicle(const Vehicle &vehicle, Flow *flow)
-        : vehicleInfo(vehicle.vehicleInfo), controllerInfo(this, vehicle.controllerInfo),
-          laneChangeInfo(vehicle.laneChangeInfo), buffer(vehicle.buffer), priority(vehicle.priority),
-          id(vehicle.id), engine(vehicle.engine),
-          laneChange(std::make_shared<SimpleLaneChange>(this, *vehicle.laneChange)),
-          flow(flow){
-        enterTime = vehicle.enterTime;
-    }
+Vehicle::ControllerInfo::ControllerInfo(Vehicle *vehicle,
+                                        const Vehicle::ControllerInfo &other)
+    : ControllerInfo(other) {
+  router.setVehicle(vehicle);
+}
 
-    Vehicle::Vehicle(const Vehicle &vehicle, const std::string &id, Engine *engine, Flow *flow)
-        : vehicleInfo(vehicle.vehicleInfo), controllerInfo(this, vehicle.controllerInfo),
-          laneChangeInfo(vehicle.laneChangeInfo), buffer(vehicle.buffer), 
-          id(id), engine(engine), laneChange(std::make_shared<SimpleLaneChange>(this)),
-          flow(flow){
-        while (engine->checkPriority(priority = engine->rnd()));
-        controllerInfo.router.setVehicle(this);
-        enterTime = vehicle.enterTime;
-    }
+Vehicle::Vehicle(const Vehicle &vehicle, Flow *flow)
+    : vehicleInfo(vehicle.vehicleInfo),
+      controllerInfo(this, vehicle.controllerInfo),
+      laneChangeInfo(vehicle.laneChangeInfo), buffer(vehicle.buffer),
+      priority(vehicle.priority), id(vehicle.id), engine(vehicle.engine),
+      laneChange(std::make_shared<SimpleLaneChange>(this, *vehicle.laneChange)),
+      flow(flow) {
+  enterTime = vehicle.enterTime;
+}
 
-    Vehicle::Vehicle(const VehicleInfo &vehicleInfo, const std::string &id, Engine *engine, Flow *flow)
-        : vehicleInfo(vehicleInfo), controllerInfo(this, vehicleInfo.route, &(engine->rnd)),
-          id(id), engine(engine), laneChange(std::make_shared<SimpleLaneChange>(this)),
-          flow(flow){
-        controllerInfo.approachingIntersectionDistance =
-            vehicleInfo.maxSpeed * vehicleInfo.maxSpeed / vehicleInfo.usualNegAcc / 2 +
-            vehicleInfo.maxSpeed * engine->getInterval() * 2;
-        while (engine->checkPriority(priority = engine->rnd()));
-        enterTime = engine->getCurrentTime();
-    }
+Vehicle::Vehicle(const Vehicle &vehicle, const std::string &id, Engine *engine,
+                 Flow *flow)
+    : vehicleInfo(vehicle.vehicleInfo),
+      controllerInfo(this, vehicle.controllerInfo),
+      laneChangeInfo(vehicle.laneChangeInfo), buffer(vehicle.buffer), id(id),
+      engine(engine), laneChange(std::make_shared<SimpleLaneChange>(this)),
+      flow(flow) {
+  while (engine->checkPriority(priority = engine->rnd()))
+    ;
+  controllerInfo.router.setVehicle(this);
+  enterTime = vehicle.enterTime;
+}
 
-    void Vehicle::setDeltaDistance(double dis) {
-        if (!buffer.isDisSet || dis < buffer.deltaDis) {
-            unSetEnd();
-            unSetDrivable();
-            buffer.deltaDis = dis;
-            dis = dis + controllerInfo.dis;
-            Drivable *drivable = getCurDrivable();
-            for (int i = 0; drivable && dis > drivable->getLength(); ++i) {
-                dis -= drivable->getLength();
-                Drivable *nextDrivable = controllerInfo.router.getNextDrivable(i);
-                if (nextDrivable == nullptr) {
-                    assert(controllerInfo.router.isLastRoad(drivable));
-                    setEnd(true);
-                }
-                drivable = nextDrivable;
-                setDrivable(drivable);
-            }
-            setDis(dis);
-        }
-    }
+Vehicle::Vehicle(const VehicleInfo &vehicleInfo, const std::string &id,
+                 Engine *engine, Flow *flow)
+    : vehicleInfo(vehicleInfo),
+      controllerInfo(this, vehicleInfo.route, &(engine->rnd)), id(id),
+      engine(engine), laneChange(std::make_shared<SimpleLaneChange>(this)),
+      flow(flow) {
+  controllerInfo.approachingIntersectionDistance =
+      vehicleInfo.maxSpeed * vehicleInfo.maxSpeed / vehicleInfo.usualNegAcc /
+          2 +
+      vehicleInfo.maxSpeed * engine->getInterval() * 2;
+  while (engine->checkPriority(priority = engine->rnd()))
+    ;
+  enterTime = engine->getCurrentTime();
+}
 
-    void Vehicle::setSpeed(double speed) {
-        buffer.speed = speed;
-        buffer.isSpeedSet = true;
+void Vehicle::setDeltaDistance(double dis) {
+  if (!buffer.isDisSet || dis < buffer.deltaDis) {
+    unSetEnd();
+    unSetDrivable();
+    buffer.deltaDis = dis;
+    dis = dis + controllerInfo.dis;
+    Drivable *drivable = getCurDrivable();
+    for (int i = 0; drivable && dis > drivable->getLength(); ++i) {
+      dis -= drivable->getLength();
+      Drivable *nextDrivable = controllerInfo.router.getNextDrivable(i);
+      if (nextDrivable == nullptr) {
+        assert(controllerInfo.router.isLastRoad(drivable));
+        setEnd(true);
+      }
+      drivable = nextDrivable;
+      setDrivable(drivable);
     }
+    setDis(dis);
+  }
+}
 
-    Drivable *Vehicle::getChangedDrivable() const {
-        if (!buffer.isDrivableSet)
-            return nullptr;
-        return buffer.drivable;
-    }
+void Vehicle::setSpeed(double speed) {
+  buffer.speed = speed;
+  buffer.isSpeedSet = true;
+}
 
-    Point Vehicle::getPoint() const {
-        if (fabs(laneChangeInfo.offset) < eps || !controllerInfo.drivable->isLane()) {
-            return controllerInfo.drivable->getPointByDistance(controllerInfo.dis);
-        } else {
-            assert(controllerInfo.drivable->isLane());
-            const Lane *lane = static_cast<const Lane*>(controllerInfo.drivable);
-            Point origin = lane->getPointByDistance(controllerInfo.dis);
-            Point next;
-            double percentage;
-            std::vector<Lane> &lans = lane->getBelongRoad()->getLanes();
-            if (laneChangeInfo.offset > 0) {
-                next = lans[lane->getLaneIndex() + 1].getPointByDistance(controllerInfo.dis);
-                percentage = 2 * laneChangeInfo.offset / (lane->getWidth() +
-                                                          lans[lane->getLaneIndex() + 1].getWidth());
-            } else {
-                next = lans[lane->getLaneIndex() - 1].getPointByDistance(controllerInfo.dis);
-                percentage = -2 * laneChangeInfo.offset / (lane->getWidth() +
-                                                           lans[lane->getLaneIndex() - 1].getWidth());
-            }
-            Point cur;
-            cur.x = next.x * percentage + origin.x * (1 - percentage);
-            cur.y = next.y * percentage + origin.y * (1 - percentage);
-            return cur;
-        }
-    }
+Drivable *Vehicle::getChangedDrivable() const {
+  if (!buffer.isDrivableSet)
+    return nullptr;
+  return buffer.drivable;
+}
 
-    void Vehicle::update() { // TODO: use something like reflection?
-        if (buffer.isEndSet) {
-            controllerInfo.end = buffer.end;
-            buffer.isEndSet = false;
-        }
-        if (buffer.isDisSet) {
-            controllerInfo.dis = buffer.dis;
-            buffer.isDisSet = false;
-        }
-        if (buffer.isSpeedSet) {
-            vehicleInfo.speed = buffer.speed;
-            buffer.isSpeedSet = false;
-        }
-        if (buffer.isCustomSpeedSet) {
-            buffer.isCustomSpeedSet = false;
-        }
-        if (buffer.isDrivableSet) {
-            controllerInfo.prevDrivable = controllerInfo.drivable;
-            controllerInfo.drivable = buffer.drivable;
-            buffer.isDrivableSet = false;
-            controllerInfo.router.update();
-        }
-        if (buffer.isEnterLaneLinkTimeSet) {
-            controllerInfo.enterLaneLinkTime = buffer.enterLaneLinkTime;
-            buffer.isEnterLaneLinkTimeSet = false;
-        }
-        if (buffer.isBlockerSet) {
-            controllerInfo.blocker = buffer.blocker;
-            buffer.isBlockerSet = false;
-        } else {
-            controllerInfo.blocker = nullptr;
-        }
-        if (buffer.isNotifiedVehicles) {
-            buffer.notifiedVehicles.clear();
-            buffer.isNotifiedVehicles = false;
-        }
-    }
+Point Vehicle::getPoint() const {
+  if (fabs(laneChangeInfo.offset) < eps || !controllerInfo.drivable->isLane()) {
+    return controllerInfo.drivable->getPointByDistance(controllerInfo.dis);
+  } else {
+    assert(controllerInfo.drivable->isLane());
+    const Lane *lane = static_cast<const Lane *>(controllerInfo.drivable);
+    Point origin = lane->getPointByDistance(controllerInfo.dis);
+    Point next;
+    double percentage;
+    std::vector<Lane> &lans = lane->getBelongRoad()->getLanes();
+    if (laneChangeInfo.offset > 0) {
+      next =
+          lans[lane->getLaneIndex() + 1].getPointByDistance(controllerInfo.dis);
+      percentage =
+          2 * laneChangeInfo.offset /
+          (lane->getWidth() + lans[lane->getLaneIndex() + 1].getWidth());
+    } else {
+      next =
+          lans[lane->getLaneIndex() - 1].getPointByDistance(controllerInfo.dis);
+      percentage =
+          -2 * laneChangeInfo.offset /
+          (lane->getWidth() + lans[lane->getLaneIndex() - 1].getWidth());
+    }
+    Point cur;
+    cur.x = next.x * percentage + origin.x * (1 - percentage);
+    cur.y = next.y * percentage + origin.y * (1 - percentage);
+    return cur;
+  }
+}
 
+void Vehicle::update() { // TODO: use something like reflection?
+  if (buffer.isEndSet) {
+    controllerInfo.end = buffer.end;
+    buffer.isEndSet = false;
+  }
+  if (buffer.isDisSet) {
+    controllerInfo.dis = buffer.dis;
+    buffer.isDisSet = false;
+  }
+  if (buffer.isSpeedSet) {
+    vehicleInfo.speed = buffer.speed;
+    buffer.isSpeedSet = false;
+  }
+  if (buffer.isCustomSpeedSet) {
+    buffer.isCustomSpeedSet = false;
+  }
+  if (buffer.isDrivableSet) {
+    controllerInfo.prevDrivable = controllerInfo.drivable;
+    controllerInfo.drivable = buffer.drivable;
+    buffer.isDrivableSet = false;
+    controllerInfo.router.update();
+  }
+  if (buffer.isEnterLaneLinkTimeSet) {
+    controllerInfo.enterLaneLinkTime = buffer.enterLaneLinkTime;
+    buffer.isEnterLaneLinkTimeSet = false;
+  }
+  if (buffer.isBlockerSet) {
+    controllerInfo.blocker = buffer.blocker;
+    buffer.isBlockerSet = false;
+  } else {
+    controllerInfo.blocker = nullptr;
+  }
+  if (buffer.isNotifiedVehicles) {
+    buffer.notifiedVehicles.clear();
+    buffer.isNotifiedVehicles = false;
+  }
+}
 
-    std::pair<Point, Point> Vehicle::getCurPos() const {
-        std::pair<Point, Point> ret;
-        ret.first = controllerInfo.drivable->getPointByDistance(controllerInfo.dis);
-        Point direction = controllerInfo.drivable->getDirectionByDistance(controllerInfo.dis);
-        Point tail(ret.first);
-        tail.x -= direction.x * vehicleInfo.len;
-        tail.y -= direction.y * vehicleInfo.len;
-        ret.second = tail;
-        return ret;
-    }
+std::pair<Point, Point> Vehicle::getCurPos() const {
+  std::pair<Point, Point> ret;
+  ret.first = controllerInfo.drivable->getPointByDistance(controllerInfo.dis);
+  Point direction =
+      controllerInfo.drivable->getDirectionByDistance(controllerInfo.dis);
+  Point tail(ret.first);
+  tail.x -= direction.x * vehicleInfo.len;
+  tail.y -= direction.y * vehicleInfo.len;
+  ret.second = tail;
+  return ret;
+}
 
-    void Vehicle::updateLeaderAndGap(Vehicle *leader) {
-        if (leader != nullptr && leader->getCurDrivable() == getCurDrivable()) {
-            controllerInfo.leader = leader;
-            controllerInfo.gap = leader->getDistance() - leader->getLen() - controllerInfo.dis;
-        } else {
-            controllerInfo.leader = nullptr;
-            Drivable *drivable = nullptr;
-            Vehicle *candidateLeader = nullptr;
-            double candidateGap = 0;
-            double dis = controllerInfo.drivable->getLength() - controllerInfo.dis;
-            for (int i = 0; ; ++i) {
-                drivable = getNextDrivable(i);
-                if (drivable == nullptr) return;
-                if (drivable->isLaneLink()) { // if laneLink, check all laneLink start from previous lane, because lanelinks may overlap 
-                    for (auto laneLink : static_cast<LaneLink *>(drivable)->getStartLane()->getLaneLinks()) {
-                        if ((candidateLeader = laneLink->getLastVehicle()) != nullptr) {
-                            candidateGap = dis + candidateLeader->getDistance() - candidateLeader->getLen();
-                            if (controllerInfo.leader == nullptr || candidateGap < controllerInfo.gap) {
-                                controllerInfo.leader = candidateLeader;
-                                controllerInfo.gap = candidateGap;
-                            }
-                        }
-                    }
-                    if (controllerInfo.leader) return;
-                } else {
-                    if ((controllerInfo.leader = drivable->getLastVehicle()) != nullptr) {
-                        controllerInfo.gap =
-                                dis + controllerInfo.leader->getDistance() - controllerInfo.leader->getLen();
-                        return;
-                    }
-                }
-
-                dis += drivable->getLength();
-                if (dis > vehicleInfo.maxSpeed * vehicleInfo.maxSpeed / vehicleInfo.usualNegAcc / 2 +
-                          vehicleInfo.maxSpeed * engine->getInterval() * 2)
-                    return;
+void Vehicle::updateLeaderAndGap(Vehicle *leader) {
+  if (leader != nullptr && leader->getCurDrivable() == getCurDrivable()) {
+    controllerInfo.leader = leader;
+    controllerInfo.gap =
+        leader->getDistance() - leader->getLen() - controllerInfo.dis;
+  } else {
+    controllerInfo.leader = nullptr;
+    Drivable *drivable = nullptr;
+    Vehicle *candidateLeader = nullptr;
+    double candidateGap = 0;
+    double dis = controllerInfo.drivable->getLength() - controllerInfo.dis;
+    for (int i = 0;; ++i) {
+      drivable = getNextDrivable(i);
+      if (drivable == nullptr)
+        return;
+      if (drivable
+              ->isLaneLink()) { // if laneLink, check all laneLink start from
+                                // previous lane, because lanelinks may overlap
+        for (auto laneLink : static_cast<LaneLink *>(drivable)
+                                 ->getStartLane()
+                                 ->getLaneLinks()) {
+          if ((candidateLeader = laneLink->getLastVehicle()) != nullptr) {
+            candidateGap = dis + candidateLeader->getDistance() -
+                           candidateLeader->getLen();
+            if (controllerInfo.leader == nullptr ||
+                candidateGap < controllerInfo.gap) {
+              controllerInfo.leader = candidateLeader;
+              controllerInfo.gap = candidateGap;
             }
-            return;
+          }
         }
-    }
-
-
-
-    double Vehicle::getNoCollisionSpeed(double vL, double dL, double vF, double dF, double gap, double interval,
-                                        double targetGap) const {
-        double c = vF * interval / 2 + targetGap - 0.5 * vL * vL / dL - gap;
-        double a = 0.5 / dF;
-        double b = 0.5 * interval;
-        if (b * b < 4 * a * c) return -100;
-        double v1 = 0.5 / a * (sqrt(b * b - 4 * a * c) - b);
-        double v2 = 2 * vL - dL * interval + 2 * (gap - targetGap) / interval;
-        return min2double(v1, v2);
-    }
-
-    // should be move to seperate CarFollowing (Controller?) class later?
-    double Vehicle::getCarFollowSpeed(double interval) {
-        Vehicle *leader = getLeader();
-        if (leader == nullptr) return hasSetCustomSpeed() ? buffer.customSpeed : vehicleInfo.maxSpeed;
-
-        // collision free
-        double v = getNoCollisionSpeed(leader->getSpeed(), leader->getMaxNegAcc(), vehicleInfo.speed,
-                                       vehicleInfo.maxNegAcc, controllerInfo.gap, interval, 0);
-
-        if (hasSetCustomSpeed())
-            return min2double(buffer.customSpeed, v);
-
-        // safe distance
-        // get relative decel (mimic real scenario)
-        double assumeDecel = 0, leaderSpeed = leader->getSpeed();
-        if (vehicleInfo.speed > leaderSpeed) {
-            assumeDecel = vehicleInfo.speed - leaderSpeed;
-        }
-        v = min2double(v, getNoCollisionSpeed(leader->getSpeed(), leader->getUsualNegAcc(), vehicleInfo.speed,
-                                              vehicleInfo.usualNegAcc, controllerInfo.gap, interval,
-                                              vehicleInfo.minGap
-                                              ));
-        v = min2double(v,
-                       (controllerInfo.gap + (leaderSpeed + assumeDecel / 2) * interval -
-                        vehicleInfo.speed * interval / 2) / (vehicleInfo.headwayTime + interval / 2));
-
-        return v;
-    }
-
-    double Vehicle::getStopBeforeSpeed(double distance, double interval) const {
-        assert(distance >= 0);
-        if (getBrakeDistanceAfterAccel(vehicleInfo.usualPosAcc, vehicleInfo.usualNegAcc, interval) < distance)
-            return vehicleInfo.speed + vehicleInfo.usualPosAcc * interval;
-        double takeInterval = 2 * distance / (vehicleInfo.speed + eps) / interval;
-        if (takeInterval >= 1) {
-            return vehicleInfo.speed - vehicleInfo.speed / (int) takeInterval;
-        } else {
-            return vehicleInfo.speed - vehicleInfo.speed / takeInterval;
+        if (controllerInfo.leader)
+          return;
+      } else {
+        if ((controllerInfo.leader = drivable->getLastVehicle()) != nullptr) {
+          controllerInfo.gap = dis + controllerInfo.leader->getDistance() -
+                               controllerInfo.leader->getLen();
+          return;
         }
-    }
+      }
 
-    int Vehicle::getReachSteps(double distance, double targetSpeed, double acc) const {
-        if (distance <= 0) {
-            return 0;
-        }
-        if (vehicleInfo.speed > targetSpeed) {
-            return std::ceil(distance / vehicleInfo.speed);
-        }
-        double distanceUntilTargetSpeed = getDistanceUntilSpeed(targetSpeed, acc);
-        double interval = engine->getInterval();
-        if (distanceUntilTargetSpeed > distance) {
-            return std::ceil((std::sqrt(
-                    vehicleInfo.speed * vehicleInfo.speed + 2 * acc * distance) - vehicleInfo.speed) / acc / interval);
-        } else {
-            return std::ceil((targetSpeed - vehicleInfo.speed) / acc / interval) + std::ceil(
-                    (distance - distanceUntilTargetSpeed) / targetSpeed / interval);
-        }
-    }
-
-    int Vehicle::getReachStepsOnLaneLink(double distance, LaneLink *laneLink) const {
-        return getReachSteps(distance, laneLink->isTurn() ? vehicleInfo.turnSpeed : vehicleInfo.maxSpeed,
-                             vehicleInfo.usualPosAcc);
+      dis += drivable->getLength();
+      if (dis > vehicleInfo.maxSpeed * vehicleInfo.maxSpeed /
+                        vehicleInfo.usualNegAcc / 2 +
+                    vehicleInfo.maxSpeed * engine->getInterval() * 2)
+        return;
     }
+    return;
+  }
+}
 
-    double Vehicle::getDistanceUntilSpeed(double speed, double acc) const {
-        if (speed <= vehicleInfo.speed) return 0;
-        double interval = engine->getInterval();
-        int stage1steps = std::floor((speed - vehicleInfo.speed) / acc / interval);
-        double stage1speed = vehicleInfo.speed + stage1steps * acc / interval;
-        double stage1dis = (vehicleInfo.speed + stage1speed) * (stage1steps * interval) / 2;
-        return stage1dis + (stage1speed < speed ? ((stage1speed + speed) * interval / 2) : 0);
-    }
+double Vehicle::getNoCollisionSpeed(double vL, double dL, double vF, double dF,
+                                    double gap, double interval,
+                                    double targetGap) const {
+  double c = vF * interval / 2 + targetGap - 0.5 * vL * vL / dL - gap;
+  double a = 0.5 / dF;
+  double b = 0.5 * interval;
+  if (b * b < 4 * a * c)
+    return -100;
+  double v1 = 0.5 / a * (sqrt(b * b - 4 * a * c) - b);
+  double v2 = 2 * vL - dL * interval + 2 * (gap - targetGap) / interval;
+  return min2double(v1, v2);
+}
 
-    bool Vehicle::canYield(double dist) const {
-        return (dist > 0 && getMinBrakeDistance() < dist - vehicleInfo.yieldDistance) ||
-               (dist < 0 && dist + vehicleInfo.len < 0);
-    }
+// should be move to seperate CarFollowing (Controller?) class later?
+double Vehicle::getCarFollowSpeed(double interval) {
+  Vehicle *leader = getLeader();
+  if (leader == nullptr)
+    return hasSetCustomSpeed() ? buffer.customSpeed : vehicleInfo.maxSpeed;
+
+  // collision free
+  double v = getNoCollisionSpeed(leader->getSpeed(), leader->getMaxNegAcc(),
+                                 vehicleInfo.speed, vehicleInfo.maxNegAcc,
+                                 controllerInfo.gap, interval, 0);
+
+  if (hasSetCustomSpeed())
+    return min2double(buffer.customSpeed, v);
+
+  // safe distance
+  // get relative decel (mimic real scenario)
+  double assumeDecel = 0, leaderSpeed = leader->getSpeed();
+  if (vehicleInfo.speed > leaderSpeed) {
+    assumeDecel = vehicleInfo.speed - leaderSpeed;
+  }
+  v = min2double(
+      v, getNoCollisionSpeed(leader->getSpeed(), leader->getUsualNegAcc(),
+                             vehicleInfo.speed, vehicleInfo.usualNegAcc,
+                             controllerInfo.gap, interval, vehicleInfo.minGap));
+  v = min2double(v, (controllerInfo.gap +
+                     (leaderSpeed + assumeDecel / 2) * interval -
+                     vehicleInfo.speed * interval / 2) /
+                        (vehicleInfo.headwayTime + interval / 2));
+
+  return v;
+}
 
-    bool Vehicle::isIntersectionRelated() {
-        if (controllerInfo.drivable->isLaneLink())
-            return true;
-        if (controllerInfo.drivable->isLane()) {
-            Drivable *drivable = getNextDrivable();
-            if (drivable && drivable->isLaneLink() && controllerInfo.drivable->getLength() - controllerInfo.dis <=
-                                                      controllerInfo.approachingIntersectionDistance) {
-                return true;
-            }
-        }
-        return false;
-    }
+double Vehicle::getStopBeforeSpeed(double distance, double interval) const {
+  if (distance <= 0) {
+    return 0;
+  }
+  if (getBrakeDistanceAfterAccel(vehicleInfo.usualPosAcc,
+                                 vehicleInfo.usualNegAcc, interval) < distance)
+    return vehicleInfo.speed + vehicleInfo.usualPosAcc * interval;
+  double takeInterval = 2 * distance / (vehicleInfo.speed + eps) / interval;
+  if (takeInterval >= 1) {
+    return vehicleInfo.speed - vehicleInfo.speed / (int)takeInterval;
+  } else {
+    return vehicleInfo.speed - vehicleInfo.speed / takeInterval;
+  }
+}
 
-    double Vehicle::getBrakeDistanceAfterAccel(double acc, double dec, double interval) const {
-        double currentSpeed = vehicleInfo.speed;
-        double nextSpeed = currentSpeed + acc * interval;
-        return (currentSpeed + nextSpeed) * interval / 2 + (nextSpeed * nextSpeed / dec / 2);
-    }
+int Vehicle::getReachSteps(double distance, double targetSpeed,
+                           double acc) const {
+  if (distance <= 0) {
+    return 0;
+  }
+  if (vehicleInfo.speed > targetSpeed) {
+    return std::ceil(distance / vehicleInfo.speed);
+  }
+  double distanceUntilTargetSpeed = getDistanceUntilSpeed(targetSpeed, acc);
+  double interval = engine->getInterval();
+  if (distanceUntilTargetSpeed > distance) {
+    return std::ceil(
+        (std::sqrt(vehicleInfo.speed * vehicleInfo.speed + 2 * acc * distance) -
+         vehicleInfo.speed) /
+        acc / interval);
+  } else {
+    return std::ceil((targetSpeed - vehicleInfo.speed) / acc / interval) +
+           std::ceil((distance - distanceUntilTargetSpeed) / targetSpeed /
+                     interval);
+  }
+}
 
-    ControlInfo Vehicle::getNextSpeed(double interval) { // TODO: pass as parameter or not?
-        ControlInfo controlInfo;
-        Drivable *drivable = controllerInfo.drivable;
-        double v = vehicleInfo.maxSpeed;
-        v = min2double(v, vehicleInfo.speed + vehicleInfo.maxPosAcc * interval); // TODO: random???
+int Vehicle::getReachStepsOnLaneLink(double distance,
+                                     LaneLink *laneLink) const {
+  return getReachSteps(distance,
+                       laneLink->isTurn() ? vehicleInfo.turnSpeed
+                                          : vehicleInfo.maxSpeed,
+                       vehicleInfo.usualPosAcc);
+}
 
-        v = min2double(v, drivable->getMaxSpeed());
+double Vehicle::getDistanceUntilSpeed(double speed, double acc) const {
+  if (speed <= vehicleInfo.speed)
+    return 0;
+  double interval = engine->getInterval();
+  int stage1steps = std::floor((speed - vehicleInfo.speed) / acc / interval);
+  double stage1speed = vehicleInfo.speed + stage1steps * acc / interval;
+  double stage1dis =
+      (vehicleInfo.speed + stage1speed) * (stage1steps * interval) / 2;
+  return stage1dis +
+         (stage1speed < speed ? ((stage1speed + speed) * interval / 2) : 0);
+}
 
-        // car follow
-        v = min2double(v, getCarFollowSpeed(interval));
+bool Vehicle::canYield(double dist) const {
+  return (dist > 0 &&
+          getMinBrakeDistance() < dist - vehicleInfo.yieldDistance) ||
+         (dist < 0 && dist + vehicleInfo.len < 0);
+}
 
-        if (isIntersectionRelated()) {
-            v = min2double(v, getIntersectionRelatedSpeed(interval));
-        }
+bool Vehicle::isIntersectionRelated() {
+  if (controllerInfo.drivable->isLaneLink())
+    return true;
+  if (controllerInfo.drivable->isLane()) {
+    Drivable *drivable = getNextDrivable();
+    if (drivable && drivable->isLaneLink() &&
+        controllerInfo.drivable->getLength() - controllerInfo.dis <=
+            controllerInfo.approachingIntersectionDistance) {
+      return true;
+    }
+  }
+  return false;
+}
 
-        if (laneChange){
-            v = min2double(v, laneChange->yieldSpeed(interval));
-            if (!controllerInfo.router.onValidLane()) {
-                double vn = getNoCollisionSpeed(0,1,getSpeed(), getMaxNegAcc(), getCurDrivable()->getLength() - getDistance(), interval, getMinGap());
-                v = min2double(v, vn);
-            }
-        }
+double Vehicle::getBrakeDistanceAfterAccel(double acc, double dec,
+                                           double interval) const {
+  double currentSpeed = vehicleInfo.speed;
+  double nextSpeed = currentSpeed + acc * interval;
+  return (currentSpeed + nextSpeed) * interval / 2 +
+         (nextSpeed * nextSpeed / dec / 2);
+}
 
-        v = max2double(v, vehicleInfo.speed - vehicleInfo.maxNegAcc * interval);
-        controlInfo.speed = v;
+ControlInfo
+Vehicle::getNextSpeed(double interval) { // TODO: pass as parameter or not?
+  ControlInfo controlInfo;
+  Drivable *drivable = controllerInfo.drivable;
+  double v = vehicleInfo.maxSpeed;
+  v = min2double(v, vehicleInfo.speed +
+                        vehicleInfo.maxPosAcc * interval); // TODO: random???
 
-        return controlInfo;
-    }
+  v = min2double(v, drivable->getMaxSpeed());
 
-    double Vehicle::getIntersectionRelatedSpeed(double interval) {
-        double v = vehicleInfo.maxSpeed;
-        Drivable *nextDrivable = getNextDrivable();
-        const LaneLink *laneLink = nullptr;
-        if (nextDrivable && nextDrivable->isLaneLink()) {
-            laneLink = (LaneLink *) nextDrivable;
-            if (!laneLink->isAvailable() || !laneLink->getEndLane()->canEnter(
-                    this)) { // not only the first vehicle should follow intersection logic
-                if (getMinBrakeDistance() > controllerInfo.drivable->getLength() - controllerInfo.dis) {
-                    // TODO: what if it cannot brake before red light?
-                } else {
-                    v = min2double(v, getStopBeforeSpeed(controllerInfo.drivable->getLength() - controllerInfo.dis,
-                                                         interval));
-                    return v;
-                }
-            }
-            if (laneLink->isTurn()) {
-                v = min2double(v, vehicleInfo.turnSpeed); // TODO: define turn speed
-            }
-        }
-        if (laneLink == nullptr && controllerInfo.drivable->isLaneLink())
-            laneLink = static_cast<const LaneLink*>(controllerInfo.drivable);
-        double distanceToLaneLinkStart = controllerInfo.drivable->isLane()
-                                         ? -(controllerInfo.drivable->getLength() - controllerInfo.dis)
-                                         : controllerInfo.dis;
-        double distanceOnLaneLink;
-        for (auto &cross : laneLink->getCrosses()) {
-            distanceOnLaneLink = cross->getDistanceByLane(laneLink);
-            if (distanceOnLaneLink < distanceToLaneLinkStart)
-                continue;
-            if (!cross->canPass(this, laneLink, distanceToLaneLinkStart)) {
-                v = min2double(v, getStopBeforeSpeed(
-                        distanceOnLaneLink - distanceToLaneLinkStart - vehicleInfo.yieldDistance,
-                        interval)); // TODO: headway distance
-                setBlocker(cross->getFoeVehicle(laneLink));
-                break;
-            }
-        }
-        return v;
-    }
+  // car follow
+  v = min2double(v, getCarFollowSpeed(interval));
 
-    void Vehicle::finishChanging() {
-        laneChange->finishChanging();
-        setEnd(true);
-    }
+  // if (isIntersectionRelated()) {
+  v = min2double(v, getIntersectionRelatedSpeed(interval));
+  // }
 
-    void Vehicle::setLane(Lane *nextLane) {
-        controllerInfo.drivable = nextLane;
+  if (laneChange) {
+    v = min2double(v, laneChange->yieldSpeed(interval));
+    if (!controllerInfo.router.onValidLane()) {
+      double vn = getNoCollisionSpeed(
+          0, 1, getSpeed(), getMaxNegAcc(),
+          getCurDrivable()->getLength() - getDistance(), interval, getMinGap());
+      v = min2double(v, vn);
     }
+  }
 
-    Drivable *Vehicle::getCurDrivable() const {
-        return controllerInfo.drivable;
-    }
+  v = max2double(v, vehicleInfo.speed - vehicleInfo.maxNegAcc * interval);
+  controlInfo.speed = v;
 
-    void Vehicle::receiveSignal(Vehicle *sender) {
+  return controlInfo;
+}
 
-        if (laneChange->changing) return;
-        auto signal_recv = laneChange->signalRecv;
-        auto signal_send = laneChange->signalSend;
-        int curPriority = signal_recv ? signal_recv->source->getPriority() : -1;
-        int newPriority = sender->getPriority();
+double Vehicle::getIntersectionRelatedSpeed(double interval) {
+  double v = vehicleInfo.maxSpeed;
+  Drivable *nextDrivable = getNextDrivable();
+  const LaneLink *laneLink = nullptr;
+  // printf("\nNow at Lane %s dis %.2f\n",
+  //        controllerInfo.drivable->getId().c_str(), controllerInfo.dis);
+  if (nextDrivable && nextDrivable->isLaneLink()) {
+    laneLink = (LaneLink *)nextDrivable;
+    if (!laneLink->isAvailable() || !laneLink->getEndLane()->canEnter(this)) {
+      auto d = controllerInfo.drivable->getLength() - controllerInfo.dis;
+      if (getMinBrakeDistance() > d) {
+        // printf("\nCannot stop\n");
+      } else {
+        v = min2double(v, getStopBeforeSpeed(d - 1, interval));
+        // printf("\nTry to stop at %.2f with v=%.2f v0=%.2f\n", d, v,
+        // getSpeed());
+      }
+    }
+    if (laneLink->isTurn()) {
+      v = min2double(v, vehicleInfo.turnSpeed); // TODO: define turn speed
+    }
+  }
+  // 
+  // if (laneLink == nullptr && controllerInfo.drivable->isLaneLink())
+  //   laneLink = static_cast<const LaneLink *>(controllerInfo.drivable);
+  // double distanceToLaneLinkStart =
+  //     controllerInfo.drivable->isLane()
+  //         ? -(controllerInfo.drivable->getLength() - controllerInfo.dis)
+  //         : controllerInfo.dis;
+  // double distanceOnLaneLink;
+  // for (auto &cross : laneLink->getCrosses()) {
+  //   distanceOnLaneLink = cross->getDistanceByLane(laneLink);
+  //   if (distanceOnLaneLink < distanceToLaneLinkStart)
+  //     continue;
+  //   if (!cross->canPass(this, laneLink, distanceToLaneLinkStart)) {
+  //     v = min2double(v, getStopBeforeSpeed(distanceOnLaneLink -
+  //                                              distanceToLaneLinkStart -
+  //                                              vehicleInfo.yieldDistance,
+  //                                          interval)); // TODO: headway
+  //                                          distance
+  //     setBlocker(cross->getFoeVehicle(laneLink));
+  //     break;
+  //   }
+  // }
+  return v;
+}
 
-        if ((!signal_recv || curPriority < newPriority) && (!signal_send || priority < newPriority) )
-            laneChange->signalRecv = sender->laneChange->signalSend;
-    }
+void Vehicle::finishChanging() {
+  laneChange->finishChanging();
+  setEnd(true);
+}
 
-    std::list<Vehicle *>::iterator Vehicle::getListIterator() {
-        assert(getCurDrivable()->isLane());
-        Segment *seg = ((Lane *)getCurDrivable())->getSegment(getSegmentIndex());
+Drivable *Vehicle::getCurDrivable() const { return controllerInfo.drivable; }
 
+void Vehicle::receiveSignal(Vehicle *sender) {
 
-        auto result = seg->findVehicle(this);
-        return result;
-    }
+  if (laneChange->changing)
+    return;
+  auto signal_recv = laneChange->signalRecv;
+  auto signal_send = laneChange->signalSend;
+  int curPriority = signal_recv ? signal_recv->source->getPriority() : -1;
+  int newPriority = sender->getPriority();
 
-    void Vehicle::abortLaneChange() {
-        assert(laneChangeInfo.partner);
-        this->setEnd(true);
-        laneChange->abortChanging();
-    }
+  if ((!signal_recv || curPriority < newPriority) &&
+      (!signal_send || priority < newPriority))
+    laneChange->signalRecv = sender->laneChange->signalSend;
+}
 
-    Road *Vehicle::getFirstRoad() {
-        return controllerInfo.router.getFirstRoad();
-    }
+std::list<Vehicle *>::iterator Vehicle::getListIterator() {
+  assert(getCurDrivable()->isLane());
+  Segment *seg = ((Lane *)getCurDrivable())->getSegment(getSegmentIndex());
 
-    void Vehicle::setFirstDrivable() {
-        controllerInfo.drivable = controllerInfo.router.getFirstDrivable();
-    }
+  auto result = seg->findVehicle(this);
+  return result;
+}
 
-    void Vehicle::updateRoute() {
-        routeValid = controllerInfo.router.updateShortestPath();
-    }
+void Vehicle::abortLaneChange() {
+  assert(laneChangeInfo.partner);
+  this->setEnd(true);
+  laneChange->abortChanging();
+}
 
-    bool Vehicle::setRoute(const std::vector<Road *> &anchor) {
-        return controllerInfo.router.setRoute(anchor);
-    }
+Road *Vehicle::getFirstRoad() { return controllerInfo.router.getFirstRoad(); }
 
+void Vehicle::setFirstDrivable() {
+  controllerInfo.drivable = controllerInfo.router.getFirstDrivable();
+}
 
-    std::map<std::string, std::string> Vehicle::getInfo() const{
-        std::map<std::string, std::string> info;
-        info["running"] = std::to_string(isRunning());
-        if (!isRunning()) return info;
+void Vehicle::updateRoute() {
+  routeValid = controllerInfo.router.updateShortestPath();
+}
 
-        info["distance"] = std::to_string(getDistance());
-        info["speed"] = std::to_string(getSpeed());
-        const auto &drivable = getCurDrivable();
-        info["drivable"] = drivable->getId();
-        const auto &road = drivable->isLane() ? getCurLane()->getBelongRoad() : nullptr;
-        if (road) {
-            info["road"] = road->getId();
-            info["intersection"] = road->getEndIntersection().getId();
-        }
-        // add routing info
-        std::string route;
-        for (const auto &r : controllerInfo.router.getFollowingRoads()) {
-            route += r->getId() + " ";
-        }
-        info["route"] = route;
+bool Vehicle::setRoute(const std::vector<Road *> &anchor) {
+  return controllerInfo.router.setRoute(anchor);
+}
 
-        return info;
-    }
+std::map<std::string, std::string> Vehicle::getInfo() const {
+  std::map<std::string, std::string> info;
+  info["running"] = std::to_string(isRunning());
+  if (!isRunning())
+    return info;
+
+  info["distance"] = std::to_string(getDistance());
+  info["speed"] = std::to_string(getSpeed());
+  const auto &drivable = getCurDrivable();
+  info["drivable"] = drivable->getId();
+  const auto &road =
+      drivable->isLane() ? getCurLane()->getBelongRoad() : nullptr;
+  if (road) {
+    info["road"] = road->getId();
+    info["intersection"] = road->getEndIntersection().getId();
+  }
+  // add routing info
+  std::string route;
+  for (const auto &r : controllerInfo.router.getFollowingRoads()) {
+    route += r->getId() + " ";
+  }
+  info["route"] = route;
+
+  return info;
 }
+} // namespace CityFlow
diff --git a/src/vehicle/vehicle.h b/src/vehicle/vehicle.h
index db0537c..90aa900 100644
--- a/src/vehicle/vehicle.h
+++ b/src/vehicle/vehicle.h
@@ -1,372 +1,391 @@
 #ifndef CITYFLOW_VEHICLE
 #define CITYFLOW_VEHICLE
 
-#include "utility/utility.h"
 #include "flow/route.h"
-#include "vehicle/router.h"
+#include "utility/utility.h"
 #include "vehicle/lanechange.h"
+#include "vehicle/router.h"
 
-#include <utility>
 #include <memory>
+#include <utility>
 
 namespace CityFlow {
-    class Lane;
-
-    class LaneLink;
-
-    class Intersection;
-
-    class Route;
-
-    class Cross;
-
-    class Drivable;
-
-    class Engine;
-
-    class Point;
-
-    class Flow;
-
-    struct VehicleInfo {
-        double speed = 0;
-        double len = 5;
-        double width = 2;
-        double maxPosAcc = 4.5;
-        double maxNegAcc = 4.5;
-        double usualPosAcc = 2.5;
-        double usualNegAcc = 2.5;
-        double minGap = 2;
-        double maxSpeed = 16.66667;
-        double headwayTime = 1;
-        double yieldDistance = 5;
-        double turnSpeed = 8.3333;
-        std::shared_ptr<const Route> route = nullptr;
-    };
-
-
-    class Vehicle {
-        friend class Router;
-        friend class LaneChange;
-        friend class SimpleLaneChange;
-        friend class Archive;
-    private:
-        struct Buffer {
-            bool isDisSet = false;
-            bool isSpeedSet = false;
-            bool isDrivableSet = false;
-            bool isNotifiedVehicles = false;
-            bool isEndSet = false;
-            bool isEnterLaneLinkTimeSet = false;
-            bool isBlockerSet = false;
-            bool isCustomSpeedSet = false;
-            double dis;
-            double deltaDis;
-            double speed;
-            double customSpeed;
-            Drivable *drivable;
-            std::vector<Vehicle *> notifiedVehicles;
-            bool end;
-            Vehicle *blocker = nullptr;
-            size_t enterLaneLinkTime;
-        };
-
-        struct LaneChangeInfo {
-            short partnerType = 0; //0 for no partner; 1 for real vehicle; 2 for shadow vehicle;
-            Vehicle *partner = nullptr;
-            double offset = 0;
-            size_t segmentIndex = 0;
-        };
-
-        struct ControllerInfo {
-            double dis = 0;
-            Drivable *drivable = nullptr;
-            Drivable *prevDrivable = nullptr;
-            double approachingIntersectionDistance;
-            double gap;
-            size_t enterLaneLinkTime;
-            Vehicle *leader = nullptr;
-            Vehicle *blocker = nullptr;
-            bool end = false;
-            bool running = false;
-            Router router;
-            ControllerInfo(Vehicle *vehicle, std::shared_ptr<const Route> route, std::mt19937 *rnd);
-            ControllerInfo(Vehicle *vehicle, const ControllerInfo &other);
-        };
-
-        VehicleInfo vehicleInfo;
-        ControllerInfo controllerInfo;
-        LaneChangeInfo laneChangeInfo;
-
-        Buffer buffer;
+class Lane;
+
+class LaneLink;
+
+class Intersection;
+
+class Route;
+
+class Cross;
+
+class Drivable;
+
+class Engine;
+
+class Point;
+
+class Flow;
+
+struct VehicleInfo {
+  double speed = 0;
+  double len = 5;
+  double width = 2;
+  double maxPosAcc = 4.5;
+  double maxNegAcc = 4.5;
+  double usualPosAcc = 2.5;
+  double usualNegAcc = 2.5;
+  double minGap = 2;
+  double maxSpeed = 16.66667;
+  double headwayTime = 1;
+  double yieldDistance = 5;
+  double turnSpeed = 8.3333;
+  std::shared_ptr<const Route> route = nullptr;
+};
+
+class Vehicle {
+  friend class Router;
+  friend class LaneChange;
+  friend class SimpleLaneChange;
+  friend class Archive;
+
+private:
+  struct Buffer {
+    bool isDisSet = false;
+    bool isSpeedSet = false;
+    bool isDrivableSet = false;
+    bool isNotifiedVehicles = false;
+    bool isEndSet = false;
+    bool isEnterLaneLinkTimeSet = false;
+    bool isBlockerSet = false;
+    bool isCustomSpeedSet = false;
+    double dis;
+    double deltaDis;
+    double speed;
+    double customSpeed;
+    Drivable *drivable;
+    std::vector<Vehicle *> notifiedVehicles;
+    bool end;
+    Vehicle *blocker = nullptr;
+    size_t enterLaneLinkTime;
+  };
+
+  struct LaneChangeInfo {
+    short partnerType =
+        0; // 0 for no partner; 1 for real vehicle; 2 for shadow vehicle;
+    Vehicle *partner = nullptr;
+    double offset = 0;
+    size_t segmentIndex = 0;
+  };
 
-        int priority;
-        std::string id;
-        double enterTime;
+  struct ControllerInfo {
+    double dis = 0;
+    Drivable *drivable = nullptr;
+    Drivable *prevDrivable = nullptr;
+    double approachingIntersectionDistance;
+    double gap;
+    size_t enterLaneLinkTime;
+    Vehicle *leader = nullptr;
+    Vehicle *blocker = nullptr;
+    bool end = false;
+    bool running = false;
+    Router router;
+    ControllerInfo(Vehicle *vehicle, std::shared_ptr<const Route> route,
+                   std::mt19937 *rnd);
+    ControllerInfo(Vehicle *vehicle, const ControllerInfo &other);
+  };
 
-        Engine *engine;
+  VehicleInfo vehicleInfo;
+  LaneChangeInfo laneChangeInfo;
 
-        std::shared_ptr<LaneChange> laneChange;
+  Buffer buffer;
 
-        bool routeValid = false;
-        Flow *flow;
+  int priority;
+  std::string id;
+  double enterTime;
 
-    public:
+  Engine *engine;
 
-        bool isStraightHold = false;
+  std::shared_ptr<LaneChange> laneChange;
 
-        Vehicle(const Vehicle &vehicle, Flow *flow = nullptr);
+  bool routeValid = false;
+  Flow *flow;
 
-        Vehicle(const Vehicle &vehicle, const std::string &id, Engine *engine, Flow *flow = nullptr);
+public:
+  ControllerInfo controllerInfo;
+  bool isStraightHold = false;
 
-        Vehicle(const VehicleInfo &init, const std::string &id, Engine *engine, Flow *flow = nullptr);
+  Vehicle(const Vehicle &vehicle, Flow *flow = nullptr);
 
-        void setDeltaDistance(double dis);
+  Vehicle(const Vehicle &vehicle, const std::string &id, Engine *engine,
+          Flow *flow = nullptr);
 
-        void setSpeed(double speed);
+  Vehicle(const VehicleInfo &init, const std::string &id, Engine *engine,
+          Flow *flow = nullptr);
 
-        void setCustomSpeed(double speed) {
-            buffer.customSpeed = speed;
-            buffer.isCustomSpeedSet = true;
-        }
+  void setDeltaDistance(double dis);
 
-        void setDis(double dis) {
-            buffer.dis = dis;
-            buffer.isDisSet = true;
-        }
+  void setSpeed(double speed);
 
-        void setDrivable(Drivable *drivable) {
-            buffer.drivable = drivable;
-            buffer.isDrivableSet = true;
-        }
+  void setCustomSpeed(double speed) {
+    buffer.customSpeed = speed;
+    buffer.isCustomSpeedSet = true;
+  }
 
-        bool hasSetDrivable() const { return buffer.isDrivableSet; }
+  void setDis(double dis) {
+    buffer.dis = dis;
+    buffer.isDisSet = true;
+  }
 
-        bool hasSetSpeed() const { return buffer.isSpeedSet; }
+  void setDrivable(Drivable *drivable) {
+    buffer.drivable = drivable;
+    buffer.isDrivableSet = true;
+  }
 
-        bool hasSetCustomSpeed() const { return buffer.isCustomSpeedSet; }
+  bool hasSetDrivable() const { return buffer.isDrivableSet; }
 
-        double getBufferSpeed() const { return buffer.speed; };
+  bool hasSetSpeed() const { return buffer.isSpeedSet; }
 
-        bool hasSetEnd() const { return buffer.isEndSet; }
+  bool hasSetCustomSpeed() const { return buffer.isCustomSpeedSet; }
 
-        void setEnd(bool end) {
-            buffer.end = end;
-            buffer.isEndSet = true;
-        }
+  double getBufferSpeed() const { return buffer.speed; };
 
-        void unSetEnd() { buffer.isEndSet = false; }
+  bool hasSetEnd() const { return buffer.isEndSet; }
 
-        void unSetDrivable() { buffer.isDrivableSet = false; }
+  void setEnd(bool end) {
+    buffer.end = end;
+    buffer.isEndSet = true;
+  }
 
-        void setEnterLaneLinkTime(size_t enterLaneLinkTime) {
-            buffer.enterLaneLinkTime = enterLaneLinkTime;
-            buffer.isEnterLaneLinkTimeSet = true;
-        }
+  void unSetEnd() { buffer.isEndSet = false; }
 
-        void setBlocker(Vehicle *blocker) {
-            buffer.blocker = blocker;
-            buffer.isBlockerSet = true;
-        }
+  void unSetDrivable() { buffer.isDrivableSet = false; }
 
-        double getBufferDis() const { return buffer.dis; }
+  void setEnterLaneLinkTime(size_t enterLaneLinkTime) {
+    buffer.enterLaneLinkTime = enterLaneLinkTime;
+    buffer.isEnterLaneLinkTimeSet = true;
+  }
 
-        void update();
+  void setBlocker(Vehicle *blocker) {
+    buffer.blocker = blocker;
+    buffer.isBlockerSet = true;
+  }
 
-        void setPriority(int priority) { this->priority = priority; }
+  double getBufferDis() const { return buffer.dis; }
 
-        inline std::string getId() const { return id; }
+  void update();
 
-        inline double getSpeed() const { return vehicleInfo.speed; }
+  void setPriority(int priority) { this->priority = priority; }
 
-        inline double getLen() const { return vehicleInfo.len; }
+  inline std::string getId() const { return id; }
 
-        inline double getWidth() const { return vehicleInfo.width; }
+  inline double getSpeed() const { return vehicleInfo.speed; }
 
-        inline double getDistance() const { return controllerInfo.dis; }
+  inline double getLen() const { return vehicleInfo.len; }
 
-        Point getPoint() const;
+  inline double getWidth() const { return vehicleInfo.width; }
 
-        inline double getMaxPosAcc() const { return vehicleInfo.maxPosAcc; }
+  inline double getDistance() const { return controllerInfo.dis; }
 
-        inline double getMaxNegAcc() const { return vehicleInfo.maxNegAcc; }
+  Point getPoint() const;
 
-        inline double getUsualPosAcc() const { return vehicleInfo.usualPosAcc; }
+  inline double getMaxPosAcc() const { return vehicleInfo.maxPosAcc; }
 
-        inline double getUsualNegAcc() const { return vehicleInfo.usualNegAcc; }
+  inline double getMaxNegAcc() const { return vehicleInfo.maxNegAcc; }
 
-        inline double getMinGap() const { return vehicleInfo.minGap; }
+  inline double getUsualPosAcc() const { return vehicleInfo.usualPosAcc; }
 
-        inline double getYieldDistance() const { return vehicleInfo.yieldDistance; }
+  inline double getUsualNegAcc() const { return vehicleInfo.usualNegAcc; }
 
-        inline double getTurnSpeed() const { return vehicleInfo.turnSpeed; }
+  inline double getMinGap() const { return vehicleInfo.minGap; }
 
-        inline Vehicle *getBlocker() const { return controllerInfo.blocker; }
+  inline double getYieldDistance() const { return vehicleInfo.yieldDistance; }
 
-        inline Vehicle *getBufferBlocker() { return buffer.blocker; }
+  inline double getTurnSpeed() const { return vehicleInfo.turnSpeed; }
 
-        Drivable *getCurDrivable() const;
+  inline Vehicle *getBlocker() const { return controllerInfo.blocker; }
 
-        Lane * getCurLane() const {
-            if (getCurDrivable()->isLane()) return (Lane *)getCurDrivable();
-            else return nullptr;
-        }
+  inline Vehicle *getBufferBlocker() { return buffer.blocker; }
 
-        inline Drivable *getNextDrivable(int i = 0) {
-            return controllerInfo.router.getNextDrivable(i);
-        }
+  Drivable *getCurDrivable() const;
 
-        inline Drivable *getPrevDrivable(int i = 1) const {
-            return controllerInfo.prevDrivable;
-        }
+  Lane *getCurLane() const {
+    if (getCurDrivable()->isLane())
+      return (Lane *)getCurDrivable();
+    else
+      return nullptr;
+  }
 
-        inline int getPriority() const { return priority; }
+  inline Drivable *getNextDrivable(int i = 0) {
+    return controllerInfo.router.getNextDrivable(i);
+  }
 
-        std::pair<Point, Point> getCurPos() const;
+  inline Drivable *getPrevDrivable(int i = 1) const {
+    return controllerInfo.prevDrivable;
+  }
 
-        ControlInfo getNextSpeed(double interval);
+  inline int getPriority() const { return priority; }
 
-        Drivable *getChangedDrivable() const;
+  std::pair<Point, Point> getCurPos() const;
 
-        double getEnterTime() const { return enterTime; }
+  ControlInfo getNextSpeed(double interval);
 
-        bool isEnd() const { return controllerInfo.end; }
+  Drivable *getChangedDrivable() const;
 
-        bool isIntersectionRelated();
+  double getEnterTime() const { return enterTime; }
 
-        double getBrakeDistanceAfterAccel(double acc, double dec, double interval) const;
+  bool isEnd() const { return controllerInfo.end; }
 
-        inline double getMinBrakeDistance() const { return 0.5 * vehicleInfo.speed * vehicleInfo.speed / vehicleInfo.maxNegAcc; }
+  bool isIntersectionRelated();
 
-        inline double getUsualBrakeDistance() const { return 0.5 * vehicleInfo.speed * vehicleInfo.speed / vehicleInfo.usualNegAcc; }
+  double getBrakeDistanceAfterAccel(double acc, double dec,
+                                    double interval) const;
 
-        double getNoCollisionSpeed(double vL, double dL, double vF, double dF, double gap, double interval,
-            double targetGap) const;
+  inline double getMinBrakeDistance() const {
+    return 0.5 * vehicleInfo.speed * vehicleInfo.speed / vehicleInfo.maxNegAcc;
+  }
 
-        double getCarFollowSpeed(double interval);
+  inline double getUsualBrakeDistance() const {
+    return 0.5 * vehicleInfo.speed * vehicleInfo.speed /
+           vehicleInfo.usualNegAcc;
+  }
 
-        double getStopBeforeSpeed(double distance, double interval) const;
+  double getNoCollisionSpeed(double vL, double dL, double vF, double dF,
+                             double gap, double interval,
+                             double targetGap) const;
 
-        int getReachSteps(double distance, double targetSpeed, double acc) const;
+  double getCarFollowSpeed(double interval);
 
-        int getReachStepsOnLaneLink(double distance, LaneLink* laneLink) const;
+  double getStopBeforeSpeed(double distance, double interval) const;
 
-        double getDistanceUntilSpeed(double speed, double acc) const;
+  int getReachSteps(double distance, double targetSpeed, double acc) const;
 
-        bool canYield(double dist) const;
+  int getReachStepsOnLaneLink(double distance, LaneLink *laneLink) const;
 
-        void updateLeaderAndGap(Vehicle *leader);
+  double getDistanceUntilSpeed(double speed, double acc) const;
 
-        Vehicle *getLeader() const { return controllerInfo.leader; }
+  bool canYield(double dist) const;
 
-        inline double getEnterLaneLinkTime() const { return controllerInfo.enterLaneLinkTime; }
+  void updateLeaderAndGap(Vehicle *leader);
 
-        inline double getHeadwayTime() const { return vehicleInfo.headwayTime; }
+  Vehicle *getLeader() const { return controllerInfo.leader; }
 
-        inline double getMaxSpeed() const { return vehicleInfo.maxSpeed; }
+  inline double getEnterLaneLinkTime() const {
+    return controllerInfo.enterLaneLinkTime;
+  }
 
-        inline double getApproachingIntersectionDistance() const { return 0.0; }
+  inline double getHeadwayTime() const { return vehicleInfo.headwayTime; }
 
-        double getIntersectionRelatedSpeed(double interval);
+  inline double getMaxSpeed() const { return vehicleInfo.maxSpeed; }
 
-        inline bool isRunning() const { return controllerInfo.running; }
+  inline double getApproachingIntersectionDistance() const { return 0.0; }
 
-        inline void setRunning(bool isRunning = true) { controllerInfo.running = isRunning; }
+  double getIntersectionRelatedSpeed(double interval);
 
-        inline bool hasPartner() const { return laneChangeInfo.partnerType > 0; }
+  inline bool isRunning() const { return controllerInfo.running; }
 
-        inline bool isReal() const { return laneChangeInfo.partnerType != 2; }
+  inline void setRunning(bool isRunning = true) {
+    controllerInfo.running = isRunning;
+  }
 
-        inline size_t getSegmentIndex() const { return laneChangeInfo.segmentIndex; }
+  inline bool hasPartner() const { return laneChangeInfo.partnerType > 0; }
 
-        inline void setSegmentIndex(int segmentIndex) { laneChangeInfo.segmentIndex = segmentIndex; }
+  inline bool isReal() const { return laneChangeInfo.partnerType != 2; }
 
-        inline void setShadow(Vehicle *veh) { laneChangeInfo.partnerType = 1, laneChangeInfo.partner = veh; }
+  inline size_t getSegmentIndex() const { return laneChangeInfo.segmentIndex; }
 
-        inline void setParent(Vehicle *veh) { laneChangeInfo.partnerType = 2, laneChangeInfo.partner = veh; }
+  inline void setSegmentIndex(int segmentIndex) {
+    laneChangeInfo.segmentIndex = segmentIndex;
+  }
 
-        void setLane(Lane *nextLane);
+  inline void setShadow(Vehicle *veh) {
+    laneChangeInfo.partnerType = 1, laneChangeInfo.partner = veh;
+  }
 
-        void finishChanging();
+  inline void setParent(Vehicle *veh) {
+    laneChangeInfo.partnerType = 2, laneChangeInfo.partner = veh;
+  }
 
-        inline void setOffset(double offset) { laneChangeInfo.offset = offset; }
+  void finishChanging();
 
-        inline double getOffset() const { return laneChangeInfo.offset; }
+  inline void setOffset(double offset) { laneChangeInfo.offset = offset; }
 
-        inline Vehicle *getPartner() const { return laneChangeInfo.partner; }
+  inline double getOffset() const { return laneChangeInfo.offset; }
 
-        inline void setId(const std::string & id) { this->id = id; }
+  inline Vehicle *getPartner() const { return laneChangeInfo.partner; }
 
-        //for lane change
-        inline void makeLaneChangeSignal(double interval){
-            laneChange->makeSignal(interval);
-        }
+  inline void setId(const std::string &id) { this->id = id; }
 
-        inline bool planLaneChange(){
-            return laneChange->planChange();
-        }
+  // for lane change
+  inline void makeLaneChangeSignal(double interval) {
+    laneChange->makeSignal(interval);
+  }
 
-        void receiveSignal(Vehicle * sender);
+  inline bool planLaneChange() { return laneChange->planChange(); }
 
-        void sendSignal() { laneChange->sendSignal(); }
+  void receiveSignal(Vehicle *sender);
 
-        void clearSignal(){ laneChange->clearSignal(); }
+  void sendSignal() { laneChange->sendSignal(); }
 
-        void updateLaneChangeNeighbor(){ laneChange->updateLeaderAndFollower(); }
+  void clearSignal() { laneChange->clearSignal(); }
 
-        std::shared_ptr<LaneChange> getLaneChange(){ return laneChange; }
+  void updateLaneChangeNeighbor() { laneChange->updateLeaderAndFollower(); }
 
-        std::list<Vehicle *>::iterator getListIterator();
+  std::shared_ptr<LaneChange> getLaneChange() { return laneChange; }
 
-        void insertShadow(Vehicle *shadow) { laneChange->insertShadow(shadow); }
+  std::list<Vehicle *>::iterator getListIterator();
 
-        bool onValidLane() const{ return controllerInfo.router.onValidLane(); }
+  void insertShadow(Vehicle *shadow) { laneChange->insertShadow(shadow); }
 
-        Lane * getValidLane() const{
-            assert(getCurDrivable()->isLane());
-            return controllerInfo.router.getValidLane(dynamic_cast<Lane *>(getCurDrivable()));
-        }
+  bool onValidLane() const { return controllerInfo.router.onValidLane(); }
 
-        bool canChange() const{ return laneChange->canChange(); }
+  Lane *getValidLane() const {
+    assert(getCurDrivable()->isLane());
+    return controllerInfo.router.getValidLane(
+        dynamic_cast<Lane *>(getCurDrivable()));
+  }
 
-        double getGap() const{ return controllerInfo.gap; }
+  bool canChange() const { return laneChange->canChange(); }
 
-        int laneChangeUrgency() const { return laneChange->signalSend->urgency; }
+  double getGap() const { return controllerInfo.gap; }
 
-        Vehicle *getTargetLeader() const { return laneChange->targetLeader; }
+  int laneChangeUrgency() const { return laneChange->signalSend->urgency; }
 
-        int lastLaneChangeDirection() const { return laneChange->lastDir; }
+  Vehicle *getTargetLeader() const { return laneChange->targetLeader; }
 
-        int getLaneChangeDirection() const {
-            if (!laneChange->signalSend) return 0;
-            return laneChange->signalSend->direction;
-        }
+  int lastLaneChangeDirection() const { return laneChange->lastDir; }
 
-        bool isChanging() const { return laneChange->changing; }
+  int getLaneChangeDirection() const {
+    if (!laneChange->signalSend)
+      return 0;
+    return laneChange->signalSend->direction;
+  }
 
-        double getMaxOffset() const {
-            auto target = laneChange->signalSend->target;
-            return (target->getWidth() + getCurLane()->getWidth()) / 2;
-        }
+  bool isChanging() const { return laneChange->changing; }
 
-        void abortLaneChange() ;
+  double getMaxOffset() const {
+    auto target = laneChange->signalSend->target;
+    return (target->getWidth() + getCurLane()->getWidth()) / 2;
+  }
 
-        void updateRoute();
+  void abortLaneChange();
 
-        Road *getFirstRoad();
+  void updateRoute();
 
-        void setFirstDrivable();
+  Road *getFirstRoad();
 
-        bool isRouteValid() const { return this->routeValid; }
+  void setFirstDrivable();
 
-        Flow *getFlow() { return flow; }
+  bool isRouteValid() const { return this->routeValid; }
 
-        bool setRoute(const std::vector<Road *> &anchor);
+  Flow *getFlow() { return flow; }
 
-        std::map<std::string, std::string> getInfo() const;
+  bool setRoute(const std::vector<Road *> &anchor);
 
-     };
+  std::map<std::string, std::string> getInfo() const;
+};
 
-}
+} // namespace CityFlow
 
 #endif
\ No newline at end of file
